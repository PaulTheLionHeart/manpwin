/*
   OSCILLATORS.CPP a module to explore Chaotic Oscillators
   The Duffing oscillator is an example of a periodically forced oscillator with a nonlinear elasticity Thanks to Takashi Kanamaru (2008) 

   Written in Microsoft Visual C++ by Paul de Leeuw.
*/

#include	<stdio.h>
#include	<time.h>
#include	"manp.h"
#include	"Fract.h"
#include	"resource.h"
#include	"fractype.h"
#include	"fractalp.h"
#include	"menu.h"
#include	"anim.h"
#include	"OscProcess.h"

extern	HWND	GlobalHwnd;			// This is the main windows handle

extern	int	user_data(HWND);
extern	void	InitTransformation(double tx, double ty, double tz);
extern	void	DoTransformation(double *x1, double *y1, double *z1, double x, double y, double z);
extern	char	*GetFractalName(void);
extern	double	GetNumFrames(void);
extern	void	PrintOsc(int);			// used for listing oscillator names in d:\temp\OscDump.txt

extern	double	x_rot;				// angle display plane to x axis
extern	double	y_rot;				// angle display plane to y axis
extern	double	z_rot;				// angle display plane to z axis

extern	int	xdots, ydots;

extern	long	threshold;
extern	double	mandel_width;			// width of display 
extern	double	hor;				// horizontal address 
extern	double	vert;				// vertical address 
extern	double	ScreenRatio;			// ratio of width / height for the screen
extern	double	param[];
extern	WORD	type;				// fractal type
extern	int	subtype;			// A - E
extern	int	curpass, totpasses;
extern	BOOL	RemoveHiddenPixels;
BOOL	DisplayLines;
	BOOL	DisplayAxes = FALSE;		// display axes for oscillator etc
	BOOL	PlotCentre = FALSE;		// display circle at the centre of the oscillator
	int	CentrePixels = 5;		// radius of the display circle at the centre of the oscillator in pixels
	BOOL	BlockAnimation = FALSE;		// used for 2D or less to preventanimating non-existent dimensions
extern	BOOL	FractalMapColouring;
extern	BOOL	RemoveHiddenPixels;		// used in Surfaces
static	double	xscale, yscale;
	double	iterations = 20000;
	double	dt = 0.001;			// delta time
	int	OscillatorPtr = 0, OscillatorNum = 0;
	double	VertBias = 1.0;			// allow vertical stretching of the image
	double	zBias = 1.0;			// allow stretching of the image in the z direction
	char	AxesText[16];			// used to convert axes and display them
static	double	FrameCounter = 0.0;		// count which animation frame we are doing for evolution animation
	int	OscPtrArray[MAXOSC];		// array of pointers to specific oscillators or fractal maps

static	double	cMax[MAXDIM], cMin[MAXDIM], cTot[MAXDIM];
static	double	xSum, ySum, zSum;
	int	MaxDimensions;
	int	NumParams;			// number of parameters in this oscillator or fractal map
	int	NumVariables;			// number of variables in this oscillator or fractal map
	int	xSign, ySign;			// sign of x and y axes - allow reflection of image across axis

	int	xAxis = 0, yAxis = 1, zAxis = 2;// numerical values for axes. assume normal x = 0, y = 1 and z = 2
	int	CoordSystem = CARTESIAN;
	int	FindCentre = AVERAGE;		// statistical average or contained volume
	BYTE	PerspectiveFlag = FALSE;	// display using perspective

	RGBTRIPLE   OscBackGround = {0,0,0};

extern	double 	*wpixels;			// an array of doubles holding slope modified iteration counts

extern	CPlot	Plot;		// image plotting routines 
extern	CTrueCol    TrueCol;			// palette info
	ProcessType	OscAnimProc = STANDARD;
COscProcess	OscProcess;

extern	CDib	Dib;				// Device Independent Bitmap

/**************************************************************************
	Common init Routines
***************************************************************************/

void	InitOscillator(double c1[], int dimensions)
    {
    OscProcess.InitOscProc(dimensions, mandel_width, ScreenRatio, xdots, ydots, type, subtype, OscAnimProc, &xAxis, &yAxis, &zAxis, FindCentre, &Dib, c1, PerspectiveFlag, iterations, OscBackGround, &x_rot, &y_rot, &z_rot, &RemoveHiddenPixels, GlobalHwnd, wpixels, &TrueCol);
    }

/**************************************************************************
	Common Display Routines
***************************************************************************/

int	DisplayOscillator(double c1[], double cn[], double dt, DWORD colour, double i, int dimensions, int spare)
    {
    return OscProcess.DisplayOscillator(c1, cn, dt, colour, i, dimensions, DisplayLines, xSign, ySign, hor, vert, VertBias, zBias, OscAnimProc, CoordSystem, threshold, 0.0, 0);
    }

/**************************************************************************
	Plot additional information
***************************************************************************/

void	PlotExtras(void)
    {
    if (OscAnimProc != RUNANIM)
	return;
    if (DisplayAxes)
	OscProcess.PlotAxes();
    if (PlotCentre)
	OscProcess.PlotCircle(CentrePixels);
    }

/**************************************************************************
	2D and 3D Solvable Maps
	Shunji Kawamoto 2017
***************************************************************************/

int	Do2Dand3DSolvableMaps(void)

    {
    double	i, c1[3], cn[3];
//    short	i;			// for Marcus experiment

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[0] + c1[1] * c1[2];
	cn[2] = 1.0 - c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A 3D Autonomous Continuous System with Two Isolated Chaotic Attractors and Its Topological Horseshoes
	Ping Zhou and Meihua Ke 21 November 2017
***************************************************************************/

int	DoA3DAutonomousContinuousSystem(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[0] + 0.5 * c1[0] * c1[2] + c1[1] * c1[2];
	cn[1] = a * c1[1] - 1.2 * c1[0] * c1[2];
	cn[2] = c1[0] * c1[1] - 6.0 * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A 3D Jerk System, Its Bifurcation Analysis, Electronic Circuit Design and a Cryptographic Application
	Sundarapandian Vaidyanathan, Alain Soup Tewa Kammogne, Esteban Tlelo-Cuautle, Cedric Noufozo Talonang, 
	Bassem Abd-El-Atty, Ahmed A. Abd El-Latif, Edwige Mache Kengne, Vannick Fopa Mawamba, Aceng Sambas, P. Darwin  and Brisbane Ovilla-Martinez 2023
	https://www.mdpi.com/2079-9292/12/13/2818....https://doi.org/10.3390/electronics12132818
	Author to contact etlelo@inaoep.mx Esteban Tlelo-Cuautle
***************************************************************************/

int	DoA3DJerkSystem(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = -a * c1[2] - c1[0] * (c1[0] * c1[0] + c1[0] * c1[1] + c1[1] * c1[1] - b);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Four-Dimensional Chaotic System with FIRST Lyapunov EXPONENT of About 22, Hyperbolic Curve and Circular Paraboloid Types of Equilibria and its Switching Synchronization by an Adaptive Global Integral Sliding Mode Control 
	Jay Prakash Singh, Binoy Krishna Roy and Zhouchao Wei 10 March 2018
	https://www.researchgate.net/publication/324669667_A_new_four-dimensional_chaotic_system_with_first_Lyapunov_exponent_of_about_22_hyperbolic_curve_and_circular_paraboloid_types_of_equilibria_and_its_switching_synchronization_by_an_adaptive_global_inte
***************************************************************************/

int	Do4DChaoticSystem1stLyapunovExponent22(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, p;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    p = param[4];

    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[1] - c1[1] * c1[2] - c1[0] * c1[2];
	cn[1] = b * c1[0] * c1[2];
	cn[2] = c1[1] * c1[1] - c * c1[2] * c1[2] + c1[3] * c1[3] - p;
	cn[3] = -d * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	4-D Memristive Chaotic System with Different Families of Hidden Attractors
	Dimitrios A. Prousalis, Christos K. Volos, Viet-Thanh Pham, Ioannis N. Stouboulos and Ioannis M. Kyprianidis 2018
	https://www.researchgate.net/requests/r41338629
***************************************************************************/

int	DoA4DMemristiveChaoticSystem(void)

    {
    double	i, c1[4], cn[4], alpha, beta, gamma, delta, eta, f, epsilon;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    alpha = param[0];
    beta = param[1];
    gamma = param[2];
    delta = param[3];
    eta = param[4];
    epsilon = param[5];
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	f = (1.0 + 0.25 * c1[3] * c1[3] - 0.002 * c1[3] * c1[3] * c1[3] * c1[3]) * c1[1];
	cn[0] = -alpha * c1[0] + gamma * f;
	cn[1] = beta * c1[0]/* - delta * c1[0] * c1[2]*/ + epsilon;	// more Marcus shit coding
	cn[2] = -eta * c1[2] + c1[0] * c1[1];
	cn[3] = c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A 3D Strange Attractor with a Distinctive Silhouette The Butterfly Effect Revisited
	Safieddine Bouali 2014
***************************************************************************/

int	DoA3DStrangeAttractor(void)

    {
    double	i, c1[3], cn[3], alpha, beta, gamma, mu;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alpha = param[0];
    beta = param[1];
    gamma = param[2];
    mu = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = alpha * c1[0] * (1.0 - c1[1]) - beta * c1[2];
	cn[1] = -gamma * c1[1] * (1.0 - c1[0] * c1[0]);
	cn[2] = mu * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A 4D Chaotic Hyperjerk System, Synchronization, Circuit Design and Applications in RNG, Image Encryption and Chaos-Based Steganography
	S. Vaidyanathan,A . Akgul, S. Kacar and U. Cavusoglu 7 January 2018
    https://www.researchgate.net/publication/323081910_A_new_4-D_chaotic_hyperjerk_system_its_synchronization_circuit_design_and_applications_in_RNG_image_encryption_and_chaos-based_steganography
***************************************************************************/

int	DoA4DChaoticHyperjerkSystem(void)

    {
    double	i, c1[4], cn[4], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = c1[3];
	cn[3] = -c * c1[0] - b * c1[1] - exp(c1[1]) - exp(c1[2]) - a * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A 4 Dimensional Hyperchaotic Finance System and Its Control Problems
	Dimitrios Prousalis, Christos Volos, Ioannis Stouboulos and Ioannis Kyprianidis 2016
***************************************************************************/

int	DoA4DHyperchaoticFinanceSystem(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, k;

    c1[0] = cn[0] = param[10];	// x
    c1[1] = cn[1] = param[11];	// y
    c1[2] = cn[2] = param[12];	// z
    c1[3] = cn[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    k = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2] + (c1[1] - a) * c1[0] + c1[3];
	cn[1] = 1.0 - b * c1[1] - c1[0] * c1[0];
	cn[2] = -c1[0] - c * c1[2];
	cn[3] = -d * c1[0] * c1[1] - k * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A 4D Hyperchaotic Memristive Dynamical System-II
	Dimitrios Prousalis, Christos Volos, Ioannis Stouboulos and Ioannis Kyprianidis 2016
***************************************************************************/

int	DoA4DHyperchaoticMemristiveDynamicalSystem(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] + b * c1[1] + c1[1] * c1[2];
	cn[1] = -c1[0] * c1[2] + c1[1] * c1[2] - c * f;
	cn[2] = -c1[2] - d * c1[0] * c1[1] + e;
	cn[3] = c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A 5 Dimensional Hyperchaotic and Chaotic Systems with Non-hyperbolic Equilibria and Many Equilibria -NHE1
	Jay Prakash Singh and Binoy Krishna Roy 2018
***************************************************************************/

int	DoA5DHyperchaoticSystem(void)

    {
    double	i, c1[5], cn[5], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[2] - c1[0]);
	cn[1] = b - c1[0] * c1[2] + c1[3];
	cn[2] = c1[0] * c1[1] + c1[4];
	cn[3] = c * c1[2];
	cn[4] = -c * c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A 5-D Hyperchaotic Rikitake Dynamo System with Hidden Attractors
	volos@physics.auth.gr 2015
***************************************************************************/

int	DoA5DHyperchaoticRikitakeDynamoSystem(void)

    {
    double	i, c1[5], cn[5], a, b, c, p, q;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v

    a = param[0];
    b = param[1];
    c = param[2];
    p = param[3];
    q = param[4];
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[0] + c1[1] * c1[2] - p * c1[3] + q * c1[4];
	cn[1] = -a * c1[1] + c1[0] * (c1[2] - b) - p * c1[3] + q * c1[4];
	cn[2] = 1 - c1[0] * c1[1];
	cn[3] = c * c1[1];
	cn[4] = q * (c1[0] + c1[1] - c1[3] - c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A 9D-Model in Scholarpaedia
	Christophe Letellier, Dr. Otto E. Rossler 1980
	http://www.scholarpedia.org/article/Hyperchaos
***************************************************************************/

int	DoA9DModelScholarpaedia(void)

    {
    double	i, c1[9], cn[9], a, r, s, b1, b2, b3, b4, b5, b6;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w
    c1[6] = param[16];	// r
    c1[7] = param[17];	// s
    c1[8] = param[18];	// t

    a = param[0];
    r = param[1];
    s = param[2];
    b1 = 4 * (1 + a * a) / (1 + 2 * a * a);
    b2 = (1 + 2 * a * a) / 2 / (1 + a * a);
    b3 = 2 * (1 - a * a) / (1 + a * a);
    b4 = a * a / (1 + a * a);
    b5 = 8 * a * a / (1 + 2 * a * a);
    b6 = 4 / (1 + 2 * a * a);

    totpasses = 10;

    InitOscillator(c1, 9);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -s * b1 * c1[0] - c1[1] * c1[3] + b4 * c1[3] * c1[3] + b3 * c1[2] * c1[4] - s * b2 * c1[6];
	cn[1] = -s * c1[1] + c1[0] * c1[3] - c1[1] * c1[4] + c1[3] * c1[4] - s * c1[8] / 2;
	cn[2] = -s * b1 * c1[2] + c1[1] * c1[3] - b4 * c1[1] * c1[1] - b3 * c1[0] * c1[4] + s * b2 * c1[7];
	cn[3] = -s * c1[3] - c1[1] * c1[2] - c1[1] * c1[4] + c1[3] * c1[4] + s * c1[8] / 2;
	cn[4] = -s * b5 * c1[4] + c1[1] * c1[1] / 2 - c1[3] * c1[3] / 2;
	cn[5] = -b6 * c1[5] + c1[1] * c1[8] - c1[3] * c1[8];
	cn[6] = -b1 * c1[6] - r * c1[0] + 2 * c1[4] * c1[7] - c1[3] * c1[8];
	cn[7] = -b1 * c1[7] + r * c1[2] - 2 * c1[4] * c1[6] + c1[1] * c1[8];
	cn[8] = -c1[8] - r * c1[1] + r * c1[3] - 2 * c1[1] * c1[5] + 2 * c1[3] * c1[5] + c1[3] * c1[6] - c1[1] * c1[7];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 9, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Chaotic System with Infinite Equilibria and Its S-Box Constructing Application
	Xiong Wang, Akif Akgul, Unal Cavusoglu, Viet-Thanh Pham and Duy Vo Hoang and Xuan Quynh Nguyen 2 November 2018
	https://www.mdpi.com/2076-3417/8/11/2132 
***************************************************************************/

int	DoAChaoticSystemInfiniteEquilibriaSBox(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -a * c1[0] - b * c1[1] + c1[1] * c1[2];
	cn[2] = -c * c1[0] * c1[1] - c1[0] * c1[0] + c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Chaotic System with an Infinite Number of Equilibrium Points Located on a Line and on a Hyperbola and its Fractional-Order Form
	Sifeu Takougang Kingni, Viet-Thanh Pham, Sajad Jafari and Paul Woafo 6 April 2017
	https://www.sciencedirect.com/science/article/abs/pii/S0960077917301467v......https://doi.org/10.1016/j.chaos.2017.04.011
***************************************************************************/

int	DoAChaoticSystemInfiniteNumberEquilibriumPoints(void)

    {
    double	i, c1[3], cn[3], a, b/*, c, d, e, f*/;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
/*
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
*/
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[2];
	cn[1] = -c1[0] * c1[2] * c1[2] + a * fabs(c1[2]) / c1[2];
	cn[2] = c1[0] - c1[0] * c1[0] * c1[1] + c1[2] * (b * c1[1] * c1[1] - c1[2] * c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Chaotic System with Infinite Equilibria Located on a Piecewise Linear Curve
	Viet-Thanh Pham, Sajad Jafari, Christos Volos, Sundarapandian Vaidyanathan and Tomasz Kapitaniak Aug 30, 2016
***************************************************************************/

int	DoAChaoticSystemInfiniteEquilibria(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = cn[0] = param[10];	// x
    c1[1] = cn[1] = param[11];	// y
    c1[2] = cn[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[2];
	cn[1] = c1[0] * c1[2] * c1[2];
	cn[2] = c1[0] - a * fabs(c1[1]) + c1[2] * (b * c1[1] * c1[1] - c * fabs(c1[2]));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Conditional Symmetric Memristive System With Infinitely Many Chaotic Attractors
	JIACHENG GU, CHUNBIAO LI, YUDI CHEN, HERBERT H. C. IU and TENGFEI LEI January 21, 2020
	Sent to us by Chunbiao Li through https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8957042
***************************************************************************/

int	DoAConditionalSymmetricMemristiveSystem(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] * c1[1] - a * c1[2] * c1[2];
	cn[1] = -c1[2] * c1[2] - b * c1[1] * tanh(c1[3]) + c;
	cn[2] = c1[1] * c1[2] + d * cos(c1[0]);
	cn[3] = c1[1] * c1[1] - c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Conservative Memristive Chaotic System with Extreme Multistability and Its Application in Image Encryption
	Jian Li, Bo Liang, Xiefu Zhang and Zhixin Yu 13 December 2023
	https://www.mdpi.com/1099-4300/25/12/1656....https://doi.org/10.3390/e25121656
	Corresponding author: zhangxiefu@gznc.edu.cn
***************************************************************************/

int	DoAConservativeMemristiveChaoticSystem(void)

    {
    double	i, c1[4], cn[4], a, b, c, wx;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	wx = 1.0 + 0.25 * sqr(c1[0]) - 0.002 * pow(c1[0], 4);

	cn[0] = c1[1];
	cn[1] = b * (c1[0] * c1[0] + 1) * c1[3] - a * c1[0];
	cn[2] = c1[3];
	cn[3] = -b * wx * c1[1] - c * c1[2];
//	if (i > start)
	    if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
		break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Conservative System based on a Triangular Wave Memristor and its Application in Image Encryption
	Chuanhong Du, Licai Liu, Zhengping Zhang and Shixing Yu 2023
	https://assets.researchsquare.com/files/rs-2717329/v1_covered.pdf?c=1680664722.....https://doi.org/10.21203/rs.3.rs-2717329/v1
	corresponding author: zpzhang@gzu.edu.cn
***************************************************************************/

int	DoAConservativeSystemTriangularWaveMemristor(void)

    {
    double	i, c1[4], cn[4], n, a, b, en, q, fx, qn, start;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    n = param[0];
    a = param[1];
    b = param[2];
    en = param[3];
    q = param[4];
    start = param[5];
    totpasses = 10;

    qn = q * (2 * n - fabs(n) / n);
    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	if (c1[0] < -en + qn)
	    fx = -c1[0] - q;
	else if (c1[2] > en + qn)
	    fx = -c1[0] + q;
	else
	    fx = -c1[0] + q / en * (c1[0] - qn);

	cn[0] = c1[3] - c1[2];
	cn[1] = a * c1[3];
	cn[2] = c1[0];
	cn[3] = b * c1[0] * c1[2] - c1[0] - c1[1] + c1[0] * fx;
	if (i > start)
	    if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
		break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Family of Circulant Megastable Chaotic Oscillators for the Detection of a Feeble Signal using Chaotic SCA Algorithm
	Karthikeyan Rajagopal , Murat Erhan Cimen , Sajad Jafari , JayPrakash Singh , Binoy Krishna Roy, Omer Faruk and, Akif Akgul 20 April 2021
	https://www.sciencedirect.com/science/article/abs/pii/S0960077921003465#!
***************************************************************************/

int	DoAFamilyCirculantMegastableChaoticOscillators(void)

    {
    double	i, c1[4], cn[4], a, b, w, w0;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    b = param[0];
    w = param[1];
    w0 = param[2];
    a = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = w0 * cos(c1[1]) - b * tanh(c1[0]) - a * sin(w * w0 * i);
	cn[1] = w0 * cos(c1[2]) - b * tanh(c1[1]) - a * sin(w * w0 * i);
	cn[2] = w0 * cos(c1[3]) - b * tanh(c1[2]) - a * sin(w * w0 * i);
	cn[3] = w0 * cos(c1[0]) - b * tanh(c1[3]) - a * sin(w * w0 * i);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Fish Biology Chaotic System and its Circuit Design
	A Rhif, S Vaidyanathan, A Sambas, Mujiarto and Subiyanto 2019
	Received from  Sundarapandian Vaidyanathan through Research Gate
***************************************************************************/

int	DoAFishBiologyChaoticSystemCircuitDesign(void)

    {
    double	i, c1[3], cn[3], r1, r2, c12, c21, a13, a23, d1, d2, t1, t2, k = 1000.0, m = 0.1;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    r1 = param[0];
    r2 = param[1];
    c12 = param[2];
    c21 = param[3];
    a13 = param[4];
    a23 = param[5];
    d1 = param[6];
    d2 = param[7];
    t1 = param[8];
    t2 = param[9];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = r1 * c1[0] * (1 - c1[0] / k) - c12 * c1[0] * c1[1] - a13 * c1[0] * c1[2];
	cn[1] = r2 * c1[1] * (1 - c1[1] / k) - c21 * c1[0] * c1[1] - a23 * c1[1] * c1[2];
	cn[2] = (d1 * c1[0] + d2 * c1[1]) * c1[2] - m * c1[2] - t1 * c1[0] * c1[2] - t2 * c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Flexible Chaotic System with Adjustable Amplitude, Largest Lyapunov Exponent, and Local Kaplan–Yorke Dimension and Its Usage in Engineering Applications
	Heng Chen, Atiyeh Bayani, Akif Akgul, Mohammad-Ali Jafari, Viet-Thanh Pham, Xiong Wang and Sajad Jafari 18 February 2018
	https://www.researchgate.net/publication/323258542_A_flexible_chaotic_system_with_adjustable_amplitude_largest_Lyapunov_exponent_and_local_Kaplan-Yorke_
	dimension_and_its_usage_in_engineering_applications
***************************************************************************/

int	DoAFlexibleChaoticSystemAdjustableAmplitude(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[0] + c1[1] * c1[2];
	cn[2] = a - fabs(c1[1]) - b * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Giga-Stable Oscillator with Hidden and Self-Excited Attractors: A Megastable Oscillator Forced by His Twin
	Thoai Phu Vo, Yeganeh Shaverdi, Abdul Jalil M. Khalaf, Fawaz E. Alsaadi, Tasawar Hayat and Viet-Thanh Pham May 2019
	https://www.researchgate.net/publication/333378037_A_Giga-Stable_Oscillator_with_Hidden_and_Self-Excited_Attractors_A_Megastable_Oscillator_Forced_by_His_Twin
***************************************************************************/

int	DoAGigaStableOscillatorHiddenSelfExcitedAttractors(void)

    {
    double	i, c1[4], cn[4], a, k, w;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    k = param[1];
    w = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -k * k * c1[0] + c1[1] * cos(c1[0]) + a * c1[2];
	cn[2] = w * c1[3];
	cn[3] = w * (-k * k * c1[2] + c1[3] * cos(c1[2]));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Memristive Chaotic Oscillator with Controllable Amplitude and Frequency
	Xin Zhanga, Chunbiao Li, Yudi Chena, Herbert H.C. IU and Tengfei Lei  2020
	Sent directly by Chunbiao Li through https://www.researchgate.net/requests/r77138144
***************************************************************************/

int	DoAMemristiveChaoticOscillatorControllableAmplitudeFrequency(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[1] * c1[2];
	cn[1] = b * c1[0] * c1[0] - c1[0] * c1[2] - c1[2] * c1[2];
	cn[2] = c1[0] * (d * fabs(c1[3]) - c) + c1[1] * c1[2];
	cn[3] = c1[0] * c1[0] - c1[3] * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Memristive Chaotic System with Hypermultistability and its Application in Image Encryption
	JIAYU SUN, CHUNBIAO LI, TIANAI LU, AKIF AKGUL AND FUHONG MIN 2020
	DOI: 10.1109/ACCESS.2020.3012455
***************************************************************************/

int	DoAMemristiveChaoticystemHypermultistability(void)

    {
    double	i, c1[4], cn[4], a, b, c, w4;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	w4 = b * fabs(c1[3]) - c;
	cn[0] = c1[1] * (1 + tan(c1[2]));
	cn[1] = -tan(c1[2]);
	cn[2] = c1[0] * w4 - a * tan(c1[2]);
	cn[3] = c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Memristor-Meminductor-Based Chaotic System with Abundant Dynamical Behaviours
	Birong Xu, Guangyi Wang, Herbert HoChing Iu, Simin Yu & Fang Yuan 2 February 2019
	https://www.researchgate.net/requests/r61471960 sent to me by one of the authors Birong Xu
***************************************************************************/

int	DoAMemristorMeminductorBasedChaoticSystem(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e, alpha, beta;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    alpha = param[5];
    beta = param[6];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -(a * c1[1] * c1[1] - b) * c1[0] - (alpha * c1[3] + beta) * c1[2];
	cn[1] = -c * c1[0] - d * c1[1] + e * c1[0] * c1[0] * c1[1];
	cn[2] = c1[0];
	cn[3] = c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Minimal 3-Term Chaotic Flow with Coexisting Routes to Chaos, Multiple Solutions, and its Analog Circuit Realisation
	Alexis Nguomkam Negou and Jacques Kengne 4 March 2019
	Sent by one of the authors: Alexis Nguomkam Negou
***************************************************************************/

int	DoAMinimal3TermChaoticFlowCoexistingRoutesChaos(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, k, fy;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    k = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	fy = 0.5 * (exp(k * (c1[1] + c * c1[2])) - exp(-(c1[1] + c * c1[2])));
	cn[0] = c1[1];
	cn[1] = a * c1[2];
	cn[2] = -b * c1[0] - d * fy;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Multi-Wing Spherical Chaotic System using Fractal Process
	Yanling Guo, Guoyuan Qi and Yskander Hamam 10 May 2021
	https://www.researchgate.net/publication/303556740
***************************************************************************/

int	DoAMultiWingSphericalChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e, xyx, xyn;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	xyx = c1[0] * c1[0] + c1[1] * c1[1];
	xyn = c1[0] * c1[0] - c1[1] * c1[1];
	cn[0] = c1[0] / 2 / xyx * (a * (2 * c1[0] * c1[1] - c1[0] * c1[0] + c1[1] * c1[1]) + 2 * e * c1[0] * c1[1] * c1[2]) + c1[1] / 2 / xyx * ((c - c1[2]) * xyn + 2 * d * c1[0] * c1[1]);
	cn[1] = c1[0] / 2 / xyx * ((c - c1[2]) * xyn + 2 * d * c1[0] * c1[1]) - c1[1] / 2 / xyx * (a * (2 * c1[0] * c1[1] - c1[0] * c1[0] + c1[1] * c1[1]) + 2 * e * c1[0] * c1[1] * c1[2]);
	cn[2] = -b * c1[2] + 2 * c1[0] * c1[1] * xyn;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New 3D Chaotic System with 4 Quadratic Nonlinear Terms, its Global Chaos Control via Passive Control Method and Circuit Design
	C H Lien, S Vaidyanathan, A Sambas, Sampath S, Sukono and M Mamat 2018
	https://iopscience.iop.org/article/10.1088/1757-899X/621/1/012013/pdf and sent to me by S Vaidyanathan through Researchgate
***************************************************************************/

int	DoANew3DChaoticSystem4QuadraticNonlinearTerms(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * (c1[1] + c1[0]) + c1[1] * c1[2];
	cn[1] = b * c1[1] - c1[0] * c1[2] - d * c1[0] * c1[0];
	cn[2] = -c * c1[2] + c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New 3-D Chaotic System with Conch-Shaped Equilibrium Curve and its Circuit Implementation
	Mustafa Mamat, Sundarapandian Vaidyanathan, Aceng Sambas, Mohamad Afendee Mohamed, Sivaperumal Sampath and W. S. Mada Sanjaya 2018
	https://www.sciencepubco.com/index.php/ijet/article/view/12544/6365
***************************************************************************/

int	DoANew3DChaoticSystemConchShapedEquilibriumCurve(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2];
	cn[1] = -c1[2] * (a * c1[1] + b * c1[0] * c1[2]);
	cn[2] = -c1[0] * c1[0] + 8 * fabs(c1[1]) - 8 * c1[0] * c1[0] * c1[0] + c1[0] * c1[0] * c1[0] * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New 3D Chaotic Flow with One Stable Equilibrium: Dynamical Properties and Complexity Analysis
	Abdul Jalil M. Khalaf, Tomasz Kapitaniak, Karthikeyan Rajagopal, Ahmed Alsaedi, Tasawar Hayat and Viet-Thanh Pham March 5, 2018
	https://www.degruyter.com/downloadpdf/j/phys.2018.16.issue-1/phys-2018-0037/phys-2018-0037.pdf
***************************************************************************/

int	DoANew3DChaoticFlowOneStableEquilibrium(void)

    {
    double	i, c1[3], cn[3], b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    b = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2];
	cn[1] = -c1[0] - c1[2];
	cn[2] = -1.2 * c1[0] + 4 * c1[1] - c1[2] + c1[2] * c1[2] + 2 * c1[0] * c1[1] + b * c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 60.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New 3D Chaotic System with a Hidden Attractor, Circuit Design and Application in Wireless Mobile Robot
	Sundarapandian Vaidyanathan, Aceng Sambas, Mustafa Mamat and Mada Sanjaya WS 21/Dec/17
	https://www.researchgate.net/publication/321958295_A_new_three-dimensional_chaotic_system_with_a_hidden_attractor_circuit_design_and_application_in_wireless_mobile_robot
***************************************************************************/

int	DoANew3DChaoticSystemHiddenAttractor(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[0] - c1[1] - a * c1[1] * c1[2];
	cn[2] = b * c1[1] * c1[1] - c * c1[0] - d;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 35.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New 3D Chaotic System with a Hidden Attractor, Circuit Design and Application - Extended to 6D
	Sundarapandian Vaidyanathan, Aceng Sambas, Mustafa Mamat and Mada Sanjaya WS 21/Dec/17 and Marcus!!!!
	https://www.researchgate.net/publication/321958295_A_new_three-dimensional_chaotic_system_with_a_hidden_attractor_circuit_design_and_application_in_wireless_mobile_robot
***************************************************************************/

int	DoANew3DChaoticSystemHiddenAttractor6D(void)

    {
    double	i, c1[6], cn[6], a, b, c, d, l, v0, w0;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    l = param[4];
    totpasses = 10;

    InitOscillator(c1, 6);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[0] - c1[1] - a * c1[1] * c1[2];
	cn[2] = b * c1[1] * c1[1] - c * c1[0] - d;
	v0 = 0.5 * (c1[0] + c1[1]);
	w0 = (c1[0] - c1[1]) / l;
	cn[3] = v0 * cos(c1[5]);
	cn[4] = v0 * sin(c1[5]);
	cn[5] = w0;

	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 35.0) % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New 3D Chaotic System Without Equilibrium Points, Its Dynamical Analyses and Electronic Circuit Application
	Akif Akgul, Ihsan Pehlivan 2016
	https://pdfs.semanticscholar.org/fc8e/6a86af5231223c55010be640126c820978ee.pdf
***************************************************************************/

int	DoANew3DChaoticSystemWithoutEquilibriumPoints(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 2.8 * c1[1] - c1[0] + c1[2] * c1[1];
	cn[1] = -0.2 * c1[0] * c1[2] - 1.4 * c1[0] + c1[1] * c1[2] + 1;
	cn[2] = 10 - 2 * c1[0] * c1[1] - c1[0] * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 35.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New 3D Memristive Time-Delay Chaotic System with Multi-scroll and Hidden Attractors
	Nalini Prasad Mohanti, Rajeeb Dey and Binoy Krishna Roy 2018
	Received directly by Binoy Krishna Roy and https://www.researchgate.net/requests/r61467767
***************************************************************************/

int	DoANew3DCMemristiveTimeDelayChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[0] + a * c1[1] * c1[2] + b * c1[1] * sin(c1[2]);
	cn[2] = 1.0 - c1[1] * c1[1] - c1[1] * (c + 3.0 * d * c1[0] * c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 35.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New 4D Chaotic Attractor Based on Two-Degrees of Freedom Nonlinear Mechanical System
	Sezgin Kaçar November 2016
	https://www.researchgate.net/publication/312210162_A_New_Four_Dimensional_Chaotic_Attractor_Based_on_Two-Degrees_of_Freedom_Nonlinear_Mechanical_System
***************************************************************************/

int	DoANew4DChaoticAttractor(void)

    {
    double	i, c1[4], cn[4], a, b, c, s, d, l;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    s = param[3];
    d = param[4];
    l = param[5];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2];
	cn[1] = c1[3];
	cn[2] = -a * c1[2] - b * c1[0] - c * (c1[0] - c1[1]) * (c1[0] - c1[1]);
	cn[3] = s - d * c1[3] - l * (c1[1] - c1[0]) * (c1[1] - c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 35.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New 4D Chaotic System with Hidden Attractor and its Engineering Applications: Analogue Circuit Design and Field Programmable Gate Array Implementation
	Hamid Reza Abdolmohammadi, Abdul Jalil M Khalaf, Shirin Panahi, Karthikeyan Rajagopal, Viet-Thanh Pham and Sajad Jafari 30 April 2018
	https://www.researchgate.net/publication/321918537
***************************************************************************/

int	DoANew4DChaoticSystemHiddenAttractor(void)

    {
    double	i, c1[4], cn[4], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[1];
	cn[1] = c1[2];
	cn[2] = c1[3];
	cn[3] = -0.06 * c1[0] * c1[0] - 0.38 * c1[0] * c1[1] - 0.56 * c1[0] * c1[2] - 0.12 * c1[0] * c1[3] + b * c1[1] * c1[3] - 0.71;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 35.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New 4-D Chaotic System with Hidden Attractor and its Circuit Implementation - affected by Marcus
	Aceng Sambas, Mustafa Mamat, Sundarapandian Vaidyanathan, Mohamad Afendee Mohamed and W. S. Mada Sanjaya 02 July 2018.
	Received from W. S. Mada Sanjaya  
	& https://www.researchgate.net/publication/326433888_A_new_four-dimensional_chaotic_system_with_hidden_attractor_and_its_circuit_design
***************************************************************************/

int	DoANew4DChaoticSystemHiddenAttractorCircuitImplementation(void)

    {
    double	i, c1[4], cn[4], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) - c1[3] / 2 + c1[2] * c1[1];	// this final part (+ z * y) was created by Marcus
	cn[1] = c1[0] * c1[2] + c1[1] * c1[0];				// this final part (+ y * x)was also created by Marcus;
	cn[2] = b / 4 - c1[0] * c1[1];
	cn[3] = 2 * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 35.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New 4-D Hyperchaotic System with Four-Scroll Hidden Attractor, Its Properties and Bifurcation Analysis
	L G Dolvis, S Vaidyanathan, K Jacques3 A Sambas, Sukono and M Mamat 2019
	https://iopscience.iop.org/article/10.1088/1757-899X/621/1/012014 and sent by S Vaidyanathanto Marcus
***************************************************************************/

int	DoANew4DHyperchaoticSystem(void)

    {
    double	i, c1[4], cn[4], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[0] - c1[1]) - c1[1] * c1[2] + c1[3];
	cn[1] = c1[0] * c1[2] - b * c1[1] + c1[3];
	cn[2] = c1[0] * c1[1] - c * c1[2];
	cn[3] = -c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 35.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New 5D Hyperchaotic System with Stable Equilibrium Point, Transient Chaotic Behaviour and its Fractional-Order Form
	No idea about source. Marcus stuffed up the name
***************************************************************************/

int	DoANew5DHyperchaoticSystem(void)

    {
    double	i, c1[5], cn[5], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + b * c1[1] * c1[2] + c1[3] + c1[4];
	cn[1] = -c1[0] * c1[2] + c * c1[1] + c1[3];
	cn[2] = -4 + c1[0] * c1[1] - d * c1[2];
	cn[3] = -e * c1[1];
	cn[4] = -e * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 35.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A new Chaotic Oscillator with Free Control
	Chunbiao Li, Julien Clinton Sprott, Akif Akgul, Herbert H. C. Iu and Yibo Zhao1 2 August 2017
	https://pdfs.semanticscholar.org/15ce/8d448ae2ac39743e6beaceadc4abbcbfcc89.pdf
***************************************************************************/

int	DoANewChaoticOscillatorWithFreeControl(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] * c1[2];	
	cn[1] = c1[1] * c1[1] - a * c1[2] * c1[2] + c1[1] * c1[2];
	cn[2] = b * c1[1] * c1[1] + c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 35.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Chaotic Image Encryption Scheme Using Breadth-First Search and Dynamic Diffusion
	Qi Yin and Chunhua Wang January 26, 2018
	https://www.researchgate.net/profile/Chunhua_Wang7/publication/324946680_A_New_Chaotic_Image_Encryption_Scheme_Using_Breadth-First_Search_and_Dynamic_Diffusion/links/5c8f9e7345851564fae633a9/A-New-Chaotic-Image-Encryption-Scheme-Using-Breadth-First-Search-and-Dynamic-Diffusion.pdf
***************************************************************************/

int	DoANewChaoticImageEncryptionScheme(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[1] * c1[2];
	cn[1] = b * c1[0] - c1[1] - c1[0] * c1[2] + c1[3];
	cn[2] = c1[0] * c1[1] - c * c1[2];
	cn[3] = d * c1[3] - c1[0] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 35.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Chaotic System with a Self-Excited Attractor-Entropy Measurement, Signal Encryption, and Parameter Estimation
	Guanghui Xu, Yasser Shekofteh, Akif Akgul, Chunbiao Li and Shirin Panahi 27 January 2018
	https://www.worldscientific.com/doi/pdf/10.1142/S0218126618300040
***************************************************************************/

int	DoANewChaoticSystemSelfExcitedAttractorEntropyMeasurement(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e, f, g;

    c1[0] = cn[0] = param[10];	// x
    c1[1] = cn[1] = param[11];	// y
    c1[2] = cn[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = g * c1[2];
	cn[1] = d * c1[0] * c1[0] + e * c1[1] * c1[1] - f;
	cn[2] = -a * c1[0] - b * c1[0] * c1[0] + c * c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Chaotic System with Multiple Attractors: Dynamic Analysis, Circuit Realization and S-Box Design
	Qiang Lai, Akif Akgul, Chunbiao Li, Guanghui Xu and Unal Cavusoglu 27 December 2017
	http://www.mdpi.com/1099-4300/20/1/12/htm
***************************************************************************/

int	DoANewChaoticSystemMultipleAttractors(void)

    {
    double	i, c1[3], cn[3], a, b, c, k;

    c1[0] = cn[0] = param[10];	// x
    c1[1] = cn[1] = param[11];	// y
    c1[2] = cn[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    k = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] - c1[1] * c1[2];
	cn[1] = -b * c1[1] + c1[0] * c1[2];
	cn[2] = -c * c1[2] + c1[0] * c1[1] * c1[2] + k;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Chaotic System with Multiple Attractors - Dynamic Analysis, Circuit Realization and S-Box Design-B
	Qiang Lai, Akif Akgul, Chunbiao Li, Guanghui Xu and Unal Cavusoglu  27 December 2017
	http://www.mdpi.com/1099-4300/20/1/12/pdf
***************************************************************************/

int	DoANewChaoticSystemMultipleAttractorsB(void)

    {
    double	i, c1[3], cn[3], n, s22;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    n = param[0];
    s22 = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] + c1[2];
	cn[1] = -c1[0] - c1[1] + s22 * c1[1];
	cn[2] = -c1[2] - 4 * tanh(i / c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Chaotic System with Line of Equilibria: Dynamics, Passive Control and Circuit Design
	Aceng Sambas, Mustafa Mamat, Ayman Ali Arafa, Gamal M Mahmoud, Mohamad Afendee Mohamed and W. S. Mada Sanjaya Mar 11, 2019
	Sent by the first author:  Aceng Sambas
***************************************************************************/

int	DoANewChaoticSystemMultipleLineEquilibria(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] * c1[2];
	cn[1] = c1[0] * fabs(c1[0]) - c1[1] * fabs(c1[1]);
	cn[2] = a * fabs(c1[0]) - b * c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Colour image Encryption based on Multi Chaotic Maps
	Ibtisam A.Taqi and Sarab M. Hameed November 2018
	https://www.researchgate.net/publication/329280553
***************************************************************************/

int	DoANewColourimageEncryption(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    k = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = -c1[0] * c1[2] + d * c1[0] + c * c1[1] + c1[3];
	cn[2] = c1[0] * c1[1] - b * c1[2];
	cn[3] = c1[0] + k;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Cost Function for Parameter Estimation of Chaotic Systems Using Return Maps as Fingerprints - Jafari oscillator
	Sajad Jafari, Julien Clinton Sprott, Viet-Thanh Pham, Seyed Mohammad Reza Hashemi Golpayegani and Amir Homayoun Jafari May 30, 2014
	https://www.researchgate.net/publication/263889454_A_New_Cost_Function_for_Parameter_Estimation_of_Chaotic_Systems_Using_Return_Maps_as_Fingerprints
***************************************************************************/

int	DoANewCostFunctionParameterEstimationChaoticSystems(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[0] - c1[1] * c1[2];
	cn[2] = c1[0] * c1[1] + c1[0] * c1[0] / 2 - 1.3;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Family of Chaotic Systems with Different Closed Curve Equilibrium
	Xinhe Zhu and Wei-Shih Du 17 January 2019
	https://www.mdpi.com/2227-7390/7/1/94/pdf
***************************************************************************/

int	DoANewFamilyChaoticSystemsDifferentClosedCurveEquilibrium(void)

    {
    double	i, c1[3], cn[3], a, b, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    k = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2];
	cn[1] = -c1[2] * (a * c1[1] + b * c1[1] * c1[1] + c1[0] * c1[2]);
	cn[2] = pow(fabs(c1[0]), k) + pow(fabs(c1[1]), k) - 1;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Finance Chaotic System, its Electronic Circuit Realization, Passivity based Synchronization and an Application to Voice Encryption
	Sundarapandian Vaidyanathan, Aceng Sambas, Sezgin Kacar and Unal Cavusoglu 2018-06-29
	https://www.researchgate.net/publication/326094812_A_New_Finance_Chaotic_System_its_Electronic_Circuit_Realization_Passivity_based_Synchronization_and_an_Application_to_Voice_Encryption
***************************************************************************/

int	DoANewFinanceChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2] + (c1[1] - a) * c1[0];
	cn[1] = 1 - b * c1[1] - d * c1[0] * c1[0] - c1[0] * c1[0] * c1[0] * c1[0];
	cn[2] = -c1[0] - c * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Four-Scroll Chaotic System with a Self-Excited Attractor and Circuit Implementation
	Sivaperumal Sampath, Sundarapandian Vaidyanathan, Aceng Sambas, Mohamad A Mohamed, Mustafa Mamat and W. S. Mada Sanjaya 27 September 2018
	Sent by one of the authors: Aceng Sambas
***************************************************************************/

int	DoANewFourScrollChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + b * c1[1] * c1[2];
	cn[1] = -c1[1] - 10 * c1[1] * fabs(c1[1]) + 4 * c1[0] * c1[2];
	cn[2] = c * c1[2] - c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Fractional Order Chaotic System with Different Families of Hidden and Self-Excited Attractors
	Jesus M. Munoz-Pacheco1, Ernesto Zambrano-Serrano, Christos Volos, Sajad Jafari, Jacques Kengne and Karthikeyan Rajagopal 28 July 2018
	https://www.researchgate.net/publication/326699572_A_New_Fractional-Order_Chaotic_System_with_Different_Families_of_Hidden_and_Self-Excited_Attractors
***************************************************************************/

int	DoANewFractionalOrderChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] * c1[2] + c1[0] * (c1[1] - a);
	cn[1] = 1 - fabs(c1[0]);
	cn[2] = -c1[0] * c1[1] - c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Hamiltonian Chaotic System with Coexisting Chaotic Orbits and its Dynamical Analysis
	Sundarapandian Vaidyanathan, Aceng Sambas, Sen Zhang, Mohamad Afendee Mohamed and Mustafa Mamat 27 September 2018
	https://www.researchgate.net/publication/327828563
***************************************************************************/

int	DoANewHamiltonianChaoticSystem(void)

    {
    double	i, c1[4], cn[4], a, b, begin;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    begin = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[0] - 2 * c1[0] * c1[2] + a * c1[0] * c1[0];
	cn[2] = c1[3];
	cn[3] = -c1[2] - c1[0] * c1[0] + c1[2] * c1[2] + b * c1[2] * c1[2] * c1[2] * c1[2];
	if (i > begin)
	    if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 4, 0) < 0)
		break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Hyperchaotic Map and its Application for Image Encryption
	Hayder Natiq, N.M.G. Al-Saidi, M.R.M. Said and Adem Kilicman 9 January 2018
	Received through Hayder Natiq Kadhim
***************************************************************************/

int	DoANewHyperchaoticMapOsc(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = 0.0;	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 1 / PI / b * sin(1 + a * c1[0] * c1[0]) - PI * PI * c1[1];
	cn[1] = 2 / PI / b * sin(PI * b * c1[0]);
	cn[2] = 5 * sin(c1[0]) + 5 * sin(c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Hyperchaotic System-Based Design for Efficient Bijective Substitution-Boxes
	Eesa Al Solami, Musheer Ahmad, Christos Volos, Mohammad Najam Doja and Mirza Mohd Sufyan Beg 12 July 2018
	Sent by the third author : www.mdpi.com/1099-4300/20/7/525/pdf
***************************************************************************/

int	DoANewHyperchaoticSystemBasedDesign(void)

    {
    double	i, c[5], cn[5], c1, c2, c3, c4, c5, c6, c7;

    c[0] = param[10];	// x
    c[1] = param[11];	// y
    c[2] = param[12];	// z
    c[3] = param[13];	// u
    c[4] = param[14];	// v

    c1 = param[0];
    c2 = param[1];
    c3 = param[2];
    c4 = param[3];
    c5 = param[4];
    c6 = param[5];
    c7 = param[6];
    totpasses = 10;

    InitOscillator(c, 5);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1 * (c[1] - c[0]);
	cn[1] = c2 * (c[0] + c[1]) + c[4] - c[0] * c[2] * c[3];
	cn[2] = -c3 * (c[1] + c[2]) - c5 * c[3] + c[0] * c[1] * c[3];
	cn[3] = -c6 * c[3] + c[0] * c[1] * c[2];
	cn[4] = -c7 * (c[0] + c[1]);
	if (DisplayOscillator(c, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Hyperchaotic Two-Scroll System: Bifurcation Study, Multistability, Circuit Simulation, and FPGA Realization
	Sundarapandian Vaidyanathan, Aceng Sambas, Esteban Tlelo-Cuautle, Ciro Fabian Bermudez-Marquez, Khaled Benkouider and Samy Abdelwahab Safaan 22 Sept 2022
	https://www.hindawi.com/journals/ddns/2022/6604684/   
	https://doi.org/10.1155/2022/6604684
***************************************************************************/

int	DoANewHyperchaotic2ScrollSystemBifurcationStudy(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) - c1[2] + c1[3];
	cn[1] = c * c1[0] - c1[1] - c1[0] * c1[2] + c1[3];
	cn[2] = -b * c1[2] + c1[0] * c1[1];
	cn[3] = -d * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Image Encryption Scheme based on Fractional Order Hyperchaotic System and Multiple Image Fusion
	Xinyu Gao, Jiawu Yu, Santo Banerjee, Huizhen Yan & Jun Mou 2021
	https://www.nature.com/articles/s41598-021-94748-7.....https://doi.org/10.1038/s41598-021-94748-7
***************************************************************************/

int	DoANewImageEncryptionScheme(void)

    {
    double	i, c1[5], cn[5], c, e, g, n, p, s, m1, m2, start;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v

    c = param[0];
    e = param[1];
    g = param[2];
    n = param[3];
    p = param[4];
    s = param[5];
    m1 = param[6];
    m2 = param[7];
    start = param[8];
    totpasses = 10;

    InitOscillator(c1, 5);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c * (c1[0] - c1[1]) + e * (1 - m1 * c1[3] * c1[3]) * c1[0];
	cn[1] = -s * (c1[0] - c1[1]) + s * g * (1 - m2 * c1[4] * c1[4]) * c1[1] - (2 * s + 1) / (s + 1) * n * c1[2];
	cn[2] = -(s + 1) * (c1[0] - c1[1]) + (s + 1) * g * (1 - m2 * c1[4] * c1[4]) * c1[1] - 2 * n * c1[2];
	cn[3] = -p * c1[0];
	cn[4] = -p * c1[1];
	if (i > start)
	    if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 50.0) % threshold), i, 5, 0) < 0)
		break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Memristor-Based 5D Chaotic System and Circuit Implementation
	Rui Wang, Mingjin Li, Zhaoling Gao and Hui Sun 2 December 2018
	https://www.hindawi.com/journals/complexity/2018/6069401/
***************************************************************************/

int	DoANewMemristorBased5DChaoticSystem(void)

    {
    double	i, c1[5], cn[5], k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v

    k = param[0];
    totpasses = 10;

    InitOscillator(c1, 5);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 14 * (c1[1] - c1[0]) + 4 * c1[1] * c1[2] - k * c1[0] * (0.1 + 0.01 * c1[4] * c1[4]);
	cn[1] = -c1[0] + 16 * c1[1] - c1[0] * c1[2] + c1[3];
	cn[2] = -78 * c1[2] + c1[0] * c1[1] - c1[0] * c1[4] - c1[1] * c1[3];
	cn[3] = -10 * c1[1] + 0.15 * c1[0] * c1[2] - 0.3 * c1[4];
	cn[4] = -c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Multi-Wing Chaotic Attractor with Unusual Variation in the Number of Wings
	Shilalipi Sahoo and Binoy Krishna Roy 9 September 2022
	https://www.sciencedirect.com/science/article/abs/pii/S096007792200786X
	https://doi.org/10.1016/j.chaos.2022.112598
***************************************************************************/

int	DoANewMultiWingChaoticAttractor(void)

    {
    double	i, c1[3], cn[3], a, b, c, k, k11, k22;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    k = param[3];
    k11 = param[4];
    k22 = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = b * c1[1] - c1[0] * c1[2];
	cn[2] = -c + k * (1 - k11 * sin(k22 * c1[1])) * c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New No-Equilibrium Chaotic System and Its Topological Horseshoe Chaos
	Chunmei Wang,1 Chunhua Hu,2 Jingwei Han,3 and Shijian Cang4,5 6 December 20167
	https://www.hindawi.com/journals/amp/2016/3142068/
***************************************************************************/

int	DoANewNoEquilibriumChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    k = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[1];
	cn[1] = -b * c1[0] - c * c1[1] + c1[1] * c1[2];
	cn[2] = -c1[1] * c1[1] + k;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New No Equilibrium Fractional Order Chaotic System, Dynamical Investigation, Synchronisation, and Its Digital Implementation
	Zain-Aldeen S. A. Rahman, Basil H. Jasim, Yasir I. A. Al-Yasir, Raed A. Abd-Alhameed and Bilal Naji Alhasnawi 6 July 2021
	https://www.mdpi.com/journal/inventions
***************************************************************************/

int	DoANewNoEquilibriumFractionalOrderChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[2] + c1[0] * c1[1];
	cn[1] = b - c1[0] * c1[0];
	cn[2] = -c * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Nonlinear Chaotic Complex Model and Its Complex Antilag Synchronisation
	Emad E. Mahmoud and Fatimah S. Abood 3 August 2017
	https://www.hindawi.com/journals/complexity/2017/3848953/
***************************************************************************/

int	DoANewNonlinearChaoticComplexModels(void)

    {
    double	i, c1[6], cn[6], r, s, m;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w

    r = param[0];
    s = param[1];
    m = param[2];
    totpasses = 10;

    InitOscillator(c1, 6);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = r * (c1[2] - c1[0]);
	cn[1] = r * (c1[3] - c1[1]);
	cn[2] = s * c1[2] - c1[0] * c1[4] + c1[1] * c1[5];
	cn[3] = s * c1[3] - c1[0] * c1[5] - c1[1] * c1[4];
	cn[4] = c1[0] * c1[2] + c1[1] * c1[3] - m * c1[4];
	cn[5] = -m * c1[5] + c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Oscillator with Infinite Coexisting Asymmetric Attractors
	Zhen Wang, Hamid Reza Abdolmohammadi, Fawaz E. Alsaadi, Tasawar Hayat and Viet-Thanh Pham May 2018
	https://www.researchgate.net/publication/324029632
***************************************************************************/

int	DoANewOscillatorInfiniteCoexistingAsymmetricAttractors(void)

    {
    double	i, c1[3], cn[3], a, w, real, imag;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = 1.0;	// z

    a = param[0];
    w = param[1];
    real = param[2];
    imag = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 1; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -sin(c1[0] / sqrt(15.0)) + c1[1] * cos(c1[0]) + a * sin(w * i);
	cn[2] = real * cos(c1[1]) + imag * sin(c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Transiently Chaotic Flow with Ellipsoid Equilibria
	SHIRIN PANAHI, ZAINAB ARAM, SAJAD JAFARI, VIET-THANH PHAM, CHRISTOS VOLOS and KARTHIKEYAN RAJAGOPAL 10 October 2017
	https://www.researchgate.net/publication/320625410_A_new_transiently_chaotic_flow_with_an_ellipsoid_equilibria
***************************************************************************/

int	DoANewTransientlyChaoticFlow(void)

    {
    double	i, c1[4], cn[4], b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    b = param[0];
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[3];
	cn[1] = c1[3] * (4.0 * c1[1] - c1[2] + c1[0] * c1[2] - c1[1] * c1[1] + 2.0 * c1[1] * c1[2] + c1[2] * c1[3] + 2.0 * c1[3] * c1[3] - 3.0);
	cn[2] = c1[3] * (4.0 * c1[1] + 2.0 * c1[2] - c1[3] + c1[0] * c1[2] + c1[0] * c1[3] + c1[1] * c1[3]);
	cn[3] = b * c1[0] * c1[0] + c1[1] * c1[1] / 4.0 + c1[2] * c1[2] / 4.0 - 9.0 + c1[3] * (3.0 * c1[1] * c1[1] - 0.6 * c1[2] * c1[3] - 19.0 * c1[3] * c1[3]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Two-Scroll Chaotic System with Two Nonlinearities: Dynamical Analysis and Circuit Simulation
	Sundarapandian Vaidyanathan, Aceng Sambas, Sen Zhang, Yicheng Zeng, Mohamad Afendee Mohamed and Mustafa Mamat 29 June 2019
	Sent by one of the authors: Aceng Sambas
***************************************************************************/

int	DoANewTwoScrollChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = c1[0] * c1[2];
	cn[2] = c - b * c1[1] * c1[1] * c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A No-Equilibrium Hyperchaotic System and Its Fractional-Order Form
	Duy Vo Hoang, Sifeu Takougang Kingni, and Viet-Thanh Pham, Viet-Thanh Pham, 
	Sundarapandian Vaidyanathan, Christos K. Volos, Sajad Jafari and Xiong Wang 29 June 2017
***************************************************************************/

int	DoANoEquilibriumHyperchaoticSystem(void)

    {
    double	i, c1[4], cn[4], a, n, b, m, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    n = param[1];
    b = param[2];
    m = param[3];
    c = param[4];
    d = param[5];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = -b * c1[1] + n * c1[0] * c1[2] + c * c1[3];
	cn[2] = d - exp(c1[0] * c1[1]);
	cn[3] = -m * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 160.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A No-Equilibrium Hyperchaotic System with a Cubic Nonlinear Term
	Viet-Thanh Phama, Sundarapandian Vaidyanathanb, Christos Volosc, Sajad Jafarid, Sifeu Takougang Kingni 9 December 2015
	https://www.researchgate.net/publication/286384124_A_no-equilibrium_hyperchaotic_system_with_a_cubic_nonlinear_term
***************************************************************************/

int	DoANoEquilibriumHyperchaoticSystemCubicNonlinearTerm(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, m, n;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    m = param[4];
    n = param[5];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = c * c1[0] - c1[1] - c1[0] * c1[2] + c1[3] - d;
	cn[2] = -b * c1[2] + c1[0] * c1[1];
	cn[3] = m * c1[1] + c1[3] - n * c1[0] * c1[0] * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 16.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel 3D Fractional-order Chaotic System with Multifarious Coexisting Attractors
	Zhou Chengyi, li Zhijun, Yicheng Zeng and Sen Zhang September 2018
	https://www.researchgate.net/publication/327664671_A_Novel_3D_Fractional-order_Chaotic_System_with_Multifarious_Coexisting_Attractors
***************************************************************************/

int	DoANovel3DFractionalOrderChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, h;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    h = param[4];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[0] + c * c1[1] * c1[2] - h * c1[2] * c1[2];
	cn[1] = b * c1[1] - c1[0] * c1[2];
	cn[2] = c1[0] * c1[1] - d * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 16.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel 4D Chaotic System Based on Two Degrees of Freedom Nonlinear Mechanical System
	Sezgin Kacar, Zhouchao Wei, Akif Akgul and Burak Aricioglu 06 May 2018
***************************************************************************/

int	DoANovel4DChaoticSystemBased2DegreesFreedom(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, h, r;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    h = param[4];
    r = param[5];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2];
	cn[1] = c1[3];
	cn[2] = -a * c1[2] - b * c1[0] - r * (c1[0] - c1[1]) * (c1[0] - c1[1]);
	cn[3] = c - d * c1[3] - h * (c1[1] - c1[0]) * (c1[1] - c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 16.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel 4D No-Equilibrium Hyper-Chaotic System with Grid Multi-wing Hyper-chaotic Hidden Attractors
	Sen Zhang, Yi Cheng Zeng and Zhi Jun Li April 18, 2018
	https://www.researchgate.net/publication/325050555
***************************************************************************/

int	DoANovel4DNoEquilibriumHyperChaoticSystem(void)

    {
    double	t, c1[4], cn[4], a, b, c, d, azao;
    double	p, p0, p1, p2, s, r, q, q1;
    int		n, m, i, j;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    n = (int)param[4];
    m = (int)param[5];
    azao = param[6];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	s = 0; r = 0;
	for (i = 1; i <= n; i++)
	    {
	    p1 = ((c1[2] + 2 * i) > 0.0) ? 1.0 : ((c1[2] + 2 * i) == 0.0 ? 0.0 : -1.0);
	    p2 = ((c1[2] - 2 * i) > 0.0) ? 1.0 : ((c1[2] - 2 * i) == 0.0 ? 0.0 : -1.0);
	    p0 = p1 + p2;
	    s = s + p0;
	    }
	p = c1[2] - s;
	for (j = -m; j <= m; j++)
	    {
	    q1 = (c1[1] + 2 * j * azao >= 0.0) ? 1.0 : -1.0;
	    r = r + q1;
	    }
	q = azao * r;

	cn[0] = -(c1[1] - q) * c1[2] - d * c1[3];
	cn[1] = (p * p) - 1;
	cn[2] = a * c1[0] - b * (c1[1] - q) * c1[2] - c1[2];
	cn[3] = c * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 16.0) % threshold), t, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel Autonomous 5D Hyperjerk RC Circuit with Hyperbolic Sine Function
	N. Tsafack and J. Kengne 3 September 2018
	https://www.hindawi.com/journals/tswj/2018/1260325/
***************************************************************************/

int	DoANovelAutonomous5DHyperjerkRCCircuit(void)

    {
    double	t, c1[5], cn[5], a0, a1, a2, a3, b, gamma;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v

    a0 = param[0];
    a1 = param[1];
    a2 = param[2];
    a3 = param[3];
    b = param[4];
    gamma = param[5];

    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = c1[3];
	cn[3] = b * c1[4];
	cn[4] = -a0 * c1[4] - a1 * c1[2] - a2 * c1[1] - a3 * c1[0] - gamma * sinh(c1[3]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 16.0) % threshold), t, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel Chaos Application to Observe Performance of Asynchronous Machine Under Chaotic Load
	Hakan Ozturk November 2020
	Chaos Theory and Applications (November 2020-Volume 2-Issue 2)
***************************************************************************/

int	DoANovelChaosApplication(void)

    {
    double	t, c1[4], cn[4], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	cn[0] = c1[1] + c1[1] * c1[2];
	cn[1] = c1[2];
	cn[2] = -0.49 * c1[1]  * c1[1]  * c1[1] - c1[0] * c1[2] - c1[1] * c1[2] - 50.0;
	cn[3] = c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 16.0) % threshold), t, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
    A Novel Chaotic System with Application to Secure Communications
    Lazaros Moysis, Christos Volos, Serdar Cicek, Viet-Thanh Pham and Vikas K. Mishra 2019 (September 2020)
    http://www.ids.uni-bremen.de/conf/mocast2020/papers/MOCAST_2020_paper_26.pd
***************************************************************************/

int	DoANovelChaoticSystemApplicationSecureCommunications(void)

    {
    double	t, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	cn[0] = c1[1] * c1[2];
	cn[1] = c1[0] * c1[0] * c1[0] - c1[1] * c1[1] * c1[1];
	cn[2] = a * fabs(c1[0]) - b * c1[1] * c1[1] * c1[1] - c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 16.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel Chaotic System with Two Circles of Equilibrium Points: Multistability, Electronic Circuit and FPGA Realisation
	Aceng Sambas, Sundarapandian Vaidyanathan, Esteban Tlelo-Cuautle, Sen Zhang, Omar Guillen-Fernandez, Sukono, Yuyun Hidayat and Gugun Gundara 23 October 2019
    Received from Esteban Tlelo-Cuautle through <scholaralerts-noreply@google.com>
***************************************************************************/

int	DoANovelChaoticSystem2Circles(void)

    {
    double	t, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	cn[0] = c1[2];
	cn[1] = c1[2] * (-a * c1[1] - b * c1[1] * c1[1] - c * c1[0] * c1[2]);
	cn[2] = c1[0] * c1[0] + c1[1] * c1[1] - fabs(c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 16.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel Class of Chaotic Flows with Infinite Equilibriums and Their Application in Chaos-Based Communication Design Using DCSK – CE-2 model
	Karthikeyan Rajagopal, Serdar Cicek, Abdul Jalil M. Khalaf, Viet-Thanh Pham, Sajad Jafari, Anitha Karthikeyan and Prakash Duraisamy April 10, 2018 Sent by the second author
***************************************************************************/

int	DoANovelClassChaoticFlowsInfiniteEquilibria2(void)

    {
    double	t, c1[3], cn[3], a1, a2, a3, b, c, f1, f2, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a1 = param[0];
    a2 = param[1];
    a3 = param[2];
    b = param[3];
    c = param[4];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	f1 = c1[2] * c1[2] - a2 * (c1[1] - c1[0]) - 1;
	f2 = c1[1] * c1[1] - c1[2] * c1[2] - a3 * c1[0] * c1[1];
	g = c1[0] * c1[0] - c1[1] * c1[1] - 1;
	cn[0] = a1 * c1[2];
	cn[1] = b * c1[2] * f1;
	cn[2] = g + c * c1[2] * f2;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 16.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel Class of Chaotic Flows with Infinite Equilibriums and Their Application in Chaos-Based Communication Design Using DCSK – CE-4 model
	Karthikeyan Rajagopal, Serdar Cicek, Abdul Jalil M. Khalaf, Viet-Thanh Pham, Sajad Jafari, Anitha Karthikeyan and Prakash Duraisamy April 10, 2018 Sent by the second author
***************************************************************************/

int	DoANovelClassChaoticFlowsInfiniteEquilibria4(void)

    {
    double	t, c1[3], cn[3], a1, a2, a3, a4, b, c, f1, f2, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a1 = param[0];
    a2 = param[1];
    a3 = param[2];
    a4 = param[3];
    b = param[4];
    c = param[5];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	f1 = c1[2] * c1[2] - a2 * c1[0];
	f2 = c1[2] - a3 * c1[0] * c1[1];
	g = c1[0] * c1[0] + a4 * c1[1];
	cn[0] = a1 * c1[2];
	cn[1] = b * c1[2] * f1;
	cn[2] = g + c * c1[2] * f2;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 16.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel Class of Chaotic Systems with Different Shapes of Equilibrium and Microcontroller-Based Cost-Effective Design for Digital Applications
	Karthikeyan Rajagopal, Serdar Cicek, Viet-Thanh Pham, Sajad Jafari and Anitha Karthikeyan 20 June 2018 Sent by the second author
	https://www.researchgate.net/publication/324984084_A_novel_class_of_chaotic_systems_with_different_shapes_of_equilibrium_and_microcontroller-based_cost-effective_design_for_digital_applications
***************************************************************************/

int	DoANovelClassChaoticSystemsDifferentShapesEquilibrium(void)

    {
    double	t, c1[3], cn[3], a, b, c, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	f = pow((c1[0] * c1[0] + c1[1] * c1[1] - fabs(c1[0] * c1[1])), 3) - 2 * pow((c1[0] * c1[0] - c1[1] * c1[1] - fabs(c1[1])), 2);
	cn[0] = a * c1[2];
	cn[1] = -c1[2] * (c1[0] * c1[2] + c1[1] * c1[1]);
	cn[2] = f + c1[2] * (c * c1[1] * c1[1] - a * c1[2] * c1[2] - b * c1[0] * c1[0] + c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 16.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel Control Method to Counteract the Dynamical Degradation of a Digital Chaotic Sequence
	Chen Chen, Kehui Suna, Yuexi Peng and Abdulaziz O.A. Alamodi 18 January 2019
	Published online: 18 January 2019
***************************************************************************/

int	DoANovelControlMethodCounteractDynamicalDegradation(void)

    {
    double	t, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	cn[0] = a * sin(PI * c1[1]) * sin(b / c1[0]);
	cn[1] = a * sin(PI * c1[0]) * sin(b / c1[1]);
	cn[2] = 1.0;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 16.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel Digital Programmable Multi-Scroll Chaotic System and its Application in FPGA-Based Audio Secure Communication
	De Chang, Zhijun Li, Mengjiao Wang and Yicheng Zeng 1 March 2018
	https://www.researchgate.net/publication/323536262
***************************************************************************/

int	DoANovelDigitalProgrammableMultiScrollChaoticSystem(void)

    {
    double	t, c1[3], cn[3], a, b, L, U, gx, gy, gz, fx, fy, fz;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    L = param[2];
    U = param[3];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	if (c1[0] < L)
	    gx = L + 4.0; 
	else if (c1[0] > U) 
	    gx = U + 4.0;
	else 
	    gx = 8.0 * floor(c1[0] / 8.0) + 4.0;
	if (c1[1] < L) 
	    gy = L + 4.0; 
	else if (c1[1] > U) 
	    gy = U + 4.0; 
	else 
	    gy = 8.0 * floor(c1[1] / 8.0) + 4.0;
	if (c1[2] < L) 
	    gz = L + 4.0; 
	else if (c1[2] > U) 
	    gz = U + 4.0; 
	else 
	    gz = 8.0 * floor(c1[2] / 8.0) + 4.0;
	fx = c1[0] - gx;
	fy = c1[1] - gy;
	fz = c1[2] - gz;

	cn[0] = fy;
	cn[1] = fz - fy;
	cn[2] = -b * fy - a * fx;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 16.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel Four Dimensional Hyper-chaotic Coupled Dynamos System and Its Tracking Control and Synchronization
	Yanyun Xie1 and Wenliang Cai  2017
	http://www.sersc.org/journals/IJCA/vol10_no4/21.pdf
***************************************************************************/

int	DoANovelFourDimensionalHyperchaoticCoupledDynamos(void)

    {
    double	i, c1[4], cn[4], m;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    m = param[0];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -2.0 * c1[0] + c1[1] * (c1[2] + 3.0) + c1[3];
	cn[1] = -2.0 * c1[1] + c1[0] * (c1[2] - 3.0);
	cn[2] = c1[2] - c1[0] * c1[1];
	cn[3] = -m * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 16.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel Four-Dimensional Hyperchaotic System
	Liangrui Tang, Lin Zhao and Qin Zhang 2011
	https://link.springer.com/chapter/10.1007/978-3-642-23235-0_51
***************************************************************************/

int	DoANovelFourDimensionalHyperchaoticSystem(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[1] * c1[2];
	cn[1] = b * (c1[0] + c1[1]) - c1[0] * c1[2];
	cn[2] = c * c1[0] - d * c1[2] + c1[1] * c1[3];
	cn[3] = e * c1[1] - f * c1[3] + c1[0] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 16.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel Four-Wing Hyperchaotic Complex System and Its Complex Modified Hybrid Projective Synchronisation with Different Dimensions
	Jian Liu, Shutang Liu and Fangfang Zhang 5 June 2014
	https://www.hindawi.com/journals/aaa/2014/257327/
***************************************************************************/

int	DoANovelFourWingHyperchaoticComplexSystem(void)

    {
    double	i, c1[6], cn[6], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 6);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] - c1[2] * c1[4] + c1[5];
	cn[1] = a * c1[1] - c1[3] * c1[4];
	cn[2] = c1[0] * c1[4] - b * c1[2];
	cn[3] = c1[1] * c1[4] - b * c1[3];
	cn[4] = c1[0] * (c1[2] + c1[5]) + c1[1] * c1[3] - c * c1[4];
	cn[5] = -c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 16.0) % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel Hyperchaotic System with Infinitely Many Heteroclinic Orbits Coined
	Haijun Wang, Xianyi Li 22 November 2017
	https://reader.elsevier.com/reader/sd/A0620DFD24A633BB75DBC3A3039EC841C2F0958D69FC104EAD81628F419010A4A70CFDC6EEDC5E3C473C2B948260A634
***************************************************************************/

int	DoANovelHyperchaoticSystem(void)

    {
    double	i, c[5], cn[5], c1, d1, e1, c2, d2, e2, a1, a2, b;

    c[0] = param[10];	// x
    c[1] = param[11];	// y
    c[2] = param[12];	// z
    c[3] = param[13];	// u
    c[4] = param[14];	// v

    c1 = param[0];
    d1 = param[1];
    e1 = param[2];
    c2 = param[3];
    d2 = param[4];
    e2 = param[5];
    b = param[6];
    a1 = param[7];
    a2 = param[8];

    totpasses = 10;

    InitOscillator(c, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c[1];
	cn[1] = -c[1] + c1 * c[0] + d1 * c[0] * c[0] * c[0] + e1 * c[0] * c[4];
	cn[2] = c[3];
	cn[3] = -c[3] + c2 * c[2] + d2 * c[2] * c[2] * c[2] + e2 * c[2] * c[4];
	cn[4] = -b * c[4] + a1 * c[0] * c[0] + a2 * c[2] * c[2];
	if (DisplayOscillator(c, cn, dt, ((DWORD)(i / 16.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel Grid Multiwing Chaotic System with Only Non-Hyperbolic Equilibria
	Sen Zhang, Yicheng Zeng, Zhijun Li, Mengjiao Wang and Le Xiong 6 December 2017
	https://www.researchgate.net/publication/324484013
***************************************************************************/

int	DoANovelGridMultiwingChaoticSystem(void)

    {
    double	t, c1[4], cn[4], a, b, c, azao;
    double	p, p0, p1, p2, s, r, q, q1;
    int		n, m, i, j;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    n = (int)param[3];
    m = (int)param[4];
    azao = param[5];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	s = 0; r = 0;
	for (i = 1; i <= n; i++)
	    {
	    p1 = ((c1[2] + 2 * i) > 0.0) ? 1.0 : ((c1[2] + 2 * i) == 0.0 ? 0.0 : -1.0);
	    p2 = ((c1[2] - 2 * i) > 0.0) ? 1.0 : ((c1[2] - 2 * i) == 0.0 ? 0.0 : -1.0);
	    p0 = p1 + p2;
	    s += p0;
	    }
	p = c1[2] - s;
	for (j = -m; j <= m; j++)
	    {
	    q1 = (c1[1] + 2 * j * azao >= 0.0) ? 1.0 : -1.0;
	    r += q1;
	    }
	q = azao * r;

	cn[0] = -a * c1[0] + p;
	cn[1] = b - p * p;
	cn[2] = c * c1[0] * (c1[1] - q);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 16.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel Megastable Hamiltonian System with Infinite Hyperbolic and Nonhyperbolic Equilibria
	Gervais Dolvis Leutcho, Theophile Fonzin Fozin, Alexis Nguomkam Negou, Zeric Tabekoueng Njitacke, Viet-Thanh Pham, Jacques Kengne and Sajad Jafari 28 September 2020
	Sent to ManpWIN by Zeric Tabekoueng Njitacke through https://www.researchgate.net/requests/r80700131
***************************************************************************/

int	DoANovelMegastableHamiltonianSystem(void)

    {
    double	i, c1[3], cn[3], a, b, k, w, azao, m;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    k = param[2];
    w = param[3];
    azao = param[4];
    m = param[5];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[1];
	cn[1] = sin(a * c1[0]) + k * sin(b * c1[0]) + azao * sin(w * i);
	cn[2] = c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 160.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel Megastable Oscillator with a Strange Structure of Coexisting Attractors: Design, Analysis, and FPGA Implementation
	Kui Zhang, M. D. Vijayakumar, Sajjad Shaukat Jamal, Hayder Natiq, Karthikeyan Rajagopal, Sajad Jafari and Iqtadar Hussain 27 Aug 2021
	https://www.hindawi.com/journals/complexity/2021/2594965
***************************************************************************/

int	DoANovelMegastableOscillator(void)

    {
    double	i, c1[3], cn[3], w, a, r;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    w = param[0];
    a = param[1];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	r = sqrt(c1[0] * c1[0] + c1[1] * c1[1]);
	cn[0] = -0.1 * c1[1] + c1[0] * cos(r) / r + a * cos(w * i);
	cn[1] = sin(0.1 * c1[0]) + c1[1] * cos(r) / r;
	cn[2] = sqrt(sqr(sin(c1[0])) + sqr(cos(c1[1])));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 16.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel Memcapacitor Model and Its Application for Generating Chaos
	Guangyi Wang, Shiyi Jiang, Xiaowei Wang, Yiran Shen and Fang Yuan 20 November 2016
***************************************************************************/

int	DoANovelMemcapacitorModel(void)

    {
    double	i, c1[5], cn[5], m, n, j, k, a, b, b1, b2, t;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w
    c1[4] = param[14];	// v

    m = param[0];
    n = param[1];
    j = param[2];
    k = param[3];
    a = param[4];
    b = param[5];
    b1 = param[6];
    b2 = param[7];

    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = n * (j * ((b1 - b2 * c1[3]) * c1[2] - c1[0]) - c1[1]);
	cn[1] = m * (c1[0] - (a - b * c1[4]) * c1[1]);
	t = (b1 - b2 * c1[3]) * c1[2];
	cn[2] = k * t + j * (c1[0] - t);
	cn[3] = c1[2];
	cn[4] = c1[1];
	c1[3] += cn[3] * dt;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 160.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel Memductor-Based Chaotic System and Its Applications in Circuit Design and Experimental Validation
	Li Xiong, Yanjun Lu, Yongfang Zhang and Xinguo Zhang 3 January 2019
	https://www.hindawi.com/journals/complexity/2019/3870327/
***************************************************************************/

int	DoANovelMemductorBasedChaoticSystem(void)

    {
    double	i, c1[4], cn[4];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 4 * c1[0] + 2 * c1[1] + 0.025 * c1[3] - 2 * c1[0] * c1[3] * c1[3];
	cn[1] = 8 * c1[0] - c1[1] + 6 * c1[2];
	cn[2] = -2.5 * c1[1] - 0.5 * c1[2];
	cn[3] = -4 * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 160.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel Method for Constructing Grid Multi-Wing Butterfly Chaotic Attractors via Nonlinear Coupling Control
	Yun Huang 29 August 2016
	https://www.hindawi.com/journals/jece/2016/9143989/
***************************************************************************/

int	DoANovelMethodConstructingGridMultiWingButterfly(void)

    {
    double	t, c1[5], cn[5], a, b, c, h, a1, a2, a3, a4, a5, a6, fu, fv, s1, s2, k1, k2;
    int		i, j, n0 = 1, n2 = 1, m2 = 1, m1 = 0;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v

    a = param[0];
    b = param[1];
    c = param[2];
    h = param[3];
    a1 = param[4];
    a2 = param[5];
    a3 = param[6];
    a4 = param[7];
    a5 = param[8];
    a6 = param[9];

    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	cn[0] = a1 * c1[1] - a2 * c1[0];
	cn[1] = a3 * c1[0] - c1[1] - a4 * c1[0] * c1[2];
	cn[2] = a5 * c1[0] * c1[1] - a6 * c1[2];
	s1 = 0;
	for (i = -n0; i <= m1; i++)
	    {
	    k1 = fabs((c1[3] + 2 * i + 1) + (m1 - n0 + 1)) / ((c1[3] + 2 * i + 1) + (m1 - n0 + 1));
	    s1 += k1;
	    }
	fu = c1[3] - s1;
	cn[3] = a1 * c1[1] - a2 * fu + h * (c1[0] - c1[3]);
	s2 = 0;
	for (j = -n2; j <= m2; j++)
	    {
	    k2 = fabs((c1[4] + 2 * j + 1) + (m2 - n2 + 1)) / ((c1[4] + 2 * j + 1) + (m2 - n2 + 1));
	    s2 += k2;
	    }
	fv = c1[4] - s2;
	cn[4] = a3 * c1[0] - fv - a4 * c1[0] * c1[2] + h * (c1[1] - c1[4]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 16.0) % threshold), t, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel Multi-Attractor Period Multi-Scroll Chaotic Integrated Circuit Based on CMOS Wide Adjustable CCCII
	XIN ZHANG AND CHUNHUA WANG February 12, 2019.
	https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8625578
***************************************************************************/

int	DoANovelMultiAttractorPeriodMultiScroll(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e, h, m, fx, fy, fz, fw;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    h = param[5];
    m = param[6];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	fx = 5 * (fabs(c1[0] - 0.1 * (2 * (-1) - fabs(-1) / (-1)) + .01) - fabs(c1[0] - 0.1 * (2 * (-1) - fabs(-1) / (-1)) - 0.01) + fabs(c1[0] - 0.1 * (2 * (1) - fabs(1) / (1)) + 0.01) - fabs(c1[0] - 0.1 * (2 * (1) - fabs(1) / (1)) - 0.01));
	fy = 5 * (fabs(c1[1] - 0.1 * (2 * (-1) - fabs(-1) / (-1)) + .01) - fabs(c1[1] - 0.1 * (2 * (-1) - fabs(-1) / (-1)) - 0.01) + fabs(c1[1] - 0.1 * (2 * (1) - fabs(1) / (1)) + 0.01) - fabs(c1[1] - 0.1 * (2 * (1) - fabs(1) / (1)) - 0.01));
	fz = 5 * (fabs(c1[2] - 0.1 * (2 * (-1) - fabs(-1) / (-1)) + .01) - fabs(c1[2] - 0.1 * (2 * (-1) - fabs(-1) / (-1)) - 0.01) + fabs(c1[2] - 0.1 * (2 * (1) - fabs(1) / (1)) + 0.01) - fabs(c1[2] - 0.1 * (2 * (1) - fabs(1) / (1)) - 0.01));
	fw = 0.0; //REM 1.25 * (ABS(x(1) - .1 * (2 * (-1) - ABS(-1) / (-1)) + .01) - ABS(x(1) - .1 * (2 * (-1) - ABS(-1) / (-1)) - .01) + ABS(x(1) - .1 * (2 * (1) - ABS(1) / (1)) + .01) - ABS(x(1) - .1 * (2 * (1) - ABS(1) / (1)) - 0.01));
	cn[0] = a * (c1[3] - fw);
	cn[1] = b * c1[3] + c * (c1[0] - fx);
	cn[2] = d * c1[3] - e * (c1[2] - fz);
	cn[3] = -h * c1[3] - m * (c1[1] - fy);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 160.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel No-Equilibrium Chaotic System with Multiwing Butterfly Attractors
	Fadhil Rahma Tahir, Sajad Jafari, Viet-Thanh Pham, Christos Volos and Xiong Wang November 10, 2014
	https://www.researchgate.net/publication/269101599
***************************************************************************/

int	DoANovelNoEquilibriumChaoticMultiWingButterfly(void)

    {
    double	t, c1[4], cn[4], ux, s, azinho, a, k, c, p, e[4] = {0.0, 1.0222, 2.0444, 3.0667}, f[4] = {0.0, 1.1165, 1.1165, 1.1165};
    int		i, n;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    azinho = param[0];
    n = (int)param[1];
    a = param[2];
    k = param[3];
    c = param[4];

    if (n > 3) n = 3;
    if (n < 0) n = 0;


    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	s = 0.0;
	for (i = 1; i <= n; i++)
	    {
	    p = -f[i] * (2 + fabs(c1[0] - e[i]) / (c1[0] - e[i]) - fabs(c1[0] + e[i]) / (c1[0] + e[i]));
	    s += p;
	    }
	ux = k * fabs(c1[0]) + s;

	cn[0] = azinho * (c1[1] - c1[0]);
	cn[1] = -c1[2] * fabs(c1[0]) / c1[0];
	cn[2] = ux - 1.0;
	cn[3] = -c * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 16.0) % threshold), t, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel No-Equilibrium HR Neuron Model with hidden Homogeneous Extreme Multistability
	Sen Zhang, Jiahao Zheng, Xiaoping Wang and Zhigang Zeng 27 January 2021
***************************************************************************/

int	DoANovelNoEquilibriumHRNeuronModel(void)

    {
    double	t, c1[3], cn[3], a, b, c, d, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    k = param[4];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	cn[0] = c1[1] - a * c1[0] * c1[0] * c1[0] + b * c1[0] * c1[0] + k * cos(c1[2]) * c1[1];	// changed last term from variable 1 to variabel 2
	cn[1] = c - d * c1[0] * c1[0] - c1[1];
	cn[2] = c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 16.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel No-Equilibrium Hyperchaotic Multi-Wing System Via Introducing Memristor
	Ling Zhou, Chunhua Wang and Lili Zhou  12 February 2017
	https://www.researchgate.net/publication/315147844_A_novel_no-equilibrium_hyperchaotic_multi-wing_system_via_introducing_memristor
***************************************************************************/

int	DoANovelNoEquilibriumHyperchaoticMultiWingSystem(void)

    {
    double	t, c1[3], cn[3], f0, fy, s, v, alpha, beta, a, k, p, k1[4] = {0.8, 0.8, 0.6, 0.45}, f[4] = {5.0, 5.0, 6.667, 8.889}, e[4] = {2.0, 3.0, 4.0, 5.0};
    int		i, n;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alpha = param[0];
    beta = param[1];
    n = (int)param[2];
    a = param[3];
    k = param[4];
    p = param[5];

    if (n > 3) n = 3;
    if (n < 0) n = 0;


    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	f0 = k / p;
	s = 0.0;
	for (i = 0; i < n; i++)
	    {
	    f[i] = 2 * a * p / k1[i];
	    e[i] = 0.5 * (i + 1) * a * p / k1[i];
	    v = f[i] * (1 + 0.5 * (fabs(c1[1] - e[i]) / (c1[1] - e[i]) - 0.5 * fabs(c1[1] + e[i] / (c1[1] + e[i]))));
	    s += v;
	    }
	fy = f0 * c1[1] * c1[1] - v;

	cn[0] = alpha * (c1[1] - c1[0]);
	cn[1] = c1[1] - c1[0] * c1[2];
	cn[2] = fy - beta;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 16.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel Plaintext-Related Image Encryption Algorithm Based on Stochastic Signal Insertion and Block Swapping
	Shuliang Sun, Yongning Guo and Ruikun Wu 27 August 2019
	https://ieeexplore.ieee.org/abstract/document/8815763
***************************************************************************/

int	DoANovelPlaintextRelatedImageEncryptionAlgorithm(void)

    {
    double	t, c1[5], cn[5];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v

    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	cn[0] = 30 * (c1[1] - c1[0]) + c1[1] * c1[2] * c1[3];
	cn[1] = 10 * (c1[0] + c1[1]) + c1[4] - c1[0] * c1[2] * c1[3];
	cn[2] = -15.7 * c1[1] - 5 * c1[2] - 2.5 *c1[3] + c1[0] * c1[1] * c1[3];
	cn[3] = -4.45 * c1[3] + c1[0] * c1[1] * c1[2];
	cn[4] = -38.5 * (c1[0] + c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 16.0) % threshold), t, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Plethora of Coexisting Strange Attractors in a Simple Jerk System with Hyperbolic Tangent Nonlinearity 
	J. Kengne, S.M. Njikama, V.R. Folifack Signing 24 November 2017
	Received from the authors
***************************************************************************/

int	DoAPlethoraCoexistingStrangeAttractors(void)

    {
    double	i, c1[3], cn[3], a, g, mu;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    g = param[1];
    mu = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = a * c1[2];
	cn[2] = -3.0 * c1[0] - g * c1[1] - mu * c1[2] + 6.0 * tanh(c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 160.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Semi-Symmetric Image Encryption Scheme based on the Projective Synchronization of Two Hyperchaotic Systems
	Xiaoqiang Di, Jinqing Li, Hui Qi, Ligang Cong and Huamin Yang September 14, 2017
	https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0184586
***************************************************************************/

int	DoASemiSymmetricImageEncryptionScheme(void)

    {
    double	i, c1[6], cn[6], b, w01, w02, w03;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// x
    c1[4] = param[14];	// y
    c1[5] = param[15];	// z

    b = param[0];
    w01 = param[1];
    w02 = param[2];
    w03 = param[3];
    totpasses = 10;

    InitOscillator(c1, 6);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -2 * b * sqrt(1 - c1[0] * c1[0]) * sin(c1[1]);
	cn[1] = -w01 * (c1[0] - c1[2] - c1[4]) + 2 * b * c1[0] / sqrt(1 - c1[0] * c1[0]) * cos(c1[1]);
	cn[2] = -2 * b * sqrt(1 - c1[2] * c1[2]) * sin(c1[3]);
	cn[3] = -w02 * (c1[2] - c1[0] - c1[4]) + 2 * b * c1[2] / sqrt(1 - c1[2] * c1[2]) * cos(c1[3]);
	cn[4] = -2 * b * sqrt(1 - c1[4] * c1[4]) * sin(c1[5]);
	cn[5] = -w03 * (c1[4] - c1[0] - c1[2]) + 2 * b * c1[4] / sqrt(1 - c1[4] * c1[4]) * cos(c1[5]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 160.0) % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Simple Chaotic Circuit with a Hyperbolic Sine Function and its Use In a Sound Encryption Scheme
	Zhang Sena, Zeng Yichenga and Li Zhijunb 13 April 2018
	https://www.researchgate.net/publication/323658236_One_to_four-wing_chaotic_attractors_coined_from_a_novel_3D_fractional-order_chaotic_system_with_complex_dynamics
***************************************************************************/

int	DoASimpleChaoticCircuitWithHyperbolicSineFunction(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[1];
	cn[1] = -c1[2];
	cn[2] = -c1[0] - b * c1[2] + a * sinh(c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 160.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Simple Chaotic Oscillator for Educational Purposes
	A Tamasevicius, G Mykolaitis, V Pyragas and K Pyragas 3 November 2004
	http://users.df.uba.ar/sgil/physics_paper_doc/papers_phys/e&m/A%20simple%20chaotic.pdf
***************************************************************************/

int	DoASimpleChaoticOscillator4EducationalPurposes(void)

    {
    double	i, c1[3], cn[3], a, b, e, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    e = param[2];
    c = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = a * c1[1] - c1[0] - c1[2];
	cn[2] = (b + c1[1] - c * (exp(c1[2]) - 1.0)) / e;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 60.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Simple Chaotic System With Topologically Different Attractors
	KARTHIKEYAN RAJAGOPAL, AKIF AKGUL, IRENE M. MORO, ZHOUCHAO WEI, SAJAD JAFARI AND IQTADAR HUSSAIN July 23, 2019
	Received from Akif Akgul through Research Gate
***************************************************************************/

int	DoASimpleChaoticSystemWithTopologicallyDifferentAttractors(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] - c1[1] * c1[2];
	cn[1] = -b * c1[1] + c1[0] * c1[2];
	cn[2] = c - c1[2] + c1[0] * c1[1] + d * c1[2] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 60.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Simple Inductor-Free Memristive Circuit with Three Line Equilibria
	Qiwei Tan, Yicheng Zeng and Zhijun Li 19 June 2018
	https://www.researchgate.net/publication/326092327_A_simple_inductor-free_memristive_circuit_with_three_line_equilibria
***************************************************************************/

int	DoASimpleInductorFreeMemristiveCircuit(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, m, n, alpha, beta, eta, xi;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    m = param[4];
    n = param[5];
    alpha = param[6];
    beta = param[7];
    eta = param[8];
    xi = param[9];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (alpha + beta * c1[3] * c1[3]) * (c1[1] - c1[0]);
	cn[1] = b * ((alpha + beta * c1[3] * c1[3]) * (c1[1] - c1[0]) + (eta + xi* c1[2] * c1[2]) * c1[1] - d * c1[1]);
	cn[2] = -c * c1[1];
	cn[3] = -m * c1[3] - eta * (c1[1] - c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 60.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Simple Memristive Jerk System
	Chunbiao Li, Julien Clinton Sprott, Wesley Joo-Chen Thio and Zhenyu Gu 11 March 2021
	Sent to ManpWIN by Chunbiao Li through https://ietresearch.onlinelibrary.wiley.com/doi/full/10.1049/cds2.12035
***************************************************************************/

int	DoASimpleMemristiveJerkSystem(void)

    {
    double	i, c1[3], cn[3], a, b, wx;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	wx = 1.3 * c1[0] * c1[0] - 1;
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = -c1[2] - a * c1[2] * c1[2] - wx * c1[1] + b;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 60.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Simple Snap Oscillator with Coexisting Attractors, Its Time-Delayed Form, Physical Realisation, and Communication Designs
	Karthikeyan Rajagopa, Sajad Jafari, Akif Akgul, Anitha Karthikeyan, Serdar Cicek  and Yasser Shekofteh April 10, 2018 received from the author
***************************************************************************/

int	DoASimpleSnapOscillator(void)

    {
    double	i, c1[4], cn[4], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = c1[3];
	cn[3] = -c * c1[0] - b * c1[1] - a * c1[3] - tan(c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 160.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Strange Novel Chaotic System with Fully Golden Proportion Equilibria and its Mobile Microcomputer-Based RNG Application-II
	Akin Ozdemira, Ihsan Pehlivanb, Akif Akgul and Emre Guleryuz  26 September 2018
	Sent by one of the authors
***************************************************************************/

int	DoAStrangeNovelChaoticSystemFullyGoldenProportionEquilibria(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[0] - c1[1] * c1[2];
	cn[1] = c * c1[0] - c1[1] - c1[0] * c1[2];
	cn[2] = b * c1[0] * c1[1] + a;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 160.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Study on Four-Species Fractional Population Competition Dynamical Model
	Sunil Kumar, Ajay Kumar, Abdel-Haleem, Abdel-Aty and M.R.Alharthi 2021
	https://www.sciencedirect.com/science/article/pii/S2211379721002473#f0010
***************************************************************************/

int	DoAStudyonFourSpeciesFractionalPopulation(void)

    {
    double	i, c1[4], cn[4], r, k, m1, m2, m3, a1 = 0.5, a2 = sqrt(0.5), a3 = sqrt(0.75), d1, d2, d3;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    r = param[0];
    k = param[1];
    m1 = param[2];
    m2 = param[3];
    m3 = param[4];
    d1 = param[5];
    d2 = param[6];
    d3 = param[7];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = r * c1[0] * (1 - c1[0] / k) - m1 * c1[1] * c1[0] * c1[0] / (a1 * a1 + c1[0] * c1[0]) - m2 * c1[2] * c1[0] * c1[0] / (a2 * a2 + c1[0] * c1[0]) - m3 * c1[3] * c1[0] * c1[0] / (a3 * a3 + c1[0] * c1[0]);
	cn[1] = m1 * c1[1] * c1[0] * c1[0] / (a1 * a1 + c1[0] * c1[0]) - d1 * c1[1];
	cn[2] = m2 * c1[2] * c1[0] * c1[0] / (a2 * a2 + c1[0] * c1[0]) - d2 * c1[2];
	cn[3] = m3 * c1[3] * c1[0] * c1[0] / (a3 * a3 + c1[0] * c1[0]) - d3 * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 160.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A True Three-Scroll Chaotic Attractor Coined
	Haijun Wang, Hongdan Fan and Jun Pan 2021
***************************************************************************/

int	DoATrueThreeScrollChaoticAttractorCoined(void)

    {
    double	i, c1[3], cn[3], a, d, f, e, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    d = param[1];
    f = param[2];
    e = param[3];
    c = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + d * c1[0] * c1[2];
	cn[1] = -c1[0] * c1[2] + f * c1[1];
	cn[2] = -e * c1[0] * c1[0] + c1[0] * c1[1] + c * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 160.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Unique Signum Switch for Chaos and Hyperchaos
	Chunbiao Li, Julien Clinton Sprott, Wesley Thio and Huanqiang Zhu August 2015
	https://www.researchgate.net/publication/318206297
***************************************************************************/

int	DoAUniqueSignumSwitch(void)

    {
    double	i, c1[4], cn[4], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - c1[0];
	cn[1] = -c1[2] * fabs(c1[0]) / c1[0];
	cn[2] = c1[0] * fabs(c1[1]) / c1[1] - a;
	cn[3] = -b * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 160.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Abundant Coexisting Multiple Attractors’ Behaviours in Three-Dimensional Sine Chaotic System
	Huagan Wu, Han Bao, Quan Xu and Mo Chen 6 December 2019
	https://www.hindawi.com/journals/complexity/2019/3687635/
***************************************************************************/

int	DoAbundantCoexistingMultipleAttractorsBehaviors(void)

    {
    double	i, c1[3], cn[3], k1, k2;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    k1 = param[0];
    k2 = param[1];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] + c1[2] - k1 * sin(c1[1]);
	cn[1] = -c1[0] + c1[2];
	cn[2] = -c1[0] - c1[2] + k2 * sin(c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 160.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	ACT Chaotic Attractor fractal map Images
***************************************************************************/

int	DoACT(void)

    {
    double	i, c1[3], cn[3], a, b, m, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    d = param[2];
    m = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[0] - c1[1]);
	cn[1] = -4.0 * a * c1[1] + c1[0] * c1[2] + m * c1[0] * c1[0] * c1[0];
	cn[2] = -d * a * c1[2] + c1[0] * c1[1] + b * c1[2] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Active Tracking Control Of The Hyperchaotic Lc Oscillator System
	XINGYUAN WANG, BIN JIA, MINGJUN WANG 2 August 2006
***************************************************************************/

int	DoActiveTracking(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, h, mu, epsilon;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    mu = param[4];
    epsilon = param[5];
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	h = ((c1[3] - 1.0) > 0.0) ? c1[3] - 1.0 : 0.0;
	cn[0] = a * c1[0] - c1[1] - c1[2] + c1[3];
	cn[1] = c1[0] - b * c1[1];
	cn[2] = (c1[0] - c * c1[2] - c1[3]) / mu - 1.0;
	cn[3] = (c1[2] - d * (c1[3] + c1[0]) * h) / epsilon;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Adaptive Hybrid Dislocated Synchronisation for Two Identical and Different Memristor Chaotic Oscillator Systems with Uncertain Parameters
	Jie Chen, Junwei Sun, Ming Chi and Xin-Ming Cheng 27 January 2014
***************************************************************************/

int	DoAdaptiveHybridDislocatedSync(void)

    {
    double	i, c1[4], cn[4], a1, a2, a3, a4, phi;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a1 = param[0];
    a2 = param[1];
    a3 = param[2];
    a4 = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	phi = (fabs(c1[2]) < 1.0) ? 0.1 : 18.0;				// changed the variable from W to Z with marvelous images
	cn[0] = a1 * (c1[2] - phi * c1[0]);
	cn[1] = a2 * c1[1] - a3 * c1[2];
	cn[2] = c1[1] - c1[0] - a4 * c1[2];
	cn[3] = c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Adaptive Hybrid Synchronisation of Chaotic Systems for Chaotic Masking
	Rajagopal Karthikeyan, Vaidhyanathan Sundarapandian, Girma Adam and Nura Halake 2016
	https://www.researchgate.net/project/Elsevier-Book-Recent-Advances-in-Chaotic-Systems-and-Synchronization-From-Theory-to-Real-World-Applications
***************************************************************************/

int	DoAdaptiveHybridSynchronisationChaoticSystems(void)

    {
    double	i, c1[3], cn[3], a, b, c, p, q;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    p = param[3];
    q = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = (a - p * c1[0] - c1[1] - c1[2]) * c1[0];
	cn[1] = (c1[0] - c) * c1[1];
	cn[2] = (b - c1[0] - q * c1[2]) * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Adaptive Synchronisation of a Hyperchaotic Oscillator Images
	Theoretical Analysis and Adaptive Synchronisation of a 4D
	Hyperchaotic Oscillator T. Fonzin Fozin, J. Kengne, F. B. Pelap 27 February 2014
***************************************************************************/

int	DoAdaptiveSync(void)

    {
    double	i, c1[4], cn[4], s, e1, e2, a, g, f, q;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    s = param[0];
    e1 = param[1];
    e2 = param[2];
    a = param[3];
    g = param[4];
    q = param[5];
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	f = exp(c1[3]) - 1.0;
	cn[0] = c1[2];
	cn[1] = e1 * (c1[2] - c1[3] - g * f);
	cn[2] = s * c1[2] - c1[0] - a * f;
	cn[3] = (s * c1[2] - c1[0] - a * f - e2 * (q * f - c1[1])) / (1.0 + g * (f + 1.0));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Adaptive Inverse Optimal Control of a Novel Fractional-Order Four-Wing Hyperchaotic System with Uncertain Parameter and Circuitry Implementation
	Chaojun Wu, Gangquan Si,Yanbin Zhang, and Ningning Yang 11 August 2014
***************************************************************************/

int	DoAdaptiveInverse(void)

    {
    double	i, c1[4], cn[4], a, b, c, h, k, g, m, n, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    h = param[3];
    k = param[4];
    g = param[5];
    m = param[6];
    n = param[7];
    e = param[8];

    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (-c1[0] + c1[1] * c1[2]);
	cn[1] = b * c1[1] - h * c1[0] * c1[2] + c * c1[3];
	cn[2] = k * c1[0] * c1[1] - g * c1[2] + e * c1[3];
	cn[3] = -(m * c1[1] + n * c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Aizawa Chaotic Attractor Oscillator Images
***************************************************************************/

int	DoAizawa(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = (c1[2] - b) * c1[0] - d * c1[1];
	cn[1] = d * c1[0] + (c1[2] - b) * c1[1];
	cn[2] = c + a * c1[2] - c1[2] * c1[2] * c1[2] / 3 - (c1[0] * c1[0] + c1[1] * c1[1]) * (1 + e * c1[2]) + f * c1[2] * c1[0] * c1[0] * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Amplitude Death and Synchronized States in Nonlinear Time-Delay Systems Coupled Through Mean-Field Diffusion
	Tanmoy Banerjee, Debabrata Biswas and MARCUS REZENDE 16 May 2014
	https://arxiv.org/pdf/1305.0150.pdf
***************************************************************************/

int	DoAmplitudeDeath(void)

    {
    double	i, c1[3], cn[3], m, n, L, a, b, d, f, Lr;

    c1[0] = param[10];	// x
    c1[1] = 0.0;	// y
    c1[2] = 0.0;	// z

    m = param[0];
    n = param[1];
    L = param[2];
    a = param[3];
    b = param[4];
    totpasses = 10;
    cn[0] = c1[0];

    InitOscillator(c1, 1);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	d = L * cn[0];
	Lr = (exp(d) - exp(-d)) / (exp(d) + exp(-d));
	f = -0.5 * n * (fabs(c1[0]) + c1[0]) + m * Lr;

	cn[0] = cos(a * c1[0]) - sin(b * f);				// these two trigonometric functions were invented by me. The original were xn=a*x-b*f
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 1, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Amplitude-Phase Control of a Novel Chaotic Attractor
	Chunbiao LI, Ihsan  PEHLIVAN  and Julien Clinton SPROTT 01/01/2016
***************************************************************************/

int	DoAmplitudePhaseControl(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] - c1[1] * c1[2];
	cn[1] = -a * c1[1] + c1[0] * c1[2];
	cn[2] = -b * c1[1] - c * c1[2] + c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	An Efficient Approach for Fractional Nonlinear Chaotic Model with Mittag-Leffler Law
	P.Veeresha, D.G.Prakasha, Abdel-Haleem, Abdel-Aty, Harendra Singh, Emad E.Mahmoud and Sunil Kumarh 21 January 2021
	https://www.sciencedirect.com/science/article/pii/S1018364721000082#f0020
***************************************************************************/

int	DoAnEfficientApproachFractionalNonlinearChaoticModel(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -2 * c1[0] - c1[1] * c1[1];
	cn[1] = -4 * c1[0] * c1[2] + 3 * c1[1] - c1[2] * c1[2];
	cn[2] = 4 * c1[0] * c1[1] - 7 * c1[2] + c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	An Eight-Term Novel Four-Scroll Chaotic System with Cubic Nonlinearity and its Circuit Simulation
	S. Sampath, S. Vaidyanathan, Ch. K. Volos and V.-T. Pham 14 November 2014
	http://www.jestr.org/downloads/Volume8Issue2/fulltext8212015.pdf
***************************************************************************/

int	DoAnEightTermNovelFourScrollChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + b * c1[1] * c1[2];
	cn[1] = -10 * c1[1] * c1[1] * c1[1] - c1[1] + 4 * c1[0] * c1[2];
	cn[2] = c * c1[2] - c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	An Image Encryption Algorithm based on Chaotic System and Compressive Sensing
	Xiuli Chai, Xiaoyu Zheng, Zhihua Gan, Daojun Han and Yiran Chen 6 February 2018
	https://www.researchgate.net/publication/324106366
***************************************************************************/

int	DoAnImageEncryptionAlgorithm(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, g, r;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    g = param[4];
    r = param[5];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[0] + b * c1[1] + c1[1] * c1[2];
	cn[1] = -0.5 * c1[0] * c1[2] + c * c1[0] - d * c1[0] * cosh(0.02 * c1[3]);
	cn[2] = 0.8 * c1[0] * c1[1] - r * c1[2];
	cn[3] = g * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	An Improved Butterfly Optimisation Algorithm with Chaos -  Chebyshev
	Arora, Sankalapa and Singh, Satvirb 2017 - furnished by the author
***************************************************************************/

int	DoAnImprovedButterflyOptimizationAlgorithm(void)

    {
    double	i, c1[3], cn[3], k, real, imag;

    c1[0] = cn[0] = param[10];	// x
    c1[1] = cn[1] = param[11];	// y
    c1[2] = 1.0;		// z

    k = param[0];
    real = param[1];
    imag = param[2];
    totpasses = 10;

    InitOscillator(c1, 2);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	c1[0] = cn[0];
	cn[0] = cos(k * acos(c1[0]));
	cn[1] = real * cos(c1[0]) + imag * sin(cn[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 2, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	An Infinite 2D Lattice of Strange Attractors
	Chunbiao Li, Julien Clinton Sprott and Yong Mei 9 June 2017
	http://sprott.physics.wisc.edu/pubs/paper480.pdf
***************************************************************************/

int	DoAnInfinite2DLatticeStrangeAttractors(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = sin(c1[1]);
	cn[1] = sin(c1[2]);
	cn[2] = 0.442 * c1[0] - sin(c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	An Infinite 3D Quasiperiodic Lattice of Chaotic Attractors
	Chunbiao Li  and Julien Clinton Sprott 19 December 2017
	http://sprott.physics.wisc.edu/pubs/paper491.pdf
***************************************************************************/

int	DoAnInfinite3DLatticeStrangeAttractors(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = sin(a * c1[1]) - b * sin(c1[0]);
	cn[1] = sin(a * c1[2]) - b * sin(c1[1]);
	cn[2] = sin(a * c1[0]) - b * sin(c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	An Introductions to Harmonic Knots - Generic knots - page 359
	Corresponding author: akt@carthague.edu
***************************************************************************/

int	DoAnIntroductions2HarmonicKnotsOsc(void)

    {
    double	i, c1[3], cn[3], p, q;

    cn[0] = c1[0] = param[10];	// x
    cn[1] = c1[1] = param[11];	// y
    cn[2] = c1[2] = param[12];	// z

    p = param[0];
    q = 4 * p + 1;
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = cos(p * i) + 0.25 * cos(p * i) * cos(q * i);
	cn[1] = sin(p * i) + 0.25 * sin(p * i) * cos(q * i);
	cn[2] = 0.25 * sin(q * i);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	An Unforced Megastable Chaotic Oscillator and its Application on Protecting Electrophysiological Signals
	Akif Akgul, Omer Faruk Boyraz, Karthikeyan Rajagopal, Emre Guleryuz, Mustafa Zahid Yildiz and Mustafa Kutlu September 30, 2020
	Send to ManpWIN by Akif Akgul through https://www.researchgate.net/requests/r78190109
***************************************************************************/

int	DoAnUnforcedMegastableChaoticOscillator(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2];
	cn[1] = b * cos(c1[2]) - c * c1[1];
	cn[2] = -d * c1[0] + c1[2] * cos(c1[0]) - a * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Analysis, Adaptive Control and Synchronization of a Novel 4-D Hyperchaotic Hyperjerk System and its SPICE Implementation
	Viet-Thanh Pham, Sundarapandian Vaidyanathan, Christos K. Volos, Sajad Jafari and Xiong Wang 6.02.2015
***************************************************************************/

int	DoAnalysisAdaptiveControlSync(void)

    {
    double	i, c1[4], cn[4], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = c1[3];
	cn[3] = -c1[0] - c1[1] - b * c1[0] * c1[0] - a * c1[2] - c * c1[0] * c1[0] * c1[0] * c1[0] * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Analysis and Characterisation of the Hyperchaos Generated by a Semiconductor Laser Subject to a Delayed Feedback Loop
	Raul Vicente, Jose Dauden, Pere Colet, and Raul Toral 4, APRIL 2005
	https://pdfs.semanticscholar.org/cc8d/bcae04ab3918604ac2582927e59dd054e7bc.pdf
***************************************************************************/

int	DoAnalysisCharacterisationHyperchaos(void)

    {
    double	i, c1[3], cn[3], b, f, real, imag;

    c1[0] = cn[0] = param[10];	// x
    c1[1] = cn[1] = param[11];	// y
    c1[2] = 1.0;		// z

    f = 5.0 * PI / 6.0;
    b = param[0];
    real = param[1];
    imag = param[2];
    totpasses = 10;

    InitOscillator(c1, 2);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[0] + b * sqr(sin(cn[0] - f));
	cn[1] = real * cos(c1[0]) + imag * sin(cn[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 2, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Analysis and Implementation of a Floating Memristor Chaotic Circuit
	Tan Zhiping, Zeng Yicheng, Li Zhijun and Hong Qinghui December 2014
	https://www.researchgate.net/publication/288471638
***************************************************************************/

int	DoAnalysisImplementationFloatingMemristorChaoticCircuit(void)

    {
    double	i, c1[4], cn[4], alpha, beta, c, d, a, b, www;

    c1[0] = cn[0] = param[10];	// x
    c1[1] = cn[1] = param[11];	// y
    c1[2] = cn[2] = param[12];	// z
    c1[3] = cn[3] = param[13];	// w

    alpha = param[0];
    beta = param[1];
    c = param[2];
    d = param[3];
    a = param[4];
    b = param[5];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	www = (fabs(c1[3]) < 1) ? a : b;
	cn[0] = alpha * c1[0] - beta * (c1[0] - c1[1]) * www;
	cn[1] = (c1[0] - c1[1]) * www + c1[2];
	cn[2] = -c * c1[1] - d * c1[2];
	cn[3] = c1[1] - c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Analysis, Control and Circuit Design of a Novel Chaotic System with Line Equilibrium
	A Sambas1, S Vaidyanathan, M Mamat, M Sanjaya WS, S H Yuningsih and K Zakaria 2010
	http://iopscience.iop.org/article/10.1088/1742-6596/1090/1/012010/meta
***************************************************************************/

int	DoAnalysisControlCircuitDesign(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - c1[0] * c1[2] - c1[1] * c1[2];
	cn[1] = a * c1[0] * c1[2];
	cn[2] = c1[1] * c1[1] - b * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Analysis, Stabilisation, and DSP-Based Implementation of a Chaotic System with Nonhyperbolic Equilibrium
	Xuan-Bing Yang, Yi-Gang He, Chun-Lai Li and Chang-Qing Liu 8 January 2020
	http://downloads.hindawi.com/journals/complexity/2020/6786832.pdf
***************************************************************************/

int	DoAnalysisStabilisationDSPBasedImplementation(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[0] + b * c1[1];
	cn[1] = e * c1[1] - f * c1[0] * c1[2];
	cn[2] = -c * c1[2] * c1[2] * c1[2] + d * c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Analysis of a 4-D Hyperchaotic Fractional-Order Memristive System with Hidden Attractors
	Christos Volos, V.-T. Pham, E. Zambrano-Serrano, J.M. Munoz-Pacheco, Sundarapandian Vaidyanathan and E. Tlelo-Cuautle 2017 received from the first author
***************************************************************************/

int	DoAnalysis4DHyperchaoticFractionalOrderMemristiveSystem(void)

    {
    double	i, c1[4], cn[4], b, c;

    c1[0] = cn[0] = param[10];	// x
    c1[1] = cn[1] = param[11];	// y
    c1[2] = cn[2] = param[12];	// z
    c1[3] = cn[3] = param[13];	// w

    b = param[0];
    c = param[1];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -10.0 * c1[0] - b * c1[1] - c1[1] * c1[2];
	cn[1] = -6.0 * c1[0] + 1.2 * c1[0] * c1[2] + 0.1 * c1[1] - c;
	cn[2] = -c1[2] - 1.2 * c1[1] * c1[1];
	cn[3] = c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Analysis of a Chaotic System with Line Equilibrium and Its Application to Secure Communications Using a Descriptor Observer
	Lazaros Moysis, Christos Volos, Viet-Thanh Pham, Sotirios Goudos, Ioannis Stouboulos, Mahendra Kumar Gupta and Vikas Kumar Mishra 24 October 2019
	Received from author Ioannis Stouboulos through Google Scholar Alerts <scholaralerts-noreply@google.com>
***************************************************************************/

int	DoAnalysisChaoticSystemWithLineEquilibrium(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = cn[0] = param[10];	// x
    c1[1] = cn[1] = param[11];	// y
    c1[2] = cn[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] * c1[2];
	cn[1] = c1[0] * fabs(c1[0]) - c1[1] * fabs(c1[1]);
	cn[2] = fabs(c1[0]) - a * c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Analysis of a New Three-Dimensional Chaotic System
	Xuebing Zhang, Honglan Zhu and Hongxing Yao 2 March 2011
	https://www.researchgate.net/publication/251383855_Analysis_of_a_new_three-dimensional_chaotic_system
**************************************************************************/

int	DoAnalysisNewThreeDimensionalChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = cn[0] = param[10];	// x
    c1[1] = cn[1] = param[11];	// y
    c1[2] = cn[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[0] + b * c1[1] - c1[1] * c1[2];
	cn[1] = c1[0] + c1[0] * c1[2];
	cn[2] = -c * c1[2] + c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Analysis of Three Types of Initial Offset-Boosting Behaviour for a New Fractional-Order Dynamical System
	Shuangquan Gu, Shaobo He, Huihai Wang and Baoxiang Du 21 December 2020
	Sent to ManpWIN by Shuangquan Gu by   through https://www.researchgate.net/publication/348497655
**************************************************************************/

int	DoAnalysisThreeTypesInitialOffsetBoostingBehaviour(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e, g, k;

    c1[0] = cn[0] = param[10];	// x
    c1[1] = cn[1] = param[11];	// y
    c1[2] = cn[2] = param[12];	// z
    c1[3] = cn[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    g = param[5];
    k = param[6];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[1];
	cn[1] = -b * (c1[0] + k * c1[1] * c1[2]);
	cn[2] = c + d * fabs(c1[2]) + e * c1[1] * c1[1];
	cn[3] = c1[2] * c1[3] - c1[2] + g * c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Anishchenko-Astakhov Chaotic Attractor Images
***************************************************************************/

int	DoAnishchenko(void)

    {
    double	i, c1[3], cn[3], a, b, c, s;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    s = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = -a * c1[0] - b * c1[1] * c1[2];
	cn[2] = -c + c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Analysis and Implementation of a New Switching Memristor Scroll Hyperchaotic System and Application in Secure Communication - II
	Ping Liu, Rui Xi, Pengbo Ren, Jialin Hou and Xiang Li 2 July 2018
	https://www.hindawi.com/journals/complexity/2018/3497640/
***************************************************************************/

int	DoAnalysisImplementationNewSwitchingHyperchaoticSystem(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, fw, gx, hy;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	fw = d * c1[3] * c1[3];
	gx = 0.9 * c1[0];
	hy = 12 * (fabs(c1[1]) / c1[1] + fabs(c1[1] - 24) / (c1[1] - 24) + fabs(c1[1] + 24) / (c1[1] + 24) + fabs(c1[1] - 48) / (c1[1] - 48) + fabs(c1[1] + 48) / (c1[1] + 48));
//	    hy = 12 * (fabs(c1[1]) / c1[1] + fabs(c1[1] - 24) / (c1[1] - 24) + fabs(c1[1] + 24) / (c1[1] + 24) 
//						+ fabs(c1[1] - 48) / (c1[1] - 48) + fabs(c1[1] + 48) / (c1[1] + 48) + fabs(c1[1] + 12) / (c1[1] + 12) + fabs(c1[1] - 12) / (c1[1] - 12));

	cn[0] = a * (fw * (c1[1] - c1[0] - hy) + gx);
	cn[1] = fw * (c1[0] - c1[1] + hy) + c1[2];
	cn[2] = -b * (c1[1] - hy);
	cn[3] = c1[1] - c1[0] - hy - c * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Analysis and Projective Synchronisation of New 4D Hyperchaotic System
	Ayub Khan and Muzaffar Ahmad Bhat 20 July 2017
	http://www.worldacademicunion.com/journal/jus/jusVol11No4paper02.pdf
***************************************************************************/

int	DoAnalysisProjectiveSynchronisationNew4DHyperchaoticSystem(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[0] - a * c1[1] + c1[1] * c1[2];
	cn[1] = b * c1[1] - c1[0] * c1[2] - c1[3];
	cn[2] = -c * c1[2] + c1[0] * c1[1];
	cn[3] = d * c1[3] + c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Analysis, Control and FPGA Implementation of a Fractional Order Modified Shinriki Circuit
	Karthikeyan Rajagopal, Fahimeh Nazarimehr, Laarem Guessas, Anitha Karthikeyan, Ashokkumar Srinivasan and Sajad Jafari 2019
	Sent to Marcus by the co-author Ashok kumar Srinivasanin the 09/25/2019
***************************************************************************/

int	DoAnalysisControlFPGAImplementation(void)

    {
    double	i, c1[4], cn[4], a1, b1, sigma, gamma, alpha, beta, eta1, eta2, delta, sh, ch, ep, w1;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a1 = param[0];
    b1 = param[1];
    sigma = param[2];
    gamma = param[3];
    alpha = param[4];
    beta = param[5];
    eta1 = param[6];
    eta2 = param[7];
    delta = param[8];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	sh = sinh(c1[0] - c1[1]);
	ch = cosh(c1[0] - c1[1]);
	ep = exp(c1[3]);
	w1 = a1 + b1 * c1[0] * c1[0];

	cn[0] = -c1[2] - delta * c1[0] - gamma * sh * ep;
	cn[1] = eta1 * ((beta - alpha) * c1[1] + gamma * ep * sh);
	cn[2] = c1[0] + w1;
	cn[3] = eta2 * (-sigma * c1[3] + gamma * ep * ch - gamma);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Analysis of a New Three-Dimensional System with Multiple Chaotic Attractors
	Zhi-Hong Guan, Qiang Lai,· Ming Chi, Xin-Ming Cheng and Feng Liu 26 September 2013
	https://www.researchgate.net/requests/r52652220
***************************************************************************/

int	DoAnalysisNewThreeDimensionalSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    k = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] - c1[1] * c1[2] - c1[1] + k;
	cn[1] = -b * c1[1] + c1[0] * c1[2];
	cn[2] = -c * c1[2] + c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Analysis of a Three-Dimensional Chaotic System and its FPGA Implementation
	Hefei Li and Xianghui Hu Jan. 19-22 - 2017
	https://pdfs.semanticscholar.org/32ae/96aee06b3c954528d041ea74a9f9ef8df1e2.pdf
***************************************************************************/

int	DoAnalysisThreeDimensionalChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -(a * b / (a + b)) * c1[0] - c1[1] * c1[2];
	cn[1] = a * c1[1] + c1[0] * c1[2];
	cn[2] = b * c1[2] + c1[0] * c1[1] + c * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Analysis of Chaotic Oscillations Induced in Two Coupled Wilson–Cowan Models
	Yuya Maruyama · Yuta Kakimoto · Osamu Araki 1 May 2014
***************************************************************************/

int	DoAnalysisWilsonCowan(void)

    {
    double	i, c[4], cn[4], te, ti, ke, ki, se, si, alpha, beta, c1, c2, c3, c4, p1 = 0.0;

    c[0] = param[10];	// x
    c[1] = param[11];	// y
    c[2] = param[12];	// z
    c[3] = param[13];	// w

    te = param[0];
    ti = param[1];
    ke = param[2];
    ki = param[3];
    c1 = param[4];
    c2 = param[5];
    c3 = param[6];
    c4 = param[7];
    alpha = param[8];
    beta = param[9];
    se = 1.0;
    si = 5.0;
    totpasses = 10;

    InitOscillator(c, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = (-c[0] + (ke - c[0]) * se * (c1 * c[0] - c2 * c[1] + p1)) / te;
	cn[1] = (-c[1] + (ki - c[1]) * si * (c3 * c[0] - c4 * c[1])) / ti;
	cn[2] = (-c[2] + (ke - c[2]) * se * (c1 * c[2] - c2 * c[3] + alpha * c[0])) / te;
	cn[3] = (-c[3] + (ki - c[3]) * si * (c3 * c[2] - c4 * c[3] + beta * c[0])) / ti;
	if (DisplayOscillator(c, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Analysis of Two Time Scale Property of Singularly Perturbed System on Chaotic Attractor-II
	The Rosenzweig-Mac Arthur Model
	Mozhgan Mombeini, Ali Khaki Sedigh, Mohammad Ali Nekoui 3 june 2011
	https://arxiv.org/ftp/arxiv/papers/1205/1205.3914.pdf
***************************************************************************/

int	DoAnalysisTwoTimeScaleProperty(void)

    {
    double	i, c1[3], cn[3], b1, b2, d1, d2, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    b1 = param[0];
    b2 = param[1];
    d1 = param[2];
    d2 = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 1.0 / e * (c1[0] * (1.0 - c1[0] - c1[1] / (b1 + c1[0])));
	cn[1] = c1[1] * (c1[0] / (b2 + c1[0]) - d1 - c1[2] / (b2 + c1[1]));
	cn[2] = e * c1[2] * (c1[1] / (b2 + c1[1]) - d2);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Analysis, Synchronisation, and Robotic Application of a Modified Hyperjerk Chaotic System
	Lazaros Moysis, Eleftherios Petavratzis, Muhammad Marwan, Christos Volos, Hector Nistazakis  and Salman Ahmad 30 April 2020
	https://www.researchgate.net/publication/341071130
***************************************************************************/

int	DoAnalysisSynchronisationRoboticApplication(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, gamma;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    gamma = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = c1[3];
	cn[3] = -a * c1[3] - b * c1[1] - c * c1[0] - gamma * sinh(d + c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 16.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Analytical-Numerical Methods for Search of Hidden Oscillations
	in Multidimensional Dynamical Systems
	I. M. Burkin, Nguyen Ngoc Hien MARCH, 2014
***************************************************************************/

int	DoAnalyticalNumerical(void)

    {
    double	i, c1[3], cn[3], e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    e = exp(1.0);
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 1.241 * c1[0] + 8.45 * c1[1] - 1.4365 * (pow(c1[0], 4) + 0.2) / (0.34 * pow(c1[0], 4) + 0.2) 
				* (pow(e, c1[0]) - pow(e, (-c1[0]))) / (pow(e, c1[0]) + pow(e, (-c1[0])));
	cn[1] = c1[0] - c1[1] + c1[2] + 0.1 * c1[1] * c1[1] * c1[1];
	cn[2] = -12.1 * c1[1] - 0.005 * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Analytic Proof of the Emergence of New Type of Lorenz-Like Attractors with Z4-Symmetry
	Attractors from the Triple Instability in Systems with Attractors from the Triple Instability in Systems With Z4-Symmetry
	Efrosiniia Karatetskaia, Alexey Kazakov, Klim Safonov and Dmitry Turaev https://arxiv.org/pdf/2408.06066.....  August 2024
	Corresponding authors: eyukaratetskaya@gmail.com, kazakovdz@yandex.ru, safonov.klim@yandex.ru, d.turaev@imperial.ac.uk
***************************************************************************/

int	DoAnalyticProofEmergenceNewTypeLorenzAttractors(void)

    {
    double	i, c1[3], cn[3], a, b, mm, m1, m2, m3, m4, m5, m6;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    mm = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	m1 = sqr(c1[0]) * c1[1] + c1[0] * sqr(c1[1]);
	m2 = sqr(c1[0]) * c1[1] - c1[0] * sqr(c1[1]);
	m3 = c1[0] + c1[1];
	m4 = c1[0] - c1[1];
	m5 = sqr(c1[0]) - sqr(c1[1]);
	m6 = sqr(c1[0]) + sqr(c1[1]);

	cn[0] = -a * c1[0] - b * c1[1] - 0.5 * c1[2] * m4 + 0.5 * m1 + 3.0 / 8.0 * sqr(c1[2]) * c1[0] - 1.0 / 8.0 * sqr(c1[2]) * c1[1];
	cn[1] = b * c1[0] - a * c1[1] + 0.5 * c1[2] * m3 + 0.5 * m1 + 1.0 / 8.0 * sqr(c1[2]) * c1[0] + 3.0 / 8.0 * sqr(c1[2]) * c1[1];
	cn[2] = mm * c1[2] + m5 - 0.25 * pow(c1[2], 3) - 0.5 * c1[2] * m6;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Anisochronous Self-Excited Systems
	Experiment on Bifurcation and Chaos in Coupled Anisochronous Self-Excited Systems: 
	Case of Two Coupled van der Pol-Duffing Oscillators
	J. Kengne, F. Kenmogne, and V. Kamdoum Tamba 29 October 2014
***************************************************************************/

int	DoAnisochronousSelfExcited(void)

    {
    double	i, c1[4], cn[4], e, beta, mi, delta;

    c1[0] = param[10];	// x1
    c1[1] = param[11];	// x2
    c1[2] = param[12];	// x3
    c1[3] = param[13];	// x4

    e = param[0];
    beta = param[1];
    mi = param[2];
    delta = param[3];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = (e - c1[0] * c1[0]) * c1[1] /* - c1[0] - beta * c1[2] * c1[2] * c1[2]*/ + mi * (c1[3] - c1[1]);
	cn[2] = c1[3];
	cn[3] = (e - c1[2] * c1[2]) * c1[3] - (1.0 + delta) * c1[2] - beta * c1[2] * c1[2] * c1[2] + mi * (c1[1] - c1[3]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 160.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Anticontrol of Hopf Bifurcation
	Anticontrol of Hopf Bifurcation and Control of Chaos for a Finance System through Washout Filters with Time Delay
	Huitao Zhao, Mengxia Lu, and Junmei Zuo 3 April 2014
***************************************************************************/

int	DoAnticontrolHopf(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2] + c1[0] * (c1[1] - a);
	cn[1] = 1.0 - b * c1[1] - c1[0] * c1[0];
	cn[2] = -c1[0] - c * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Antimonotonicity, Crisis and Multiple Attractors in a Simple Memristive Circuit
	Christos K. Volos, Akif Akgul, Viet-Thanh Pham and Murilo S. Baptista 30 June 2017
	Received directly by the last author and http://aura.abdn.ac.uk/handle/2164/10685
***************************************************************************/

int	DoAntimonotonicityCrisisMultipleAttractors(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, h;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    h = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[1];
	cn[1] = -c1[2];
	cn[2] = -c1[0] - b * c1[2] + a * exp(-c1[3]) * sinh(c1[1]);
	cn[3] = h * (-d * c1[3] + c * exp(-c1[3]) * cosh(c1[1]) - c);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Antinoise Performances of Improved Tent Chaos-based Phase Modulation Radar Signal Images
	Shaobin Xie, Zishu He and Jichun Pan June 05, 2012 
***************************************************************************/

int	DoAntinoise(void)

    {
    double	i, c1[3], cn[3], k, m, mu;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    k = param[0];
    mu = param[1];
    m = 4.0 * k - 1.0;
    totpasses = 10;

    cn[0] = c1[0];
    cn[1] = 0.0;
    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	if (c1[0] < -1.0 / 3.0) cn[0] = mu * k * c1[0] + k - 0.5;
	else if (c1[0] < -1.0 / 6.0) cn[0] = mu * k * c1[0] + (k - 1.5) * -1;
	else if (c1[0] < 1.0 / 3.0) cn[0] = mu * k * c1[0] + (k - m + 0.5) * pow(-1, m + 1.0);
	else if (c1[0] < 0.5) cn[0] = mu * k * c1[0] + (-k + 0.5) * (-1);

	cn[0] = (cn[0] > 0.5) ? cn[0] - fabs(c1[0] * mu) : cn[0] + fabs(c1[0] * mu);
	c1[1] = cn[0];
	cn[1] = 0.0;
	cn[2] = sqrt(sqr(2.0 * sin(c1[0])) + sqr(2.0 * cos(c1[1])));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Anti-Synchronisation of a Novel Hyperchaotic System with Parameter Mismatch and External Disturbances (Modified)
	FEI YU, CHUN HUA WANG, YAN HU and JIN WEN YIN 25 January 2012
***************************************************************************/

int	DoAntiSynchronisationNovel(void)

    {
    double	i, c1[8], cn[8], a, b, c, d, k, e = exp(1.0);

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w
    c1[4] = param[10];	// x1
    c1[5] = param[11];	// y1
    c1[6] = param[12];	// z1
    c1[7] = param[13];	// w1

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    k = param[4];
    totpasses = 10;

    InitOscillator(c1, 8);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);						// subtracted a ‘z’
	cn[4] = (a * (c1[1] - c1[0]) - c1[4]) / dt;
	cn[1] = b * c1[0] - c1[2] * c1[0] + c * c1[1] + c1[3];
	cn[5] = (b * c1[0] - c1[2] * c1[0] + c * c1[1] + c1[3] - c1[5]) / dt;
	cn[2] = pow(e, (c1[0] * c1[1])) - d * c1[2];
	cn[6] = (pow(e, (c1[0] * c1[1])) - d * c1[2] - c1[6]) / dt;
	cn[3] = -k * c1[0];	
	cn[7] = (-k * c1[0] - c1[7]) / dt;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 8, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Anti-Synchronisation of Two Chaotic Systems (Modified)
	DYNAMICS OF ANTI-Synchronisation OF TWO CHAOTIC SYSTEMS
	Mitul Islam, Bipul Islam, and Nurul Islam, Marcus Rezende April, 2015
***************************************************************************/

int	DoAntiSynchronisation(void)

    {
    double	i, c1[3], cn[3], alpha, lambda, ColourDivider;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alpha = param[0];
    lambda = param[1];
    ColourDivider = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - c1[2];						// subtracted a ‘z’
	cn[1] = c1[0] - lambda * c1[1] - c1[0] * c1[2] - c1[2];		// subtracted a ‘z’
	cn[2] = -alpha * c1[2] + c1[0] * c1[0] + c1[1] * c1[0];		// put na multiplying ‘x’ (whatever that means)
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / ColourDivider) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Application of a Chaotic Oscillator in an Autonomous Mobile Robot-II
	Esteban Tlelo-Cuautle, Hugo C. Ramos-Lopez, Mauro Sanchez-Sanchez, Ana D. Pano-Azucena, Luis A. Sanchez-Gaspariano, Jose C. Nunez-Perez, Jorge L. Camas-Anzueto, 2014,
***************************************************************************/

int	DoApplicationChaoticOscillatorAutonomousMobileRobot(void)

    {
    double	t, i, c1[3], cn[3], a, b, c, d1, k, alpha, s, h, p, q, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d1 = param[3];
    k = param[4];
    alpha = param[5];
    s = param[6];
    h = param[7];
    p = param[8];
    q = param[9];
    i = 0.9;
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	if (c1[0] > q * h + alpha) 
	    f = (2 * q + 1) * k; 
	else if (c1[0] < (-p * h - alpha)) 
	    f = -(2 * p + 1) * k; 
	else
	    f = (fabs(c1[0] - i * h) <= alpha && i >= -p && i <= q) ? k / alpha / (c1[0] - i * h) + 2 * k * i : (2 * i + 1) * k;
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = -a * c1[0] - b * c1[1] - c * c1[2] + d1 * f;		// put na multiplying ‘x’ (whatever that means)
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 2.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Application of the Silnikov Theorem
	The Related Extension and Application of the Silnikov Theorem
	Baoying Chen 1 February 2013
***************************************************************************/

int	DoApplicationSilnikov(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    a = param[0];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[1] + c1[2] * c1[2] + a * c1[0] * (c1[0] * c1[0] + c1[1] * c1[1]);
	cn[1] = c1[0] + a * c1[1] * (c1[0] * c1[0] + c1[1] * c1[1]);
	cn[2] = 4.0 * c1[2] - c1[2] * (c1[0] * c1[0] + c1[1] * c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Approximate Prediction-Based Control Method for Nonlinear Oscillatory Systems with Applications to Chaotic Systems
	Thiago P. Chagas,1 Pierre-Alexandre Bliman,2,3 and Karl H. Kienitz4 1 March 2018
	https://www.hindawi.com/journals/jcse/2018/3298286/
***************************************************************************/

int	DoApproximatePredictionBasedControlMethod(void)

    {
    double	i, c1[3], cn[3], a, n, w;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    n = param[1];
    w = param[2];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = a * sin(w * i) - n * (c1[0] * c1[0] - 1) * c1[1] - c1[0];
	cn[2] = sqrt(sqr(sin(c1[0])) + sqr(cos(c1[1])));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Are Perpetual Points Sufficient for Locating Hidden Attractors? - B
	Fahimeh Nazarimehr, Batool Saedi, Sajad Jafari and J. C. Sprott November 13, 2016
	https://www.researchgate.net/publication/312029501_Are_Perpetual_Points_Sufficient_for_Locating_Hidden_Attractors
***************************************************************************/

int	DoArePerpetualPointsSufficient(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[0] + c1[1] * c1[2];
	cn[2] = -c1[1] - 12.0 * c1[2] + c1[0] * c1[0] + 9.0 * c1[0] * c1[2] - 1.0;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Arneodo Chaotic Attractor Images
***************************************************************************/

int	DoArneodo(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = -a * c1[0] - b * c1[1] - c1[2] + c * c1[0] * c1[0] * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Artificial Neural Network Chaotic Attractor Images
	New Chemical Oscillator
***************************************************************************/

int	DoArtificialNeural(void)

    {
    double	i, c1[3], cn[3], k, s, d, m;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    k = param[0];
    s = param[1];
    d = param[2];
    m = param[3];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = m * (k + c1[2]) - c1[0] - c1[0] * c1[1] * c1[1];
	cn[1] = (c1[0] + c1[0] * c1[1] * c1[1] - c1[1]) / s;
	cn[2] = (c1[1] - c1[2]) / d;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Asymmetric Double Strange Attractors in a Simple Autonomous Jerk Circuit
	G. H. Kom, J. Kengne, J. R. Mboupda Pone, G. Kenne and A. B. Tiedeu 8 February 2018
	https://www.hindawi.com/journals/complexity/2018/4658785/
***************************************************************************/

int	DoAsymmetricDoubleStrangeAttractors(void)

    {
    double	i, c1[3], cn[3], epsilon, mu, ro, a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    epsilon = param[0];
    mu = param[1];
    ro = param[2];
    a = param[3];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = a * c1[2];
	cn[2] = -ro * c1[0] - mu * c1[2] - epsilon * (-1.0 + exp(c1[1]));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Asymmetry Coefcients as Indicators of Chaos - Hyperchaotic Qi System
	P. Waz and D. Bielinska-Waz October 31, 2012
	https://www.researchgate.net/publication/271015211
***************************************************************************/

int	DoAsymmetryCoefcientsIndicatorsChaos(void)

    {
    double	i, c1[4], cn[4], a, c, d, ee, f, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    c = param[1];
    d = param[2];
    ee = param[3];
    f = param[4];
    g = param[5];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[1] * c1[2];
	cn[1] = g * (c1[0] + c1[1]) - c1[0] * c1[2];
	cn[2] = -c * c1[2] - ee * c1[3] + c1[0] * c1[1];
	cn[3] = -d * c1[3] + f * c1[2] + c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Attractor Embedded in the Atmosphere
	EDWARD N. LORENZ 28 February 2006
***************************************************************************/

int	DoAttractorAtmosphere(void)

    {
    double	i, c1[3], cn[3], a, b, f, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    f = param[2];
    g = param[3];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[1] * c1[1] - c1[2] * c1[2] - a * c1[0] + a * f;
	cn[1] = c1[0] * c1[1] - b * c1[0] * c1[2] - c1[1] + g;
	cn[2] = b * c1[0] * c1[1] + c1[0] * c1[2] - c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Autonomous Silva-Young Type Chaotic Oscillator with Flat Power Spectrum
	E. Tamaseviciute, G. Mykolaitis and  A. Tamasevicius & Marcus Rezende 2011
***************************************************************************/

int	DoAutonomousSilvaYoung(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, k, mu, e, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    k = param[4];
    mu = param[5];
    e = param[6];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	f = (c1[0] < -0.5 || c1[0] > 0.5) ? 0.5 : c1[0] - c1[3];	// this 'w' is mine contribution
	cn[0] = c1[1];
	cn[1] = k * f - c1[0] - b * c1[1] + c * c1[3] + c1[3];		// this 'w' also is my idea
	cn[2] = c1[3] / e;
	cn[3] = (a * c1[1] - c1[2] - d * c1[3]) / mu;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Bands and branes-1 Images
	Chaos and non-linear Dynamics -Book
	Robert C. Hilborn
***************************************************************************/

int	DoBandsAndBranes(void)

    {
    double	i, c1[4], cn[4];

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // px
    c1[3] = param[13];    // py

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2];
	cn[1] = c1[3];
	cn[2] = -c1[0] - 2.0 * c1[0] * c1[1];
	cn[3] = -c1[1] - c1[0] * c1[0] - c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Basic Dynamical Analyses and Electronic Circuit Implementation of a new 3D Chaotic System
	Akin Ozdemir, Akif Akgul, Yilmaz Uyaroglu and Ihsan Pehlivan October 2016
	https://www.researchgate.net/publication/309209139
***************************************************************************/

int	DoBasicDynamicalAnalyses(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[0] - c1[1] * c1[2];
	cn[1] = c1[0] - c1[1] - c1[0] * c1[2];
	cn[2] = c1[0] * c1[1] + a;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Basins of Attraction for Chimera States
	Erik A Martens, Mark J Panaggio and Daniel M Abrams 18 February 2016
***************************************************************************/

int	DoBasinsAttractionChimeraStates(void)

    {
    double	i, c1[3], cn[3], mu, ni, beta;

    c1[0] = param[10];    // r01
    c1[1] = param[11];    // r02
    c1[2] = param[12];    // psi

    mu = param[0];
    ni = param[1];
    beta = param[2];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = -100.0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = (1.0 - c1[0] * c1[0]) / 2.0 * (mu * c1[0] * sin(beta) + ni * c1[1] * sin(beta + c1[2]));
	cn[1] = (1.0 - c1[1] * c1[1]) / 2.0 * (mu * c1[1] * sin(beta) + ni * c1[0] * sin(beta - c1[2]));
	cn[2] = (1.0 + c1[1] * c1[1]) / 2.0 / c1[1] * (mu * c1[1] * cos(beta) + ni * c1[0] * cos(beta + c1[2])) 
	      - (1.0 + c1[0] * c1[0]) / 2.0 / c1[0] * (mu * c1[0] * cos(beta) + ni * c1[1] * cos(beta - c1[2]));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Baskets Hyper-Chaotic Attractor in 4 Dimensions Images
	Analysis and Numerical Simulation of a Novel Four-dimensional 
	Dynamic Evolution System with Multilayer Chaotic Attractors Minggang Wan
***************************************************************************/

int	DoBaskets4D(void)

    {
    double	i, c[4], cn[4], a1, a2, a3, a4, b1, b2, b3, b4, c1, c2, c3, d1, d2;

    c[0] = param[10];	// x
    c[1] = param[11];	// y
    c[2] = param[12];	// z
    c[3] = param[13];	// w

    b2 = 0.082; b3 = 0.07; b4 = 0.07;

    a1 = param[0];
    a2 = param[1];
    a3 = param[2];
    a4 = param[3];
    b1 = param[4];
    c1 = param[5];
    c2 = param[6];
    c3 = param[7];
    d1 = param[8];
    d2 = param[9];
    totpasses = 10;

    InitOscillator(c, 4);						// pass in number of dimensions
    for (i = 1; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a1 * c[0] - a2 * c[0] * c[0] - a3 * (c[1] + c[2]) - a4 * c[3];
	cn[1] = -b1 * c[1] - b2 * c[2] + b3 * c[0] - b4 * c[0] * (c[0] - c[2]);
	cn[2] = c1 * (c[2] - c2) * (c[0] - c3);
	cn[3] = d1 * c[0] - d2 * c[3];
	if (DisplayOscillator(c, cn, dt, ((DWORD)(i / 40.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Basins of Attraction Plasticity of a Strange Attractor with a Swirling Scroll
	Safieddine Bouali 31 Jul 2015
***************************************************************************/

int	DoBasinsAttractionPlasticity(void)

    {
    double	i, c1[3], cn[3], alpha, beta, fi, mu, eta, s;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alpha = param[0];
    beta = param[1];
    fi = param[2];
    mu = param[3];
    eta = param[4];
    s = param[5];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 1; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = alpha * c1[0] * (c1[1] - 1.0) + beta * c1[1] * c1[2];
	cn[1] = fi * (1.0 - c1[0] * c1[0]) * c1[1] + mu * c1[0] * c1[2];
	cn[2] = eta * c1[0] * c1[1] - s * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 40.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Belyakov Homoclinic Bifurcations in a Tritrophic Food Chain Model
	YU. A. KUZNETSOV, O. DE FEO, AND S. RINALDII 2001
***************************************************************************/

int	DoBelyakov(void)

    {
    double	i, c[3], cn[3], a1, a2, b1, b2, d1, d2, r, k;

    c[0] = param[10];	// x
    c[1] = param[11];	// y
    c[2] = param[12];	// z

    a1 = param[0];
    a2 = param[1];
    b1 = param[2];
    b2 = param[3];
    d1 = param[4];
    d2 = param[5];
    r = param[6];
    k = param[7];
    totpasses = 10;

    InitOscillator(c, 3);						// pass in number of dimensions
    for (i = 1; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c[0] * (r * (1.0 - c[0] / k) - a1 * c[1] / (1.0 + b1 * c[0]));
	cn[1] = c[1] * (a1 * c[0] / (1.0 + b1 * c[0]) - a2 * c[2] / (1.0 + b2 * c[1]) - d1);
	cn[2] = c[2] * (a2 * c[1] / (1.0 + b2 * c[1]) - d2);
	if (DisplayOscillator(c, cn, dt, ((DWORD)(i / 40.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Bifurcation Analysis and Chaos Control of a Fractional Order Portal Frame with Nonideal Loading Using Adaptive Sliding Mode Control
	Karthikeyan Rajagopal, Anitha Karthikeyan and Prakash Duraisamy 20 July 2017
***************************************************************************/

int	DoBifurcationAnalysis(int type)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = cn[0] = param[10];	// x
    c1[1] = cn[1] = param[11];	// y
    c1[2] = cn[2] = param[12];	// z
    c1[3] = cn[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 1; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -a * c1[1] + b * c1[0] - c * c1[0] * c1[0] * c1[0] + d * cn[3] * sin(c1[2]) + d * c1[3] * c1[3] * ((type) ? 1.0 : c1[3]) * cos(c1[2]);
	cn[2] = c1[3];
	cn[3] = 0.05 * cn[1] * sin(c1[2]) - 100.0 * c1[3] + 200.0;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 40.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

int	DoBifurcationAnalysisI(void)
    {
    return DoBifurcationAnalysis(0);
    }
int	DoBifurcationAnalysisII(void)
    {
    return DoBifurcationAnalysis(1);
    }

/**************************************************************************
	Bifurcation and Chaos in Integer and Fractional Order Two Degree of Freedom Shape Memory Alloy Oscillators
	Karthikeyan Rajagopal, Anitha Karthikeyan, Prakash Duraisamy and Riessom Weldegiorgis 4 January 2018
***************************************************************************/

int	DoBifurcationAndChaos(void)

    {
    double  i, c1[4], cn[4], a, b, c, d;
    double  w1, w2, e1, e2, e3, f1, f2, f3, l1, l2, l3, v21, v32, mu, d1, d2, a21, a32, t1, t2, t3;


    c1[0] = cn[0] = param[10];	// x
    c1[1] = cn[1] = param[11];	// y
    c1[2] = cn[2] = param[12];	// z
    c1[3] = cn[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    w1 = param[4];
    w2 = param[5];
    e1 = param[6];
    e2 = param[7];
    e3 = param[8];
    f1 = param[9];

    f2 = 1300.0; f3 = 1300.0; l1 = 470000.0; l2 = 4700000.0; l3 = 470000.0;
    v21 = 1.0; v32 = 1.0; mu = 1.0; d1 = 0.06; d2 = 0.0; a21 = 1.0; a32 = 1.0; t1 = 1.5; t2 = 3.5; t3 = 1.5;

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 1; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = d1 * sin(w1 * i) - (e1 + e2 * mu) * c1[1] + e2 * v21 * mu * c1[2] - ((t1 - 1.0) + v21 * v21 * mu * (t2 - 1)) * c1[0]
	    + v21 * v21 * mu * (t2 - 1) * c1[2] + f1 * c1[0] * c1[0] * c1[0] - l1 * c1[0] * c1[0] * c1[0] * c1[0] * c1[0] 
	    - f2 * v21 * v21 * mu * (c1[2] - c1[0]) * (c1[2] - c1[0]) * (c1[2] - c1[0]) 
	    + l2 * mu * (c1[2] - c1[0]) * (c1[2] - c1[0]) *(c1[2] - c1[0]) * (c1[2] - c1[0]) * (c1[2] - c1[0]);
	cn[2] = c1[3];
	cn[3] = a21 * a21 * d2 * sin(w2 * i) - e2 * v21 * c1[1] - (e2 * a21 + e3 * v21 * a32) * c1[3] + v21 * v21 * (t2 - 1) * c1[0] 
	    - (v21 * v21 * (t2 - 1) + v21 * v21 * v32 * v32 * (t3 - 1.0)) * c1[2] + f2 * v21 * v21 * (c1[2] - c1[0]) * (c1[2] - c1[0]) * (c1[2] - c1[0]) 
	    - l2 * v21 * v21 * (c1[2] - c1[0]) * (c1[2] - c1[0]) *(c1[2] - c1[0]) * (c1[2] - c1[0]) * (c1[2] - c1[0]) 
	    - f3 * v21 * v21 * v32 * v32 * v32 * c1[2] * c1[2] * c1[2] - l3 * v21 * v21 * v32 * v32 * c1[2] * c1[2] * c1[2] * c1[2] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 40.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Bifurcation and Chaos in Time Delayed Fractional Order Chaotic Memfractor Oscillator and its Sliding Mode Synchronisation with  Uncertainties
	Karthikeyan Rajagopal, Anitha Karthikeyan and Ashokkumar Srinivasan 26 June 2017 Received directly from the authors
***************************************************************************/

int	DoBifurcationAndChaosTimeDelayedFractionalOrder(void)

    {
    double  i, c1[5], cn[5], a1, a2, a3, a4, a5, a6, a7, a8, a9;


    c1[0] = cn[0] = param[10];	// x
    c1[1] = cn[1] = param[11];	// y
    c1[2] = cn[2] = param[12];	// z
    c1[3] = cn[3] = param[13];	// u
    c1[4] = cn[4] = param[14];	// v

    a1 = param[0];
    a2 = param[1];
    a3 = param[2];
    a4 = param[3];
    a5 = param[4];
    a6 = param[5];
    a7 = param[6];
    a8 = param[7];
    a9 = param[8];
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 1; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2];
	cn[1] = c1[3];
	cn[2] = a1 * c1[2] + a2 * c1[0] * c1[2] + a3 * c1[4];
	cn[3] = a4 * c1[4] + a5 * c1[3] * (1.0 - c1[1]);
	cn[4] = a6 * c1[3] + a7 * c1[0] * c1[2] + a8 * c1[2] + a9 * c1[4];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 60.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Bifurcation Analysis and Chaotic Behaviors of Fractional-Order Singular Biological Systems-I
	Komeil Nosrati and Christos Volos October 2017
	Nonlinear Dynamical Systems with Self-Excited and Hidden Attractors - Springer Verlag – a chapter of this book that Volos liberated for me.
***************************************************************************/

int	DoBifurcationAnalysisChaoticBehaviorsI(void)

    {
    double	i, c1[3], cn[3], r, k, sigma, a, p, m, h, beta, w, c;
    int		trig;

    c1[0] = param[10];	    // x
    c1[1] = param[11];	    // y
    c1[2] = param[12];	    // z

    trig = (int)param[0];
    r = param[1];
    k = param[2];
    sigma = param[3];
    a = param[4];
    p = param[5];
    m = param[6];
    beta = param[7];
    w = param[8];
    c = param[9];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	switch (trig)							// Marcus: paper don’t show this function but says it is a function of ‘t’ . So invented mine 
	    {
	    case 0:
		h = sin(w * i);
		break;
	    case 1:
		h = cos(w * i);
		break;
	    case 2:
		h = tan(w * i);
		break;
	    case 3:
		h = log(fabs(c1[0]));
		break;
	    case 4:
		h = log(fabs(c1[1]));
		break;
	    case 5:
		h = log(fabs(c1[2]));
		break;
	    case 6:
		h = fabs(c1[0]) / c1[0];
		break;
	    case 7:
		h = sinh(w * i);
		break;
	    case 8:
		h = cosh(w * i);
		break;
	    case 9:
		h = tanh(w * i);
		break;
	    default:
		h = sin(w * i);
		break;
	    }
	cn[0] = r * c1[0] * (1.0 - c1[0] / k) - beta * c1[0] * c1[1] / (1.0 + sigma * c1[0]);
	cn[1] = beta * c1[0] * c1[1] / (1.0 + sigma * c1[0]) - a * c1[1] - h;
	cn[2] = c1[2] * (p * c1[1] - c) - m;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Bifurcation Analysis and Chaotic Behaviors of Fractional-Order Singular Biological Systems-II
	Komeil Nosrati and Christos Volos 2018
	https://www.researchgate.net/requests/r41338629
***************************************************************************/

int	DoBifurcationAnalysisChaoticBehaviorsII(void)

    {
    double	i, c1[3], cn[3], p;

    c1[0] = param[10];	    // x
    c1[1] = param[11];	    // y
    c1[2] = 1.0;	    // z

    p = param[0];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[1] + c1[0] * (p - log(c1[0] * c1[0] + c1[1] * c1[1]));	// original formula xn = -y + x * (p - (x * x + y * y))
	cn[1] = c1[0] + c1[1] * (p + sin(c1[0] * c1[0] - c1[1] * c1[1]));	// original formula  yn = x + x * (p - (x * x + y * y))
	cn[2] = sin(c1[0]) + cos(c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Bifurcation Behavior and PD Control Mechanism of a Fractional Delayed Genetic Regulatory Model
	Peiluan Li, Rong Gao, Changjin Xu, Shabir Ahmad, Ying Li, Ali Akgul 7 February 2023
	https://www.researchgate.net/publication/368333686....https://doi.org/10.1016/j.chaos.2023.113219
***************************************************************************/

int	DoBifurcationBehaviorPDControlMechanism(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	    // x
    c1[1] = param[11];	    // y
    c1[2] = 1.0;	    // z
    cn[0] = 1.0;
    cn[1] = 1.0;

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 11.55 * sqr(cn[0]) / (sqr(cn[0]) + 10 * (1 + cn[1] / 0.2)) - c1[0] + 0.4;
	cn[1] = 0.3 * sqr(cn[0]) / (sqr(cn[0]) + 10 * (1 + cn[1] / 1)) - 0.2 * c1[1];
	cn[2] = sin(c1[0]) + cos(c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Bifurcations of a New Fractional-Order System with a One-Scroll Chaotic Attractor
	Xiaojun Liu, Ling Hong, Lixin Yang and Dafeng Tang 1 January 2019
	https://www.hindawi.com/journals/ddns/2019/8341514/
***************************************************************************/

int	DoBifurcationsNewFractionalOrderSystem(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	    // x
    c1[1] = param[11];	    // y
    c1[2] = param[12];	    // z

    a = param[0];
    b = param[1];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] - c1[1];
	cn[1] = c1[0] - c1[2] - b * c1[1];
	cn[2] = a * c1[0] + 4 * c1[2] * (c1[1] - 2);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Bifurcation Phenomena and Chaotic Attractors in a Six-Dimensional Nonlinear System
	T. Sutani, T. Czaszejko, A. Nafalski 1 JUNE 1998
***************************************************************************/

int	DoBifurcationPhenomena(void)

    {
    double	i, c1[6], cn[6], a0, a00, a1i, a10, a2i, a20, b1i, b00, b10, f;
    double	k1, k2, k3, k4, k5, k6, k7;

    c1[0] = param[10];	    // x1
    c1[1] = param[11];	    // x2
    c1[2] = param[12];	    // x3
    c1[3] = param[13];	    // x4
    c1[4] = param[14];	    // x5
    c1[5] = param[15];	    // x6

    a0 = 0.0; a1i = 0.0; a10 = 0.0; a2i = 5.0e-6; a20 = 6.0e-6; f = 12.5; a00 = 0.0;

    k1 = param[0];
    k2 = param[1];
    k3 = param[2];
    k4 = param[3];
    k5 = param[4];
    k6 = param[5];
    k7 = param[6];
    b1i = param[7];
    b00 = param[8];
    b10 = param[9];
    totpasses = 10;

    InitOscillator(c1, 6);						// pass in number of dimensions
    for (i = 1; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -k1 * c1[0] - k2 * c1[1] + f * sin(i);
	cn[1] = k3 * c1[0] - a1i * c1[2] - b1i * c1[2] * c1[2] * c1[2] - a2i * c1[3];
	cn[2] = k4 * (c1[1] + c1[5]);
	cn[3] = k5 * (c1[1] - c1[5]);
	cn[4] = k6 * c1[5];
	cn[5] = a20 * c1[3] - a10 * c1[2] - b1i * c1[2] - a00 * c1[4] - b00 * c1[4] * c1[4] * c1[4] - k7 * c1[5];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 40.0) % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Bifurcations and Synchronisation of the Fractional-Order Bloch System
	Xiaojun Liu, Ling Hong, Honggang Dang and Lixin Yang 22 March 2017
***************************************************************************/

int	DoBifurcationSynchronisation(void)

    {
    double	i, c1[3], cn[3], d, g, c, g1, g2;

    c1[0] = cn[0] = param[10];	// x
    c1[1] = cn[1] = param[11];	// y
    c1[2] = cn[2] = param[12];	// z

    d = param[0];
    g = param[1];
    c = param[2];
    g1 = param[3];
    g2 = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 1; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = d * c1[0] + g * c1[2] * (c1[0] * sin(c) - c1[1] * cos(c)) - c1[0] / g2;
	cn[1] = -d * c1[0] - c1[2] + g * c1[2] * (c1[0] * cos(c) + c1[1] * sin(c)) - c1[1] / g2;
	cn[2] = c1[1] - g * sin(c) * (c1[0] * c1[0]) - (c1[2] - 1) / g1;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 40.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Birds Images
	Chaos Synchronisation of A New Fractional-Order System with Unknown Parameters
	Hong-Gang Dang 2012
***************************************************************************/

int	DoBirds(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 1; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[3];
	cn[1] = c1[0] * c1[2] - c1[1];
	cn[2] = b - c1[0] * c1[1] - c * c1[2];
	cn[3] = d * c1[3] - c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 40.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Birth of One-to-Four-Wing Chaotic Attractors in a Class of Simplest three-dimensional Continuous Memristive Systems
	Shijian Cang, Aiguo Wu, Zenghui Wang, Wei Xue and Zengqiang Chen 14 October 2015
	https://www.researchgate.net/profile/Shijian_Cang/publication/283451126_Birth_of_one-to-four-wing_chaotic_attractors_in_a_class_of_simplest_three-dimensional_continuous_memristive_systems/links/563ae2a408ae405111a596d7.pdf
***************************************************************************/

int	DoBirth1to4WingChaoticAttractors(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 1; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[1];
	cn[1] = -b * c1[0] - 9 * (c1[2] * c1[2] - c * c) * c1[1];
	cn[2] = (c1[1] * c1[1] - 1) * (c1[1] * c1[1] - 4) * (c1[1] * c1[1] - 9) * c1[2] - d * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 40.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Bistable Hidden Attractors in a Novel Chaotic System with Hyperbolic Sine Equilibrium
	Viet-Thanh Pham, Christos Volos, Sifeu Takougang Kingni, Tomasz Kapitaniak, Sajad Jafari 8 July 2017
***************************************************************************/

int	DoBistableHidden(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, cy, shcy;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 1; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cy = c * c1[1];
	shcy = (exp(cy) - exp(-cy)) / (exp(cy) + exp(-cy));
	cn[0] = -c1[2];
	cn[1] = c1[0] * c1[2] * c1[2] + a * fabs(c1[2]) / c1[2];
	cn[2] = c1[0] - b * shcy + c1[2] * (d * c1[1] * c1[1] - c1[2] * c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 40.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Bistability in a Fifth-Order Voltage-Controlled Memristor-Based Chua’s Chaotic Circuit
	Lin Yiy, Liu Wen-Bo aand Shen Qian 29 August 2018
	Sent to ManpWIN by Shen Qian through https://www.researchgate.net/requests/r78713435
***************************************************************************/

int	DoBistabilityFifthOrderVoltageControlledMemristorBasedChua(void)

    {
    double	i, c1[5], cn[5], a, b, c, d, e, f, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[11];	// u
    c1[4] = param[12];	// v

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 1; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[0] - b * c1[1];
	cn[1] = c * c1[1] - g * c * c1[0] * c1[0] * c1[1] + c1[3];
	cn[2] = (c1[4] - c1[3]) * d;
	cn[3] = (c1[2] - c1[1] - c1[3]) * e;
	cn[4] = -f * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 40.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Bistability in a Hyperchaotic System with a Line Equilibrium Images
	Chunbiao Li, J. C. Sprott, and Wesley Thioc Received October 26, 2013
***************************************************************************/

int	DoBistability(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - c1[2];
	cn[1] = c1[0] + a * c1[1];
	cn[2] = b + c1[2] * (c1[0] - c);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    return -1;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Bistability in a Hyperchaotic System with a Line Equilibrium
	Chunbiao Li, , J. C. Sprott and Wesley Thioc October 26, 2013
***************************************************************************/

int	DoBistabilityHyperchaotic(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - c1[0] * c1[2] - c1[1] * c1[2] + c1[3];
	cn[1] = a * c1[0] * c1[2];
	cn[2] = c1[1] * c1[1] - b * c1[2] * c1[2];
	cn[3] = -c * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 2) < 0)
	    return -1;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Bi-Stability in an Improved Memristor-Based Third-Order Wien-Bridge Oscillator
	Han Bao, Ning Wang, Huagan Wu, Zhe Song & Bocheng Bao 28 Jan 2018
	Received from Research Gate
***************************************************************************/

int	DoBistabilityImprovedMemristorBased3rdOrderWienBridgeOscillator(void)

    {
    double	i, c1[3], cn[3], a, b, c, m, k, mu, w, hy;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    m = param[3];
    k = param[4];
    mu = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	w = mu * sqr(c1[0] - m * c1[1]) - 1;
	hy = 0.5 * k * (fabs(c1[1] + 1) - fabs(c1[1] - 1));
	cn[0] = -a * c1[1];
	cn[1] = hy - c1[1] - c1[2] - b * w * c1[1];
	cn[2] = c * (hy - c1[1] - c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 2) < 0)
	    return -1;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Bloch Equations Under Chaos Images
	Chaos Control in the Nonlinear Bloch Equations using Recursive Active Control 
	U. E. Vincent, J. A. Laoyea, R. K. Odunaike 
	African Journal Of Mathematical Physics Volume 7 No 1(2009)31-38
***************************************************************************/

int	DoBloch(void)

    {
    double	i, c1[3], cn[3], d, l, p, t1, t2;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    d = -0.4 * PI;

    l = param[0];
    p = param[1];
    t1 = param[2];
    t2 = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = d * c1[1] + l * c1[2] * (c1[0] * sin(p) - c1[1] * cos(p)) - c1[0] / t2;
	cn[1] = -d * c1[0] - c1[2] + l * c1[2] * (c1[0] * cos(p) + c1[1] * sin(p)) - c1[1] / t2;
	cn[2] = c1[1] - l * sin(p) * (c1[0] * c1[0] + c1[1] * c1[1]) - (c1[2] - 1.0) / t1;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    return -1;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Blue Sky Catastrophe Chaotic Images  
	Gavrilov Shilnicov -2000/2001
***************************************************************************/

int	DoBlueSky(void)

    {
    double	i, c1[3], cn[3], e, b, m;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    b = param[0];
    m = param[1];
    e = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] * (2.0 + m - b * (c1[0] * c1[0] + c1[1] * c1[1])) + c1[2] * c1[2] + c1[1] * c1[1] + 2.0 * c1[1];
	cn[1] = -(c1[2] * c1[2] * c1[2]) - (1.0 + c1[1]) * (c1[2] * c1[2] + c1[1] * c1[1] + 2 * c1[1]) - 4.0 * c1[0] + m * c1[1];
	cn[2] = (1.0 + c1[1]) * c1[2] * c1[2] + c1[0] * c1[0] - e;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    return -1;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Bluetooth Based Chaos Synchronisation Using Particle Swarm Optimisation and Its Applications to Image Encryption
	Her-Terng Yau,* Tzu-Hsiang Hung, and Chia-Chun Hsieh 2012 Jun 1
	https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3435984/
***************************************************************************/

int	DoBluetoothBasedChaosSynchronisation(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[1];
    k = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = -1.2 * c1[0] - c1[1] - 0.6 * c1[2] + 2 * fabs(c1[0]) / c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    return -1;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Boa Hyper-Chaotic Attractor in 4 Dimensions Images
***************************************************************************/

int	DoBoa4D(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    k = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[3];
	cn[1] = c * c1[1] - c1[0] * c1[2];
	cn[2] = c1[0] * c1[1] - b * c1[2];
	cn[3] = k * c1[0] + d * c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Boldrighini-Francheschini Chaotic Oscillator Images  
	Book Fractals and Chaos An Illustrated Course by Paul S. Addison
***************************************************************************/

int	DoBoldrighini(void)

    {
    double	i, c1[5], cn[5], re;

    c1[0] = param[10];	// x1
    c1[1] = param[11];	// x2
    c1[2] = param[12];	// x3
    c1[3] = param[13];	// x4
    c1[4] = param[14];	// x5
    re = param[0];

    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i += dt)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -2.0 * c1[0] + 4.0 * c1[1] * c1[2] + 4.0 * c1[3] * c1[4];
	cn[1] = -9.0 * c1[1] + 3.0 * c1[0] * c1[2];
	cn[2] = -5.0 * c1[2] - 7.0 * c1[0] * c1[1] + re;
	cn[3] = -5.0 * c1[3] - c1[0] * c1[4];
	cn[4] = -c1[4] - 2.0 * c1[0] * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / dt) % threshold), i, 5, 0) < 0)
	    return -1;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Bonhoffer-van der Pol Chaotic Oscillator Images  
	Comparison of backstepping and modified active control in projective 
	Synchronisation of chaos in an extended Bonhoffer-van der Pol oscillator
	K S OJO1, A N NJAH1,  S T OGUNJO May 2013
***************************************************************************/

int	DoBonhoffer(void)

    {
    double	i, c1[3], cn[3], a, b, d, k, t1;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    d = param[2];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);    
	k = b * c1[0];
	t1 = (exp(k) - exp(-k)) / (exp(k) + exp(-k));
	cn[0] = -c1[2] + a * c1[0] + t1;
	cn[1] = c1[2] - d * c1[1];
	cn[2] = c1[0] - c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    return -1;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Bose-Einstein Condensate Images  
	Synchronisation and Stabilization of Chaotic Dynamics in a 
	Quasi-1D Bose-Einstein Condensate 
	B. A. Idowu, U. E. Vincent2,3 18 November 2013
***************************************************************************/

int	DoBoseEinstein(void)

    {
    double	i, c1[4], cn[4], i0, mu, ni, g, u1, u2;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    i0 = param[0];
    mu = param[1];
    ni = param[2];
    g = param[3];
    u1 = param[4];
    u2 = param[5];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = 0.25 * ni * ni * c1[0] + g * c1[0] * c1[0] * c1[0] + i0 * pow(cos(i), 2) * c1[0] - mu * ni * c1[1];
	cn[2] = c1[3] + u1;
	cn[3] = 0.25 * ni * ni * c1[2] + g * c1[2] * c1[2] * c1[2] + i0 * pow(cos(i), 2) * c1[2] - mu * ni * c1[3] + u2;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    return -1;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Bouali Chaotic Attractor Type 2
***************************************************************************/

int	DoBouali2(void)

    {
    double	i, c1[3], cn[3], s, alpha;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alpha = param[0];
    s = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] * (4.0 - c1[1]) + alpha * c1[2];
	cn[1] = -c1[1] * (1.0 - c1[0] * c1[0]);
	cn[2] = -c1[0] * (1.5 - s * c1[2]) - 0.05 * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Bouali Chaotic Attractor Type 3 
	Apud Jugen Meier
	Bouali - Meier
	https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
***************************************************************************/

int	DoBouali3(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] * (1 - c1[1]) - b * c1[2];
	cn[1] = -c * c1[1] * (1 - c1[0] * c1[0]);
	cn[2] = d * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Bouali-Safieddine Chaotic Attractor Images
	Feedback loop applied to Van der Pol equation to an economic model of circles - 1997
***************************************************************************/

int	DoBoualiSafieddine(void)

    {
    double	i, c1[3], cn[3], k, m, b, p, q, s;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    b = param[0];
    p = param[1];
    q = param[2];
    s = param[3];
    k = param[4];
    m = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = k * c1[1] + m * c1[0] * (b - c1[1] * c1[1]);
	cn[1] = -c1[0] + s * c1[2];
	cn[2] = p * c1[0] - q * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 60.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Braid Chaotic Attractor Images
	From an original idea of:
	Comprehensive Chaotic Description Heartbeat Dynamics 
	Using Scale Index and Lyapunov Exponent 
	Sohrab Behnia, Javid Ziaei, Marjan Ghiassi, and Mohammad Yahyavi 
	June 2013 Istanbul, Turkey
***************************************************************************/

int	DoBraid(void)

    {
    double	i, c1[3], cn[3], a, alpha, v1, v2, d, e, w = PI - 0.000001;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    alpha = param[1];
    v1 = param[2];
    v2 = param[3];
    e = param[4];
    d = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = a * sin(w * i) - alpha * (c1[0] - v1) * (c1[0] - v2) * c1[1] - (c1[0] * (c1[0] + e) * (c1[0] + d)) / e / d;
	cn[2] = fabs(c1[1]) / sin(c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 60.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Brusselator Chaotic Attractor Images
	Marcus 2014
***************************************************************************/

int	DoBrusselator(void)

    {
    double	i, c1[3], cn[3], a, azao, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    azao  = param[1];
    b = param[2];
    c = param[3];
    d = param[4];
    totpasses = 10;

    c1[2] *= c;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = sqrt(fabs(c1[0])) * c1[1] - (b + 1.0) * c1[0] + a + azao * cos(c * c1[2]);
	cn[1] = -sqrt(fabs(c1[0])) * c1[1] + sin(b * c1[2]);
	cn[2] = sin(c * c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 60.0) % threshold), i, 3, 1) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Burke-Shaw Chaotic Attractor Images
***************************************************************************/

int	DoBurkeShaw(void)

    {
    double	i, c1[3], cn[3], s, V;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    s = param[0];
    V = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -s * (c1[0] + c1[1]);
	cn[1] = -c1[1] - s * c1[0] * c1[2];
	cn[2] = s * c1[0] * c1[1] + V;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Butterfly Chaotic Attractor Images
	Controllable V-Shape Multi-Scroll Butterfly Attractor:
	System and Circuit Implementation
***************************************************************************/

int	DoButterfly(void)

    {
    double	i, c1[3], cn[3], m, d1, d2, s0, s1, gz;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    m = param[0];
    d1 = param[1];
    d2 = param[2];
    s0 = param[3];
    s1 = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	if (c1[2] < s0) gz = 0.0;
	if (c1[2] >= s0 && c1[2] < s1) gz = d1;
	if (c1[2] > s1) gz = d2;

	cn[0] = c1[1] - c1[0];
	cn[1] = fabs(c1[0]) / c1[0] * (1 - m * c1[2] + gz);
	cn[2] = fabs(c1[0]) - 0.5 * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Cai Hyper-Chaotic Attractor in 4 Dimensions Images
***************************************************************************/

int	DoCai4D(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = b * c1[0] + c * c1[1] - c1[0] * c1[2] + c1[3];
	cn[2] = -d * c1[2] + c1[1] * c1[1];
	cn[3] = -e * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	CAMO - Self-Excited and Hidden Chaotic Flows
	Karthikeyan Rajagopal, Fahimeh Nazarimehr, Anitha Karthikeyan, Ashokkumar Srinivasan and Sajad Jafari December 16, 2017
	https://www.researchgate.net/publication/324706135
***************************************************************************/

int	DoCAMOChaoticFlows(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 10 * c1[2] + c1[0] * c1[1];
	cn[1] = a - c1[0] * c1[0] - c1[2] * c1[2];
	cn[2] = -9 * c1[0] + c1[1] * c1[2] - c * c1[3];
	cn[3] = -d * c1[3] - b * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Cardiovascular Applications Images
	Nonlinear Filtering of Oscillatory Measurements in Cardiovascular Applications
	Ranjan Vepa 13 March 2010
	I have no images to check if the initial values lead to a similar objective, 
	because the initial values came from my mind till i get something interesting
	Marcus
***************************************************************************/

int	DoCardiovascular(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 3.0 * c1[0] * c1[0] - c1[0] * c1[0] * c1[0] + c1[1] - c1[2];
	cn[1] = a - 7.0 * c1[0] * c1[0] - c1[1] - c1[3] / 80.0;
	cn[2] = b * (4.0 * (c1[0] + c) - c1[2]);
	cn[3] = d * (-c1[3] + e * (c1[1] - 0.9));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 1) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Mathematical modeling of cardiac dynamic of rhythms Images
	Sandra Regina F. S. M. Gois - sandra@lavi.coppe.ufrj.br 
	Marcelo Amorim Savi - savi@mecanica.ufrj.br
***************************************************************************/

/*
int	DoCardiac6D(void)

    {
    double	i, c1[5], cn[5], a, b;
    double	asa, aav, ahp, wsa1, wsa2, dsa, dav, dhp, esa, eav, ehp, wav1, wav2, whp1, whp2;
    double	ksa_av, kav_hp, tsa_av, tas_hp, rsa, rav, rhp, wsa, wav, whp;

    c1[0] = 0.03;	// x				// these numbers were tried and tried till we get more 'skimmed' images
    c1[1] = -0.1;	// y
    c1[2] = -0.3;	// z
    c1[3] = 0.2;	// w
    c1[4] = 0.05;	// q
    c1[5] = 8.0;	// r

    asa = 3.0; aav = 3.0; ahp = 5.0;
    wsa1 = 0.2; wsa2 = -1.9;
    dsa = 3.0; dav = 3.0; dhp = 3.0;
    esa = 6.0; eav = 3.0; ehp = 7.0;
    wav1 = 0.1; wav2 = -0.1;
    whp1 = 1.0; whp2 = -1.0;
    ksa_av = 5.0; kav_hp = 20.0;
    tsa_av = 0.8; tas_hp = 0.1;
    rsa = 1.0; rav = 1.0; rhp = 20.0;

    wsa =  wav = whp = 2.0 * PI / 60.0;			// all these numbers above are from the original paper.

    asa = param[1];
    aav = param[2];
    ahp = param[3];
    wsa1 = param[4];
    wsa2 = param[5];
    totpasses = 10;

    InitOscillator(c1, 6);						// pass in number of dimensions
    for (i = 0; i < iterations; i += dt)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -asa * c1[1] * (c1[0] - wsa1) * (c1[0] - wsa2) - c1[0] * (c1[0] + dsa) * (c1[0] + esa)
				+ rsa * sin(wsa * i) + ksa_av * (c1[0] - x3t_sa_av) + ksa_hp * (c1[0] - x5t_sa_hp);
	cn[2] = c1[3];
	cn[3] = -aav * c1[3] * (c1[2] - wav1) * (c1[2] - wav2a) - c1[2] * (c1[2] + dav) * (c1[2] + eav)
				+ rav * sin(wav * i) + kav_sa * (c1[2] - x1t_av_sa) + kav_hp * (c1[2] - x5t_av_hp);
	cn[4] = c1[5];
	cn[5] = ahp * c1[5] * (c1[4] - whp1) * (c1[4] - whp2) - c1[4] * (c1[4] + dhp) * (c1[4] + ehp)
				+ rhp * sin(whp * i) + khp_sa * (c1[4] - x1t_hp_sa) + khp_av * (c1[4] - x3t_hp_av);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 6, 0) < 0)
	    break;
	}
    return 0;
    }
*/

/**************************************************************************
	Carlos Hyper-Chaotic Oscillator in 4+1 Dimensions Images
***************************************************************************/

int	DoCarlos5D(void)

    {
    double	i, c1[5], cn[5], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w
    c1[4] = param[14];	// t

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 1; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[2] = a / c1[1] - exp(-i) * c1[2] - sin(i) * c1[0];
	cn[0] = c1[2];
	cn[3] = b / c1[0] - exp(-i) * c1[3] - sin(i) * c1[1];
	cn[1] = c1[3];
//	cn[4] = log(i+1) / 300.0;
	cn[4] = log(i) / 300.0;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Carpet Oscillator: A New Mega-Stable Nonlinear Oscillator with Infinite Islands of Self Excited and Hidden Attractors
	Yanxia Tang, Hamid Reza Abdolmohammadi, Abdul Jalil M. Khalaf, Ye Tian and Tomasz Kapitaniak January 2018
	https://www.researchgate.net/publication/322275783_Carpet_oscillator_A_new_mega-stable_nonlinear_oscillator_with_infinite_islands_of_self-excited_and_hidden_attractors
***************************************************************************/

int	DoCarpetOscillator(void)

    {
    double	i, c1[3], cn[3], m, n, k, t;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = 1.0;	// z

    m = param[0];
    n = param[1];
    k = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (c1[0] = -m; c1[0] <= m; c1[0] += k)
	{
	for (c1[1] = -n; c1[1] <= n; c1[1] += k)
	    {
	    for (i = 1; i < iterations; i++)
		{
		if (user_data(GlobalHwnd) == -1)				// user pressed a key?
		    return -1;
		curpass = (int)(i * totpasses / iterations);
		t = sin(0.1 * c1[1]);
		cn[0] = t;
		cn[1] = -sin(0.1 * c1[0]) + t * cos(c1[0]);
		cn[2] = c1[2];
		if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 2, 0) < 0)
		    break;
		}
	    }
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Cascading Method for Constructing New Discrete Chaotic Systems with Better Randomness
	Fang Yuan, Yue Deng, Yuxia Li and Guanrong Chen 20 May 2019
	Sent by Qiang Lai that recommended this paper
***************************************************************************/

int	DoCascadingMethod(void)

    {
    double	i, c1[3], cn[3], a1, a2;

    c1[0] = param[10];	// x
    c1[1] = 1.0;	// y
    c1[2] = 1.0;	// z

    a1 = param[0];
    a2 = param[1];
    if (a1 == 0.0) a1 = 1.0E-20;					// no divide by 0
    if (a2 == 0.0) a2 = 1.0E-20;
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 1; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 1.0 - a2 * fabs((1.0 - a1 * fabs(c1[0] - 1.0 / a1) - 1.0 / a2));
	cn[1] = c1[1];
	cn[2] = c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 1, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Categorising Chaotic Flows from the Viewpoint of Fixed Points and Perpetual Points
	Fahimeh Nazarimehr, Sajad Jafari and Seyed Mohammad Reza Hashemi Golpayegani November 13, 2016
	https://pdfs.semanticscholar.org/39b6/40bb314560938f79ea427e4b9dc8cade8ba0.pdfs
***************************************************************************/

int	DoCategorisingChaoticFlows(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    k = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 1; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] / (c1[2] * c1[2]);
	cn[1] = -c1[0];
	cn[2] = c1[3];
	cn[3] = c1[1] * c1[1] / (c1[2] * c1[2] * c1[2]) - 2 / c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Cells CNN Chaotic Attractor Images
***************************************************************************/

int	DoCells(void)

    {
    double	i, c1[3], cn[3], p1, p2, r, s, h1, h2, h3;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    p1 = param[0];
    p2 = param[1];
    r = param[2];
    s = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	h1 = 0.5 * (fabs(c1[0] + 1) - fabs(c1[0] - 1));
	h2 = 0.5 * (fabs(c1[1] + 1) - fabs(c1[1] - 1));
	h3 = 0.5 * (fabs(c1[2] + 1) - fabs(c1[2] - 1));
	cn[0] = -c1[0] + p1 * h1 - s * h2 - s * h3;
	cn[1] = -c1[1] - s * h1 + p2 * h2 - r * h3;
	cn[2] = -c1[2] - s * h1 + r * h2 + h3;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Changing Climate: A Snapshot Attractor Picture
	Probabilistic Concepts in a Changing Climate: A Snapshot Attractor Picture
	GABOR DROTOS, TAMAS BODAI, TAMAS TEL 15 APRIL 2015  : REM VERY MODERN !!!
***************************************************************************/

int	DoChangingClimate(void)

    {
    double	i, c1[3], cn[3], a, b, w, f, f0, g, azao;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    g = param[2];
    azao = param[3];
    w = 2.0 * PI / 73.0;
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	f0 = (i <= 7300.0) ? f0 = 9.5 : 9.5 - 2.0 / 7300.0 * (i - 7300.0);
	f = f0 + azao * sin(w * i);
	cn[0] = -c1[1] * c1[1] - c1[2] * c1[2] - a * c1[0] + a * f;
	cn[1] = c1[0] * c1[1] - b * c1[0] * c1[2] - c1[1] + g;
	cn[2] = c1[0] * c1[2] + b * c1[0] * c1[1] - c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaos Control of Single Time-scale Brushless DC Motor with Sliding Mode Control Method Images
	Yilmaz UYAROGLU, Baris CEVHER 27.05.2013
***************************************************************************/

int	DoChaosControl(void)

    {
    double	i, c1[3], cn[3], v1, v2, ro, delta, eta, tl, sigma;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    v1 = param[0];
    v2 = param[1];
    ro = param[2];
    delta = param[3];
    eta = param[4];
    tl = param[5];
    sigma = param[6];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = v1 - c1[0] - c1[1] * c1[2] + ro * c1[2];
	cn[1] = v2 - delta * c1[1] + c1[0] * c1[2];
	cn[2] = sigma * (c1[0] - c1[2]) + eta * c1[0] * c1[1] - tl;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaos and Adaptive Synchronisations in Fractional-Order Systems
	Xiaojun Liu August 2013
	https://www.researchgate.net/publication/326732244_Chaos_and_adaptive_synchronizations_in_fractional-order_systems/stats
***************************************************************************/

int	DoChaosAdaptiveSynchronisationsFractionalOrderSystems(void)

    {
    double	i, c1[3], cn[3], b1, b2, b3, b4;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    b1 = param[0];
    b2 = param[1];
    b3 = param[2];
    b4 = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = -b1 * c1[0] - b2 * c1[1] - b3 * c1[2] + b4 * c1[0] * c1[0] * c1[0] * c1[0] * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaos and Multi-Scroll Attractors in RCL-Shunted Junction Coupled Jerk Circuit Connected by Memristor
	Jun Ma, Ping Zhou, Bashir Ahmad, Guodong Ren and Chunni Wang January 17, 2018
	http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0191120
***************************************************************************/

int	DoChaosMultiScrollAttractors(void)

    {
    double	t, c1[3], cn[3], bc, bl, i, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    bl = param[0];
    i = param[1];
    bc = sin(PI/3.0);
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	g = (fabs(c1[1]) > 2.9) ? 0.366 : 0.061;
	cn[0] = c1[1];
	cn[1] = (i - g * c1[1] - sin(c1[0] - c1[2])) / bc;
	cn[2] = (c1[1] - c1[2]) / bl;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 5.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaos and Symbol Complexity in a Conformable Fractional-Order Memcapacitor System
	Shaobo He, Santo Banerjee and Bo Yan August 2018
	https://www.researchgate.net/publication/326865134_Chaos_and_Symbol_Complexity_in_a_Conformable_Fractional-Order_Memcapacitor_System
***************************************************************************/

int	DoChaosSymbolComplexity(void)

    {
    double	t, c1[3], cn[3], a1, bl, a2, b2, c, d, e, f1, f2;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a1 = param[0];
    bl = param[1];
    a2 = param[2];
    b2 = param[3];
    c = param[4];
    d = param[5];
    e = param[6];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	f1 = a1 * c1[2] + bl * c1[2] * c1[2] * c1[2];
	f2 = a2 * c1[1] + b2 * c1[1] * c1[1] * c1[1];
	cn[0] = c * f1;
	cn[1] = (d - e) * f2 + e * f1;
	cn[2] = e * (f2 - f1) - c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 5.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaos-Based Application of a Novel No-Equilibrium Chaotic System with Coexisting Attractors
	Zhen Wang, Akif Akgul, Viet-Thanh Pham and Sajad Jafari 1 May 2017 Received from the authors
***************************************************************************/

int	DoChaosBasedApplicationNovelNoEquilibriumChaoticSystem(void)

    {
    double	t, c1[3], cn[3], k1, k2, k3, k4, k5, k6;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    k1 = param[0];
    k2 = param[1];
    k3 = param[2];
    k4 = param[3];
    k5 = param[4];
    k6 = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = k1 * c1[0] * c1[1] + k2 * c1[0] * c1[2] + k3 * c1[1] * c1[2] + k4 * c1[1] * c1[1] * c1[1] + k5 * c1[2] * c1[2] * c1[2] + k6;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 5.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaos-Based Optimisation - A Review
	Roman Senkerik, Ivan ZelinkaI and Michal Pluhacek June 2017
	https://www.researchgate.net/publication/324087299_Chaos-Based_Optimization_-_A_Review
***************************************************************************/

int	DoChaosBasedOptimisation(void)

    {
    double	t, c1[3], cn[3], a, b, c, mu, gamma, w, real, imag;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = 1.0;	// z

    a = param[0];
    b = param[1];
    c = param[2];
    mu = param[3];
    gamma = param[4];
    w = param[5];
    real = param[6];
    imag = param[7];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = mu * (1.0 - gamma * c1[0] * c1[0]) * c1[1] - c1[0] * c1[0] * c1[0] + a * sin(w * t);
	cn[2] = real * cos(c1[1]) + imag * sin(c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 5.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaos Encryption Algorithm for Wireless Sensor Networks Based on the Reconfigure Technology of FPGA Images
	Kong De-peng, Zhu Jun-da, He Ting and Zhou Yi-fei 2014
***************************************************************************/

int	DoChaosEncryption(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e, f, g, h;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];
    h = param[7];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] + b * c1[1];
	cn[1] = c * c1[0] + d * c1[0] * c1[2] + e * c1[1];
	cn[2] = f * c1[0] * c1[1] + g * c1[0] + h * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaos Entanglement Function
	Hopf Bifurcation Analysis in a New Chaotic System with Chaos Entanglement Function
	Zhang Jiangang, Chu Yandong, Du Wenju, Chang Yingxiang, and An Xinlei 22 July 2014
***************************************************************************/

int	DoChaosEntanglement(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];    
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] + b * c1[1];
	cn[1] = -b * c1[0] + a * c1[1] + d * cos(c1[2]);
	cn[2] = c * c1[2] + e * tan(c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaos in a Novel Fractional Order System Without a Linear Term
	Zhang Sen, Zeng Yichenga and Li Zhijunb September 2018
	https://www.researchgate.net/publication/327396045_Chaos_in_a_novel_fractional_order_system_without_a_linear_term/comments
***************************************************************************/

int	DoChaosNovelFractionalOrderSystem(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] * c1[1] - c1[2] * c1[2];
	cn[1] = c1[0] * c1[0] - a * c1[0] * c1[1];
	cn[2] = c1[0] * c1[0] - b;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaos in a Pendulum Adaptive Frequency Oscillator Circuit Experiment
	Xiaofu LI, Aubrey Beal, Robert N. Dean and Edmon Perkins January 2023
	https://www.researchgate.net/publication/368525190.....DOI: 10.51537/chaos.1204481
***************************************************************************/

int	DoChaosPendulumAdaptiveFrequencyOscillator(void)

    {
    double	i, c1[3], cn[3], a, c, kw, w;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    c = param[1];
    kw = param[2];
    w = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] * 2;
	cn[1] = -c * c1[1] - 0.5 * (c1[2] * c1[2] * sin(c1[0]) - a * cos(c1[0] * sin(w * i)));
	cn[2] = -kw * c1[0] * a * sin(w * i) / 100 / sqrt(c1[0] * c1[0] + 4 * c1[1] * c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaos in Learning a Simple Two-Person Game
	Yuzuru Sato, Eizo Akiyama and J. Doyne Farmer 2002 Apr 2
	https://www.ncbi.nlm.nih.gov/pmc/articles/PMC123719/
***************************************************************************/

int	DoChaosLearningSimple2PersonGame(void)

    {
    double	i, c1[4], cn[4], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 2 * a *c1[2] + (3 + a) * c1[3];
	cn[1] = (-3 + a) * c1[2] + 2 * a * c1[3];
	cn[2] = -2 * a * c1[0] + (3 - a) * c1[1];
	cn[3] = -(3 + a) * c1[0] - 2 * a * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaos in Parametrically Excited Continuous Systems Images
	Exited System for Synchronisation
	New Criteria for Generalized Synchronisation 
	Tatyana S. Krasnopolskaya, Alexandre A. Gourjii, 
	Viacheslav M. Spektor, Dmytro F. Prykhodko
***************************************************************************/

int	DoChaosExcitedContinuous(void)

    {
    double	i, c1[4], cn[4], k, a, b1, b2, b3, b4, b5, b6, b, r;

    c1[0] = param[10];	// p1
    c1[1] = param[11];	// q1
    c1[2] = param[12];	// p2
    c1[3] = param[13];	// q2

    b = -1.531;

    k = param[0];
    a = param[1];
    b1 = param[2];
    b2 = param[3];
    b4 = param[4];
    b6 = param[5];

    b3 = 1.3 * k;
    b5 = 0.235 * k;

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	r = (b1 + b6 / 2 * (c1[0] * c1[0] + c1[1] * c1[1]));
	cn[0] = -a * c1[0] - r * c1[1] + b3 * c1[1] + b * (c1[1] * c1[2] - c1[0] * c1[3]);
	cn[1] = -a * c1[1] + r * c1[0] + b3 * c1[0] + b * (c1[0] * c1[2] + c1[1] * c1[3]);
	cn[2] = -a * c1[2] - b2 * c1[3] - 2.0 * b4 * c1[0] * c1[1];
	cn[3] = -a * c1[3] + b2 * c1[2] + b4 * (c1[0] * c1[0] - c1[1] * c1[1]) + b5;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaos in Integer Order and Fractional Order Financial Systems and their Synchronisation
	Fei Xu, Yongzeng Lai and Xiao-Bao Shu 23 October 2018
	Sent by Xiao-Bao Shu and available at https://www.researchgate.net/publication/329344017
***************************************************************************/

int	DoChaosIntegerOrderFractionalOrderFinancialSystems(void)

    {
    double	i, c1[4], cn[4], b, c, p, q, m, n, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    b = param[0];
    c = param[1];
    p = param[2];
    q = param[3];
    m = param[4];
    n = param[5];
    d = param[6];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2] + (c1[1] - c1[3]) * c1[0];
	cn[1] = 1 - b * c1[1] - c1[0] * c1[0] - d * c1[1] * c1[3];
	cn[2] = -c1[0] - c * c1[2];
	cn[3] = p - q * c1[3] + (m * c1[0] - n * c1[1]) * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaos–Hyperchaos Transition In Coupled Rössler Systems
	S. Yanchuk, T. Kapitaniak 12 November 2001
***************************************************************************/

int	DoChaosHyperchaosTransition(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x1
    c1[1] = param[11];	// x2
    c1[2] = param[12];	// x3

    b = param[0];
    c = param[1];
    d = param[2];
    a = param[3];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[1] - c1[2];
	cn[1] = c1[0] + a * c1[1];
	cn[2] = b + c1[2] * (c1[0] - c) + d * (c1[2] - c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaos in a 6D System with an Absolute Nonlinearity and Chaos Synchronization
	Victor Kamdoum Tamba, Karthikeyan Rajagopal, Viet-Thanh Pham and Duy Vo Hoang 30 January 2018
***************************************************************************/

int	DoChaosIn6DSystemWithAbsoluteNonlinearity(void)

    {
    double	i, c1[6], cn[6], a, b, c, kx, as, bs, cs;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    kx = param[3];

    totpasses = 10;

    InitOscillator(c1, 6);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * fabs(c1[1]) + b * c1[2];
	cn[1] = 1.0 + c1[2];
	cn[2] = -c * c1[0] - c1[2] + kx;

	as = -fabs(c1[1]) * (c1[3] - c1[0]);
	bs = -c1[2] * (c1[4] - c1[1]);
	cs = c1[0] * (c1[5] - c1[2]);

	cn[3] = as * fabs(c1[1]) + bs * c1[2] - (c1[3] - c1[0]);
	cn[4] = 1.0 + c1[2] - (c1[4] - c1[1]);
	cn[5] = -cs * c1[0] - c1[2] - (c1[5] - c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaos in a System with an Absolute Nonlinearity and Chaos Synchronization
	Victor Kamdoum Tamba, Karthikeyan Rajagopa, Viet-Thanh Pham and Duy Vo Hoang 30 January 2018
***************************************************************************/

int	DoChaosIn3DSystemWithAbsoluteNonlinearity(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * fabs(c1[1]) + b * c1[2];
	cn[1] = 1.0 + c1[2];
	cn[2] = -c * c1[0] - c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaos Synchronisation of Nonlinear Fractional Discrete Dynamical Systems via Linear Control
	Baogui Xin, Li Liu, Guisheng Hou and Yuan Ma 11 July 2017
	https://www.researchgate.net/publication/318345375
***************************************************************************/

int	DoChaosSynchronisation(void)

    {
    double	i, c1[3], cn[3], k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    k = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[0] + k * tan(c1[1]);
	cn[1] = c1[0] - k * c1[2];
	cn[2] = -k * c1[0] + c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaotic Attractor in a Simple Hybrid System
	XIAO-SONG YANG and QINGDU LI September 1, 2001
***************************************************************************/

int	DoChaoticAttractor(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, h, alpha, beta, k, l;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    h = param[4];
    alpha = param[5];
    beta = param[6];
    k = param[7];
    l = param[8];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] + b * c1[1];
	if ((c1[2] + k * c1[0]) <= -l)
	    {
	    cn[1] = c * c1[0] + d * c1[1];
	    cn[2] = -h * c1[2] + alpha;
	    }
	else if (fabs(c1[2] + k * c1[0]) < l)
	    {
	    cn[1] = c * c1[0] + (d + beta) * c1[1];
	    cn[2] = -h * c1[2];
	    }
	else
	    {
	    cn[1] = c * c1[0] + d * c1[1];
	    cn[2] = -h * c1[2] - alpha;
	    }
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaotic Attractor in 4 Dimensions
	M.Ababneh 14 February 2017
***************************************************************************/

int	DoChaoticAttractor4D(void)

    {
    double	i, c1[4], cn[4], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[3] * (b - c1[1]);
	cn[1] = c1[0] * (c1[3] - c1[2]);
	cn[2] = c1[1] * (c1[0] - 1.0);
	cn[3] = a * (c1[0] - c1[3]);

	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaotic Attractor With Quadratic Exponential Nonlinear Term From Chen's Attractor
	IFTIKHAR AHMED, CHUNLAI MU, FUCHEN ZHANG and MARCUS REZENDE 2014/ 2015
***************************************************************************/

int	DoChaoticAttractorQuadratic(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e = exp(1.0);

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) - c1[3];
	cn[1] = (c - a) * c1[0] + c * c1[1] - c1[0] * c1[2];
	cn[2] = pow(e, (c1[0] * c1[1])) - b * c1[2];
	cn[3] = -c1[0] * c1[2] + d * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaotic Behavior and Feedback Control of Magnetorheological Suspension System With Fractional-Order Derivative
	Chengyuan Zhang and Jian Xiao February 2018
	https://www.researchgate.net/publication/319859507_Chaotic_Behavior_and_Feedback_Control_of_Magnetorheological_Suspension_System_With_Fractional-Order_Derivative
***************************************************************************/

int	DoChaoticBehaviorFeedbackControl(void)

    {
    double	i, c1[3], cn[3], a0, a, b, c, d, w;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a0 = param[0];
    a = param[1];
    b = param[2];
    c = param[3];
    d = param[4];
    w = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = a0 * w * w * sin(w * i) - a * c1[0] - b * c1[0] * c1[0] * c1[0] - c * c1[1] - d * c1[1] * c1[1] * c1[1];
	cn[2] = sin(c1[0]) + cos(c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaotic Chameleon: Dynamic Analyses, Circuit Implementation, FPGA Design and Fractional Order -b .8
	Karthikeyan Rajagopal, Akif Akgul, Sajad Jafari, Anitha Karthikeyan and Ismail Koyuncu 7 July 2017
	https://www.researchgate.net/publication/318351140_Chaotic_chameleon_Dynamic_analyses_circuit_implementation_FPGA_design_and_fractional-order_form_with_basic_analyses
***************************************************************************/

int	DoChaoticChameleon(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    c = param[1];
    b = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] + b;
	cn[1] = -7.0 * c1[0] + 4.0 * c1[1] * c1[2];
	cn[2] = a - c1[0] * c1[0] - c1[1] * c1[1] + c * c1[0] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaotic Cuttlesh: King of Camouage with Self-Excited and Hidden Flows and Communication Designs with Fractional Form
	Karthikeyan Rajagopal, Serdar Cicek, Akif Akgul, Sajad Jafari and Anitha Karthikeyan 3 March 2020
	Received from  Shijian Cang  through Research Gate
***************************************************************************/

int	DoChaoticCuttlesh(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -4.0 * c1[0] - 4.0 * c1[1] * c1[2];
	cn[2] = c1[0] * c1[0] + c1[1] * c1[1] + b * c1[2] * c1[2] - a;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	The Chaotic Dadras-Momeni System:  Control and Hyperchaotification-4D
	H. Saberi Nik and Robert A. Van Gorder and G. Gambino May 16, 2014
***************************************************************************/

int	DoChaoticDadrasMomeniSystem(void)

    {
    double	i, c1[4], cn[4], r, m, g, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    r = param[0];
    m = param[1];
    g = param[2];
    k = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = r * (c1[1] - c1[0]) + c1[3];
	cn[1] = -(1.0 + m) * c1[1] + 2.0 * c1[0] * c1[2];
	cn[2] = g / 2.0 * (1.0 + m * c1[0] * c1[0] - (1.0 + m) * c1[0] * c1[1]);
	cn[3] = -k * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaotic Dynamics of a Fractional-Order System, its Chaos-Suppressed Synchronisation and Circuit Implementation
	Manashita Borah, Piyush P. Singh, Binoy K. Roy, 2 March 2016
***************************************************************************/

int	DoChaoticDynamicsFractionalOrder(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -2.667 * c1[0] - 10.0 * c1[1] - c1[1] * c1[1];
	cn[1] = -10.0 * c1[1] + 10.0 * c1[2];
	cn[2] = 27.3 * c1[1] - c1[2] + c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaotic Evolution towards Philosophy and Methodology of Chaotic Optimization
	From Determinism and Probability to Chaos
	Yan Pei 12 November 2014
***************************************************************************/

int	DoChaoticEvolution(void)

    {
    double	i, c1[4], cn[4], a1, a2, a3, b1, b2, b3, d1, d2, d3, alpha, beta, gamma, mu;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a1 = param[0];
    a2 = param[1];
    a3 = param[2];
    b1 = param[3];
    b2 = param[4];
    b3 = param[5];
    d1 = param[6];
    d2 = param[7];
    d3 = param[8];
    mu = param[9];
    alpha = 1.35;
    beta = 0.3;
    gamma = 0.35;
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	c1[0] = (c1[0] < 0.5 && c1[0] >= 0.0) ? mu * c1[0] : mu * (1.0 - c1[0]);
	cn[0] = mu * c1[0] * (1.0 - c1[0]);				// here ends the original equations
	cn[1] = c1[1] + beta * c1[1] * (a2 - a1 * b2 - b1 * b2 * c1[0] - 2.0 * b2 * c1[1] + d2 * c1[2]);
	cn[2] = c1[2] + gamma * c1[2] * (a3 + a1 * b3 - b1 * b3 * c1[0] + d3 * c1[1] - 2.0 * b3 * c1[2]);
	cn[3] = (mu * c1[0] * (1.0 - c1[0]) - c1[3]) / dt;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 1.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaotic Flow with Hidden Attractor - The First Hyperjerk System with No Equilibrium
	Shuili Ren, Shirin Panahi, Karthikeyan Rajagopal, Akif Akgul, Viet-Thanh Pham and Sajad Jafari December 28, 2017
	https://www.researchgate.net/publication/322100648
***************************************************************************/

int	DoChaoticFlowHiddenAttractor(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];				// here ends the original equations
	cn[1] = c1[2];
	cn[2] = c1[3];
	cn[3] = a * c1[0] * c1[0] + b * c1[0] * c1[1] + c * c1[0] * c1[2] + d * c1[0] * c1[3] + e;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaotic and Hyperchaotic Complex Jerk Equations
	Gamal M. Mahmoud, Mansour E. Ahmed March 12, 2012
***************************************************************************/

int	DoChaoticHyperchaotic(void)

    {
    double	i, c1[6], cn[6], alpha, beta, ni, eta;

    c1[0] = param[10];	// x1
    c1[1] = param[11];	// x2
    c1[2] = param[12];	// x3
    c1[3] = param[13];	// x4
    c1[4] = param[14];	// x5
    c1[5] = param[15];	// x6

    alpha = param[0];
    beta = param[1];
    ni = param[2];
    eta = param[3];
    totpasses = 10;

    InitOscillator(c1, 6);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2];
	cn[1] = c1[3];
	cn[2] = c1[4];
	cn[3] = c1[5];
	cn[4] = -alpha * c1[4] - beta * c1[2] - ni * c1[0] - eta * c1[0] * (c1[0] * c1[0] + c1[1] * c1[1]);
	cn[5] = -alpha * c1[5] - beta * c1[3] - ni * c1[1] - eta * c1[1] * (c1[0] * c1[0] + c1[1] * c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaotic Dynamics of Modified Wien Bridge Oscillator with Fractional Order Memristor
	Karthikeyan RAJAGOPAL, Chunbiao LI, Fahimeh NAZARIMEHR, Anitha KARTHIKEYAN, Prakash DURAISAMY and Sajad JAFARI 1 APRIL 2019
	https://www.researchgate.net/publication/332382380_Chaotic_Dynamics_of_Modified_Wien_Bridge_Oscillator_with_Fractional_Order_Memristor
***************************************************************************/

int	DoChaoticDynamicsModifiedWienBridgeOscillator(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] * (a - 1 - c * c1[2] * c1[2]) - b * c1[1];
	cn[1] = a * c1[0] - b * c1[1];
	cn[2] = -c1[0] - c1[2] * (d - c1[0] * c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaotic Attractors of Relaxation Oscillators
	John Guckenheimer1, Martin Wechselberger2 and Lai-Sang Young 31 January 2006
***************************************************************************/

int	DoChaoticRelaxation(void)

    {
    double	i, c1[3], cn[3], w, a, epsilon;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    w = param[0];
    a = param[1];
    epsilon = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = (c1[1] + c1[0] - c1[0] * c1[0] * c1[0] / 3.0) / epsilon;
	cn[1] = -c1[0] + a * (c1[0] * c1[0] - 1.0) * sin(2.0 * PI * c1[2]);
	cn[2] = w;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaotic Signal-Induced Dynamics of Degenerate Optical Parametric Oscillator
	Ma Jun 2005
***************************************************************************/

int	DoChaoticSignalInduced(void)

    {
    double	i, c1[4], cn[4], g, d0, d1, ea, u;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    g = param[0];
    d0 = param[1];
    d1 = param[2];
    ea = param[3];
    u = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[0] + d1 * c1[1] + c1[0] * c1[2] + c1[1] * c1[2];
	cn[1] = -d1 * c1[0] - c1[1] - c1[1] * c1[2] + c1[0] * c1[3];
	cn[2] = -g * c1[2] + d0 * c1[3] - c1[0] * c1[0] + u * u + ea;
	cn[3] = -g * c1[3] - d0 * c1[2] - 2.0 * c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 4, 2) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Chaotic System with Different Families of Hidden Attractors
	Viet-Thanh Pham,Christos Volos,Sajad Jafari,Sundarapandian Vaidyanathan, Tomasz Kapitaniak,Xiong Wang February 25, 2016
***************************************************************************/

int	DoChaoticDifferentFamilies(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, r, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    r = param[4];
    k = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[2];
	cn[1] = c1[2] * (b * c1[0] - c * fabs(c1[2])) - k;
	cn[2] = c1[0] * c1[0] + c1[1] * c1[1] - r * r - d * c1[0] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 2) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Chaotic System with Multiple Attractors - Dynamic Analysis, Circuit Realization and S-Box Design
	Qiang Lai, Akif Akgul, Chunbiao Li, Guanghui Xu and Unal Cavusoglu 27 December 2017
	http://www.mdpi.com/1099-4300/20/1/12/pdf
***************************************************************************/

int	DoChaoticSystemMultipleAttractors(void)

    {
    double	i, c1[3], cn[3], a, b, c, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    k = param[3] / 2.0;
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] - 2.0 * c1[1] * c1[2];
	cn[1] = -b * c1[1] + 2.0 * c1[0] * c1[2];
	cn[2] = -c * c1[2] + c1[0] * c1[1] * c1[2] + k;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 2) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Chaotic System with Rounded Square Equilibrium and with No-Equilibrium
	Viet-Thanh Pham, Sajad Jafari, Christos Volos, Tomas Gotthans, Xiong Wang, 
	Duy Vo Hoang 24, october 2016
***************************************************************************/

int	DoChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2];
	cn[1] = -c1[2] * (a * c1[1] + b * c1[1] * c1[1] + c1[0] * c1[2]) - c;
	cn[2] = c1[0] * c1[0] * c1[0] * c1[0] + c1[1] * c1[1] * c1[1] * c1[1] - 1.0;

	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaotic System with Equilibria Located on the Rounded Square Loop and its Circuit Implementation
	Viet-Thanh Pham, Sajad Jafari, Christos Volos, Aggelos Giakoumis, Sundarapandian Vaidyanathan, and Tomasz Kapitaniak September 2015
***************************************************************************/

int	DoChaoticSystemEquilibriaLocatedRoundedSquareLoop(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    k = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[2];
	cn[1] = b * c1[0] * c1[2] - c * c1[2] * c1[2] * c1[2];
	cn[2] = c1[0] * c1[0] * c1[0] * c1[0] + c1[1] * c1[1] * c1[1] * c1[1] - k - d * c1[0] * c1[2];

	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaotification in the Stretch-Twist-Fold (STF) Flow
	YUE BaoZeng and AQEEL Muhammad May 2013
	https://link.springer.com/content/pdf/10.1007%2Fs11434-013-5754-x.pdf
***************************************************************************/

int	DoChaotificationSTFFlow(void)

    {
    double	i, c1[3], cn[3], alpha, beta;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alpha = param[0];
    beta = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = alpha * c1[2] - 8 * c1[0] * c1[1];
	cn[1] = 11 * c1[0] * c1[0] + 3 * c1[1] * c1[1] + c1[2] * c1[2] + beta * c1[0] * c1[2] - 3;
	cn[2] = -alpha * c1[0] + 2 * c1[1] * c1[2] - beta * c1[0] * c1[1];

	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	The Characteristics of the Chaotic Parameters for a Loss Type of Modified Coupled Dynamic System
	Hao Jian-Hong and Sun Na-Yan 3 January 2017
***************************************************************************/

int	DoCharacteristicsChaoticParameters(void)

    {
    double	i, c1[3], cn[3], a, mu, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    mu = param[1];
    e = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -mu * c1[0] + c1[1] * (c1[2] + a);
	cn[1] = -mu * c1[1] + c1[0] * (c1[2] - a);
	cn[2] = e * c1[2] - c1[0] * c1[1];

	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chemical Chaos Images
	AMPLIFICATION PHENOMENA UNDER CHAOTIC DRIVING IN A MODEL OF CHEMICAL CHAOS
	J. M. GONZALEZ-MIRANDA September 11, 1998: REM very old !!
***************************************************************************/

int	DoChemicalChaos(void)

    {
    double	i, c1[3], cn[3], d, lambda, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    d = param[0];
    lambda = param[1];
    e = param[2];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] * (d * c1[0] - c1[1] / 2.0 - c1[2] + 0.6);
	cn[1] = c1[1] * (c1[0] + 3.0 * c1[2] / 10.0 - lambda);
	cn[2] = (1.0 / e) * (c1[0] - c1[2] * c1[2] * c1[2] / 2.0 + 3.0 * c1[2] * c1[2] - 5.0 * c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chemical Oscillations Out of Chemical Noise
	Carlos Escudero,  Andres M. Rivera and Pedro J. Torres 2 Oct 2011
***************************************************************************/

int	DoChemicalOscillations(void)

    {
    double	i, c1[3], cn[3], mu, sigma;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    mu = param[0];
    sigma = param[1];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = mu * (c1[0] - c1[0] * c1[0]) + sigma * (c1[0] * c1[0] - c1[0]) * c1[1];
	cn[1] = mu * (c1[0] + c1[0] - 1.0) * c1[1] + sigma / 2.0 * (1.0 - c1[0] - c1[0]) * c1[1] * c1[1];
	cn[2] = sin(c1[0]) + cos(c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chen Chaotic Attractor Images
***************************************************************************/

int	DoChen(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = (c - a) * c1[0] - c1[0] * c1[2] + c * c1[1];
	cn[2] = c1[0] * c1[1] - b * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chen Circuit-Like Model: High Periodicity Leading to Chaotic Dynamics
	Sk Sarif Hassan and Sujay Goldar August 26, 2023
	https://www.researchgate.net/publication/374482027....DOI: 10.1142/S0218127423501444
	Corresponding author sujaygoldar@pinglacollege.ac.in
***************************************************************************/

int	DoChenCircuitLikeModel(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = c1[0] - b * c1[0] * c1[2] + c * c1[1];
	cn[2] = c1[0] * c1[1] + sqr(c1[0]) * c1[2] - d * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chen-Lee Chaotic Attractor Images
***************************************************************************/

int	DoChenLee(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] - c1[1] * c1[2];
	cn[1] = b * c1[1] + c1[0] * c1[2];
	cn[2] = c * c1[2] + c1[0] * c1[1] / 3;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chen Like Chaotic Attractor + Marcus Images
	A New Three-Scroll Unified Chaotic System Coined
	Lin Pan, Wuneng Zhou, Jian'an Fang , Dequan Li 10 March 2010
***************************************************************************/

int	DoChenLike(void)

    {
    double	i, c1[4], cn[4], a, c, d, e, f, gamma;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    c = param[1];
    d = param[2];
    e = param[3];
    f = param[4];
    gamma = param[5];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + d * c1[0] * c1[2];
	cn[1] = (f - a) * c1[0] - c1[0] * c1[2] + f * c1[1];
	cn[2] = -e * c1[0] * c1[0] + c1[0] * c1[1] + c * c1[2];
	cn[3] = gamma * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chen-Multiscroll Chaotic Attractor Images
	MULTI-SCROLL CHAOTIC AND HYPERCHAOTIC ATTRACTORS 
	GENERATED FROM CHEN SYSTEM 'XINZHI LIU, XUEMIN (SHERMAN) SHEN and HONGTAO ZHANG
	Received December 15, 2011
***************************************************************************/

int	DoChenMultiscroll(void)

    {
    double	i, c1[3], cn[3], d1, d2, a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d1 = param[3];
    d2 = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = (c - a) * c1[0] - c1[0] * (d1 * c1[2] - d2 * sin(c1[2])) + c * c1[1];
	cn[2] = c1[0] * c1[1] - b * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chimeralike States in a Network of Oscillators under Attractive and Repulsive Global Coupling
	Arindam Mishra, Chittaranjan Hens, Mridul Bose, Prodyot K. Roy, Syamal K. Dana June 3, 2015
***************************************************************************/

int	DoChimeralikeStates(void)

    {
    double	i, c1[3], cn[3], a, f, w, m, e, sb, rb, xb, yb;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y

    rb = sb = 0.0;	// rb and sb are somatories
    xb = yb = 0.0;

    a = param[0];
    f = param[1];
    w = param[2];
    m = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 2);						// pass in number of dimensions
    for (i = 1.0; i < iterations; i++)					// i cannot be zero because of one division by i
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	sb += c1[0]; 
	xb = sb / i;							// xb is the media of all  xxx  till now
	rb += c1[1]; 
	yb = rb / i;							// yb is the media of all  yyy  till now
	cn[0] = c1[1];
	cn[1] = a * (1.0 - c1[0] * c1[0]) * c1[1] - c1[0] * c1[0] * c1[0] + f * sin(w * i) + m * (e * (xb - c1[0]) + (yb - c1[1]));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 2, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chua Chaotic Oscillator Images
***************************************************************************/

int	DoChua(void)

    {
    double	i, c1[3], cn[3], h, alpha, beta, a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    alpha = param[2];
    beta = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	h = b * c1[0] + (0.5 * (a - b) * (fabs(c1[0] + 1) - fabs(c1[0] - 1)));
	cn[0] = alpha * (c1[1] - c1[0] - h);
	cn[1] = c1[0] - c1[1] + c1[2];
	cn[2] = -beta * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 1.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chua Cubic Chaotic Oscillator Images
***************************************************************************/

int	DoChuaCubic(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] -  c1[0] *  c1[0] *  c1[0] - c *  c1[0]);
	cn[1] = c1[0] - c1[1] + c1[2];
	cn[2] = -b * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chua-Matsumoto's Chaotic Oscillator Images
	Optimal Feedback Control Aproach to Patern Signal Generation
	with Chua-Matsumoto's Chaotic Oscillator
	K. Bouson, Sandra c. r. Antunes January-February 2010
***************************************************************************/

int	DoChuaMatsumoto(void)

    {
    double	i, c1[3], cn[3], a, b, c, alpha, beta, k1, k2, f, d;

    c1[0] = param[10];	// x1
    c1[1] = param[11];	// x2
    c1[2] = param[12];	// x3

    alpha = param[0];
    beta = param[1];
    a = param[2];
    b = param[3];
    c = param[4];
    d = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	k1 = b * PI / 2.0 / a;
	k2 = 2.0 * a * c;
	if (c1[0] >= k2)
	    f = k1 * (c1[0] - k2);
	else if (c1[0] <= -k2)
	    f = k1 * (c1[0] + k2);
	else 
	    f = -b * sin(PI * c1[0] / 2.0 / a + d);
	cn[0] = alpha * (c1[1] - f);
	cn[1] = c1[0] - c1[1] + c1[2];
	cn[2] = -beta * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chua's Chaotic System in 4 Dimensions Images
	FOUR-DIMENSIONAL CHUA'S SYSTEM PERIODIC, CHAOTIC, AND HYPERCHAOTIC 
	STATES IN PARAMETER-SPACES OF A FOUR-DIMENSIONAL CHUA’S SYSTEM
	Cristiane Stegemann, Holokx A. Albuquerque, Paulo C. Rech July 26-30, 2010
***************************************************************************/

int	DoChuaQuartic(void)

    {
    double	i, c1[4], cn[4], a, c, s, alpha, beta, gamma;

    c1[0] = param[10];	// x1
    c1[1] = param[11];	// x2
    c1[2] = param[12];	// x3
    c1[3] = param[13];	// x4

    a = param[0];
    c = param[1];
    s = param[2];
    alpha = param[3];
    beta = param[4];
    gamma = param[5];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = alpha * (c1[1] - a * c1[0] * c1[0] * c1[0] - (1.0 + c) * c1[0]);
	cn[1] = c1[0] - c1[1] + c1[2];
	cn[2] = -beta * c1[1] - gamma * c1[2] + c1[3];
	cn[3] = -s * c1[0] + c1[1] * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Circuit Design and Experimental Investigations for a Predator-Prey Model
	Afef Ben Saad, Ali Hmidet and Olfa Boubaker January 12, 2018.
	Received directly from the third author or 
	https://www.researchgate.net/publication/326519127_Circuit_Design_and_Experimental_Investigations_for_a_Predator-Prey_Model
***************************************************************************/

int	DoCircuitDesignPredatorPreyModel(void)

    {
    double	i, c1[3], cn[3], m, l, k, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    m = param[0];
    l = param[1];
    k = param[2];
    e = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] * (c1[0] - l) * (k - c1[0]) - c1[0] * c1[1];
	cn[1] = e * (c1[0] - m) * c1[1];
	cn[2] = sin(c1[1]) + cos(c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Circuit Implementation of a Modified Chaotic System with Hyperbolic Sine Nonlinearities Using Bi-Color LED
	Christos K. Volos, Lazaros Moysis, George D. Roumelas, Aggelos Giakoumis, Hector E. Nistazakis and George S. Tombras 24 February 2021
	Sento to ManoWIN by Christos k. Volos through https://www.mdpi.com/2227-7080/9/1/15
***************************************************************************/

int	DoCircuitImplementationModifiedChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[1];
	cn[1] = -d * c1[2] - c * sinh(c1[2]);
	cn[2] = -e * c1[0] - b * c1[2] + a * sinh(c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Circuit Implementations of a Nonlinear System for Integer and Fractional Orders
	A. Akgul, B. Aricioglu, S. Kacar and I. Pehlivan 2017
	https://www.researchgate.net/publication/321532968_Circuit_implementations_of_a_nonlinear_system_for_integer_and_fractional_orders
***************************************************************************/

int	DoCircuitImplementationNonlinearSystemIntegerFractionalOrders(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[0] + b * c1[1] + c1[1] * c1[2];
	cn[1] = -a * c1[1] - b * c1[0] + c1[0] * c1[2];
	cn[2] = c1[2] - c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Circuit Implementation, Synchronisation of Multistability, and Image Encryption of a Four-Wing Memristive Chaotic System
	Guangya Peng, Fuhong Min and Enrong Wang 1 February 2018
***************************************************************************/

int	DoCircuitImplementationFourWingMemristiveChaoticSystem(void)

    {
    double	i, c1[4], cn[4], a, b, alpha, beta, epsilon, gamma;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    alpha = param[2];
    beta = param[3];
    epsilon = param[4];
    gamma = param[5];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 36.0 * c1[1] * c1[2] - alpha * c1[0] - c1[2] * (a + b * c1[3] * c1[3]);
	cn[1] = epsilon * c1[1] - beta * c1[0] * c1[2];
	cn[2] = 8.0 * c1[0] * c1[1] - gamma * c1[2];
	cn[3] = c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Clown 3D Images
	Lorenz+Function Projective Synchronisation of Two Identical New Hyperchaotic Systems
***************************************************************************/

int	DoClown(void)

    {
    double	i, c1[4], cn[4], a, b, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    d = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = (1.0 + a * b) * c1[0] - b * c1[0] * c1[1];
	cn[1] = -(1.0 - b) * c1[1] - c1[2] * c1[3] + b * c1[0] * c1[0];
	cn[2] = -c1[0] * c1[1] - b * c1[2] - c1[1] * c1[0] - c1[2] - c1[3];
	cn[3] = -d * c1[3] + c1[1] * c1[2] - c1[0] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Coexistence of Generalised Synchronisation and Inverse Generalised Synchronisation Between Chaotic and Hyperchaotic Systems
	Ahlem Gasri, Adel Ouannas, Kayode S. Ojo and Viet-Thanh Pham June 15, 2018
	Received from  Research Gate
***************************************************************************/

int	DoCoexistenceGeneralisedSynchronisation(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    k = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[2];
	cn[1] = b * c1[0] * c1[2] - c * c1[2] * c1[2] * c1[2];
	cn[2] = c1[0] * c1[0] * c1[0] * c1[0] + c1[1] * c1[1] * c1[1] * c1[1] - k - d * c1[0] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Coexistence of Hidden Attractors, 2-Torus and 3-Torus in a New Simple 4-D Chaotic System with Hyperbolic Cosine Nonlinearity
	Vitrice Ruben Folifack Signing and Kengne Jacques November 2018
	https://www.researchgate.net/publication/322321461_Coexistence_of_hidden_attractors_2-torus_and_3-torus_in_a_new_simple_4-D_chaotic_system_with_hyperbolic_cosine_nonlinearity
***************************************************************************/

int	DoCoexistenceHiddenAttractors2Torus3Torus(void)

    {
    double	i, c1[4], cn[4], a, b, c, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    e = param[2];
    c = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[1] - c1[2];
	cn[1] = c1[0] + c1[3];
	cn[2] = a * (1 - e * cosh(c1[1])) - b * c1[2];
	cn[3] = -c * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Coexistence of Hidden Chaotic Attractors in a Novel No-equilibrium System
	Viet-Thanh Pham, Christos Volos, Sajad Jafari, and Tomasz Kapitaniak 3 November 2016
***************************************************************************/

int	DoCoexistenceHiddenChaoticAttractors(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[0] - c1[1] * c1[2];
	cn[2] = fabs(c1[0]) + c1[0] * c1[1] - a;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Coexistence of Single & Multi-Scroll Chaotic Orbits in a Single-Link Flexible Joint Robot Manipulator with Stable Spiral and Index-4 Spiral Repellor Types of Equilibria
	Jay Prakash Singh, K. Lochan, Nikolay V. Kuznetsov and B. K. Roy 4 August 2017
	https://www.researchgate.net/publication/319177478
***************************************************************************/

int	DoCoexistenceSingleMultiScrollChaoticOrbits(void)

    {
    double	i, c1[4], cn[4], p1, p2, p3, p4, p5, a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// z

    p1 = param[0];
    p2 = param[1];
    p3 = param[2];
    p4 = param[3];
    p5 = param[4];
    a = param[5];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -p1 * (c1[0] - c1[2]) * sin(c1[0]) - p2 * (c1[0] - c1[2]);
	cn[2] = c1[3];
	cn[3] = p3 * (c1[0] - c1[2]) - p4 * c1[3] + p5 * a * cos(2 * PI * c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Coexisting Attractors and Circuit Implementation of a New 4D Chaotic System with Two Equilibria
	Qiang Lai, Tsafack Nestor, Jacques Kengnec and Xiao-Wen Zhao 21 December 2017
	https://www.researchgate.net/publication/322523032_Coexisting_attractors_and_circuit_implementation_of_a_new_4D_chaotic_system_with_two_equilibria
***************************************************************************/

int	DoCoexistingAttractorsCircuitImplementation(void)

    {
    double	i, c1[4], cn[4], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = c1[0] * c1[2] + c1[3];
	cn[2] = b - c1[0] * c1[1];
	cn[3] = c * c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Coexisting Attractors, Crisis Route to Chaos in a Novel 4D Fractional-Order System and Variable-Order Circuit Implementation
	Chengyi Zhou, Zhijun Lia and Fei Xie 2018
	sent by  Zhou Chengyi
***************************************************************************/

int	DoCoexistingAttractorsCrisisRoute2Chaos(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    k = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] - c * c1[1] * c1[2];
	cn[1] = c1[0] * c1[2] - b * c1[1] + c1[3];
	cn[2] = c1[0] * c1[1] - d * c1[2];
	cn[3] = -k * c1[3] - c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Coexisting Attractors Generated from a New 4D Smooth Chaotic System
	Qiang Lai and Shiming Chen Springer 2016
	http://www.springer.com/12555
***************************************************************************/

int	DoCoexistingAttractorsGenerated4DSmoothChaoticSystem(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] - c1[1] * c1[2];
	cn[1] = -b * c1[1] + c1[0] * c1[2] - c1[2] * c1[3];
	cn[2] = -c * c1[2] + c1[0] * c1[1];
	cn[3] = d * (c1[1] - c1[3]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Coexisting Infinitely Many Attractors in Active Band-Pass Filter-Based Memristive Circuit
	Bocheng Bao, Tao Jiang, Quan Xu, Mo Chen, Huagan Wu and Yihua Hu 26 July 2016
	https://www.researchgate.net/publication/305894313
***************************************************************************/

int	DoCoexistingInfinitelyManyAttractors(void)

    {
    double	i, c1[4], cn[4], a, b1, b2, c, r1, r2, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b1 = param[1];
    b2 = param[2];
    c = param[3];
    r1 = param[4];
    r2 = param[5];
    k = param[6];
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[1];
	cn[1] = c * (b1 - b2 * c1[0] * c1[0]) * c1[1] - c * (c1[1] - c1[2]);
	cn[2] = -k * c1[1] + k * (r1 + 1) * c1[2] - (2 * k + 1) * r2 * c1[3] / (k + 1);
	cn[3] = -(k + 1) * c1[1] + (k + 1) * (r1 + 1) * c1[2] - 2 * r2 * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Coexisting Multi-Stable Patterns in Memristor Synapse-Coupled Hopfield Neural Network with Two Neurons
	Chengjie - Chen, Jingqi Chen, Han Bao, M. Chen and Bocheng Bao February 2019
	https://www.researchgate.net/publication/330368824_Coexisting_multi-stable_patterns_in_memristor_synapse-coupled_Hopfield_neural_network_with_two_neurons0
***************************************************************************/

int	DoCoexistingMultiStablePatterns(void)

    {
    double	i, c1[3], cn[3], k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    k = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[0] - 0.1 * tanh(c1[0]) + 2.8 * tanh(c1[1]) + k * c1[2] * (c1[0] - c1[1]);
	cn[1] = -c1[1] - 3 * tanh(c1[0]) + 4 * tanh(c1[1]) - k * c1[2] * (c1[0] - c1[1]);
	cn[2] = c1[0] - c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Coexisting Oscillation and Extreme Multistability for a Memcapacitor-Based Circuit
	Guangyi Wang, Chuanbao Shi, Xiaowei Wang and Fang Yuan 23 January 2017
***************************************************************************/

int	DoCoexistingOscillation(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e, f, m, n;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    m = param[6];
    n = param[7];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c * c1[0] + d * c1[1] - a * c1[2] - b * c1[2] * c1[3] * c1[3];
	cn[1] = f * c1[0] + e * c1[1] - n * c1[2] - m * c1[2] * c1[3] * c1[3];
	cn[2] = c1[0] + c1[1];
	cn[3] = c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Coherent Motion of Chaotic Attractors
	Patrick Louodop, Suman Saha, Robert Tchitnga, Paulsamy Muruganandam, Syamal K. Dana and Hilda A. Cerdeira 18 October 2017
	https://www.researchgate.net/publication/320471958_Coherent_motion_of_chaotic_attractor
***************************************************************************/

int	DoCoherentMotionChaoticAttractors(void)

    {
    double	i, c1[3], cn[3], a, b, g, t;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    g = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	t = (c1[1] <= 1.0) ? -c1[1] : -1.0;
	cn[0] = t;
	cn[1] = a * (-c1[2] + t);
	cn[2] = b * (-c1[0] + c1[1] - g * c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Colour Image Compression-Encryption Algorithm Based on Fractional-Order Discrete Chaotic Neural Network and DNA Sequence Operations
	Li-ping CHEN, Hao YIN, Li-guo YUAN, Antonio M. LOPES, J. A. Tenreiro MACHADO, Ran-chao WU Apr. 16, 2020
	Received from J. A. Tenreiro MACHADO through https://link.springer.com/content/pdf/10.1631/FITEE.1900709.pdf
***************************************************************************/

int	DoColourImageCompressionEncryptionAlgorithmNeuralNetworkDNA(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[0] + 2 * sin(c1[0]) + sin(c1[1]) - 9 * sin(c1[2]);
	cn[1] = -c1[1] - 9 * sin(c1[0]) + 2 * sin(c1[1]) + sin(c1[2]);
	cn[2] = -c1[2] + sin(c1[0]) - 9 * sin(c1[1]) + 2 * sin(c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Colour Image Compression-Encryption Algorithm Based on Fractional-Order Memristor Chaotic Circuit
	FEIFEI YANG, JUN MOU, KEHUI SUN, YINGHONG CAO and JIYU JIN 2019
	Sent directly by KEHUI SUN – provisory issue or this article in IEEE access
***************************************************************************/

int	DoColourImageCompressionEncryptionAlgorithm(void)

    {
    double	i, c1[4], cn[4], a, b, c, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    g = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[1];
	cn[1] = b * (1 - g * c1[0] * c1[0]) * c1[1] + b * c1[3];
	cn[2] = c1[2] - c1[3];
	cn[3] = c * (c1[2] - c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hyperchaos in micro Colpitts Images
	Hyperchaos in coupled Colpitts oscillators' Roland Pulch
	Antanas Cenys, Arunas Tamasevicius, Antanas Baziliauskas,
	Romanas Krivickas, Erik Lindberg 2003
***************************************************************************/

int	DoColpitts(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	f = (c1[2] < (e - 1)) ? e - 1.0 - c1[2] : 0.0;
	cn[0] = c1[1] - a * f;
	cn[1] = c - c1[0] - b * c1[1] - c1[2];
	cn[2] = c1[1] - d * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Colpitts Oscillator stretched Images
	18 November 2013
***************************************************************************/

int	DoColpittsStretched(void)

    {
    double	i, c1[4], cn[4], s1, s2, gamma, epsilon, b, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    e = exp(1.0);

    s1 = param[0];
    s2 = param[1];
    gamma = param[2];
    epsilon = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	b = c1[1] + c1[2];
	cn[0] = s1 * (c1[3] - gamma * (pow(e, -b) - 1.0));
	cn[1] = c1[3];
	b = c1[1];
	cn[2] = s2 * (c1[3] - gamma * (pow(e, -b) - 1.0));
	cn[3] = -c1[0] - c1[1] - c1[2] - epsilon * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Combination–Combination Phase Synchronisation among Non-Identical Fractional Order Complex Chaotic Systems via Nonlinear Control - 1
	Vijay K. Yadav, Ghanshyam Prasad, Mayank Srivastava and Subir Das 17 April 2018
	https://www.researchgate.net/requests/r52624565
***************************************************************************/

int	DoCombinationCombinationPhaseSynchronisation(void)

    {
    double	i, c1[5], cn[5], a11, a12, a13;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v

    a11 = param[0];
    a12 = param[1];
    a13 = param[2];
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a11 * (c1[2] - c1[0]);
	cn[1] = a11 * (c1[3] - c1[1]);
	cn[2] = a12 * c1[0] - c1[2] - c1[0] * c1[4];
	cn[3] = a12 * c1[1] - c1[3] - c1[1] * c1[4];
	cn[4] = c1[0] * c1[2] + c1[1] * c1[3] - a13 * c1[4];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Combination Hyperchaos Synchronisation of Complex Memristor Oscillator System
	Zhang Jin-E 29 May 2014
***************************************************************************/

int	DoCombinationHyperchaos(void)

    {
    double	i, c1[5], cn[5], a1, a2, a3, a4, a5, a6, a7;
    bool	subX;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// v
    c1[4] = param[14];	// w

    a1 = param[0];
    a2 = param[1];
    a3 = param[2];
    a4 = param[3];
    a5 = param[4];
    a6 = param[5];
    a7 = param[6];
    subX = (param[7] != 0.0);
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a1 * c1[2] - a2 * c1[0] - a3 * c1[0] * c1[4] * c1[4];
	cn[1] = -a4 * c1[2] + a4 * c1[3];
	cn[2] = a5 * c1[1] - a5 * c1[0] - a6 * c1[2] - (subX ? c1[0] : 0.0);
	// the same program we have,
	// in ManpWIN with the name "Combination Hyperchaos...."
	// but now I subtracted 'x' in the above equation,
	// changing ALL THE IMAGES FROM THAT PREVIOUS PROGRAM
	cn[3] = -a7 * c1[1];
	cn[4] = c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Combination Synchronisation of Three Nonidentical Ecological Systems with Species Invasion 3D Version
	Xu Weigang, Yu Yilei and Wang Henian 17 April 2019
	https://www.hindawi.com/journals/mpe/2019/8591823/
***************************************************************************/

int	DoCombinationSynchronisation3NonidenticalEcologicalSystems3D(void)

    {
    double	i, c1[3], cn[3], w11, w12, w13, w14, w15, w16, w17, w18, w19;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    w11 = param[0];
    w12 = param[1];
    w13 = param[2];
    w14 = param[3];
    w15 = param[4];
    w16 = param[5];
    w17 = param[6];
    w18 = param[7];
    w19 = param[8];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] * (1 - c1[0]) - c1[0] * c1[1] / (c1[0] + w11);
	cn[1] = w12 * c1[0] * c1[1] / (c1[0] + w13) - c1[1] * c1[2] / (w14 * c1[2] + c1[1] + w15) - w16 * c1[1];
	cn[2] = w17 * c1[2] * c1[2] - w18 * c1[2] * c1[2] / (c1[1] + w19);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Combination Synchronisation of Three Nonidentical Ecological Systems with Species Invasion 4D Version
	Xu Weigang, Yu Yilei and Wang Henian 17 April 2019
	https://www.hindawi.com/journals/mpe/2019/8591823/
***************************************************************************/

int	DoCombinationSynchronisation3NonidenticalEcologicalSystems4D(void)

    {
    double	i, c1[4], cn[4], w11, w12, w13, w14, w15, w16, w17, w18, w19;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    w11 = param[0];
    w12 = param[1];
    w13 = param[2];
    w14 = param[3];
    w15 = param[4];
    w16 = param[5];
    w17 = param[6];
    w18 = param[7];
    w19 = param[8];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] * (1 - c1[0]) - w11 * c1[0] * c1[1] / (1 + w12 * c1[0]);
	cn[1] = w11 * c1[0] * c1[1] / (1 + w12 * c1[0]) - w13 * c1[1] * c1[2] / (1 + w14 * c1[1]) - w15 * c1[1] * c1[3] / (1 + w16 * c1[1]) - w17 * c1[1];
	cn[2] = w13 * c1[1] * c1[2] / (1 + w14 * c1[1]) - w18 * c1[2];
	cn[3] = w15 * c1[1] * c1[3] / (1 + w16 * c1[1]) - w19 * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Complex Behaviours of a Novel Three Dimensional Autonomous System
	The analysis of complex behaviours of a novel three dimensional autonomous system
	Dong Gao-Gao, Zheng Song, Tian Li-Xin, Du Rui-Jin and Sun Mei 25 January 2010
***************************************************************************/

int	DoComplexBehaviours(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e, f, g, h;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];
    h = param[7];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] * c1[2] - b * c1[0] + c * c1[1] * c1[2];
	cn[1] = c1[2] + d * c1[1] - e * c1[0] * c1[2];
	cn[2] = f * c1[0] * c1[1] - g * c1[2] - h * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Complex Dynamics, Hidden Attractors and Continuous Approximation of a Fractional-Order Hyperchaotic PWC System
	Marius-F. Danca, M. Feckan, Nikolay V. Kuznetsov and Guanrong Chen 2018
	https://arxiv.org/pdf/1804.10774.pdf
***************************************************************************/

int	DoComplexDynamicsHiddenAttractors(void)

    {
    double	i, c1[4], cn[4], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[0] + c1[1];
	cn[1] = -c1[2] * fabs(c1[0]) / c1[0] + c1[3];
	cn[2] = fabs(c1[0]) - a;
	cn[3] = -b * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Complex Dynamics in a Memristive Diode Bridge-Based MLC Circuit: Coexisting Attractors and Double-Transient Chaos -Second Version
	A. Chithra, T. Fonzin Fozin, K. Srinivasan, E. R. Mache Kengne, A. Tchagna Kouanou and I. Raja Mohamed - March 2021
	https://www.researchgate.net/publication/350280276_Complex_Dynamics_in_a_Memristive_Diode_Bridge-Based_MLC_Circuit_Coexisting_Attractors_and_Double-Transient_Chaos
***************************************************************************/

int	DoComplexDynamicsMemristiveDiodeBridge(void)

    {
    double	i, c1[3], cn[3], a1, a2, b, c, e, f, w;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a1 = param[0];
    a2 = param[1];
    b = param[2];
    c = param[3];
    e = param[4];
    f = param[5];
    w = param[6];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a1 * c1[0] + c1[1] - c * exp(-c1[2]) * sinh(c1[0]);
	cn[1] = b * (f * sin(w * i) - c1[1] - c1[0]);
	cn[2] = e * (c * exp(-c1[2]) - cosh(c1[0]) - a2 * c1[2] - c);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Complex System and Its AntiSynchronisation
	A New Fractional-Order Chaotic Complex System and Its AntiSynchronisation
	Cuimei Jiang, Shutang Liu, and Chao Luo  & Marcus Rezende 20 October 2014
***************************************************************************/

int	DoComplexSystem(void)

    {
    double	i, c1[5], cn[5], a1, a2, a3;

    c1[0] = param[10];	// x1
    c1[1] = param[11];	// x2
    c1[2] = param[12];	// x3
    c1[3] = param[13];	// x4
    c1[4] = param[14];	// x5

    a1 = param[0];
    a2 = param[1];
    a3 = param[2];
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a1 * (c1[2] - c1[0]);
	cn[1] = a1 * (c1[3] - c1[1]);
	cn[2] = -c1[0] * c1[4] + a2 * c1[2];
	cn[3] = -c1[1] * c1[4] + a2 * c1[3];
	cn[4] = c1[0] * c1[2] + c1[1] * c1[3] - a3 * c1[4];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Compound Lorenz + Chen + Lu chaotic attractors Images
	DESIGN AND IMPLEMENTATION OF COMPOUND CHAOTIC ATTRACTORS
	CHAOXIA ZHANG, SIMIN YU, GUANRONG CHEN February 15, 2011
***************************************************************************/

int	DoCompoundLorenzChenLu(void)

    {
    double	i, c[3], cn[3], a1, b1, c1, a2, b2, c2, a3, b3, c3, k1, k2, k3, z1, z2, z3, s1, s2, s3;

    c[0] = param[10];	// x
    c[1] = param[11];	// y
    c[2] = param[12];	// z

    a1 = param[0];					// Lorenz system
    b1 = param[1];
    c1 = param[2];
    a2 = param[3];					// Chen system
    b2 = param[4];
    c2 = param[5];
    a3 = param[6];					// Lu system
    b3 = param[7];
    c3 = param[8];
    k1 = 1.0 / 38.0; k2 = 1.0 / 36.0; k3 = 1.0 / 30.0;	// auxiliary data for the three of them
    z1 = -0.75; z2 = 0.14; z3 = -1.65;			// translation factor for the three of them

    totpasses = 10;

    InitOscillator(c, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	s1 = 0.5 * (fabs(c[2] + 0.5) / (c[2] + 0.5) - fabs(c[2] - 0.5) / (c[2] - 0.5));
	s2 = 0.5 * (1.0 + fabs(c[2] - 0.5) / (c[2] - 0.5));
	s3 = 0.5 * (1.0 - fabs(c[2] + 0.5) / (c[2] + 0.5));
	cn[0] = a1 * (c[1] - c[0]) * s1 + a2 * (c[1] - c[0]) * s2 + a3 * (c[1] - c[0]) * s3;
	cn[1] = (b1 * c[0] - c[0] * (c[2] - z1) / k1 - c[1]) * s1 + ((c2 - a2) * c[0] + c2 * c[1] 
					- c[0] * (c[2] - z2) / k2) * s2 + (-c[0] * (c[2] - z3) / k3 + c3 * c[1]) * s3;
	cn[2] = (c[0] * c[1] / k1 - c1 * (c[2] - z1)) * s1 + (c[0] * c[1] / k2 - b2 * (c[2] - z2)) * s2 
					+ (c[0] * c[1] / k3 - b3 * (c[2] - z3)) * s3;
	if (DisplayOscillator(c, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Compound Lorenz + Chen + L + SM + Rucklidge and Piecewise-Lorenz Chaotic Attractors Images
	DESIGN AND IMPLEMENTATION OF COMPOUND CHAOTIC ATTRACTORS
	CHAOXIA ZHANG, SIMIN YU, GUANRONG CHEN February 15, 2011
***************************************************************************/

int	DoCompoundLorenzChenLSMRucklidge(void)

    {
    double	i, c[3], cn[3], a1, b1, c1, a2, b2, c2, a3, b3, c3, a4, b4, c4, a5, b5, a6, b6;
    double	k1, k2, k3, k5, k6, z1, z2, z3, z4, z5, z6, s1, s2, s3, s4, s5, s6;

    c[0] = param[10];	// x
    c[1] = param[11];	// y
    c[2] = param[12];	// z

    a1 = param[0];					// Lorenz system
    b1 = param[1];
    c1 = param[2];
    a2 = param[3];					// Chen system
    b2 = param[4];
    c2 = param[5];
    a3 = param[6];					// L system
    b3 = param[7];
    c3 = param[8];
    a4 = 0.5; b4 = 2.5; c4 = 0.2;			// SM system
    a5 = 2.0; b5 = 7.7;					// Rucklidge system
    a6 = 0.8; b6 = 0.4;					// Piece-wise Lorenz system
    k1 = 1.0 / 38.0; k2 = 1.0 / 36.0; k3 = 1.0 / 30.0;	// auxiliary data for the three of them
    k5 = 1.0 / 8.0; k6 = 0.5; 
    z1 = -0.75; z2 = 0.14; z3 = -1.65;			// translation factor for the three of them
    z4 = -2.42; z5 = 1.8; z6 = 1.0; 

    totpasses = 10;

    InitOscillator(c, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	s1 = 0.5 * (fabs(c[2] + 0.5) / (c[2] + 0.5) - fabs(c[2] - 0.5) / (c[2] - 0.5));
	s2 = 0.5 * (fabs(c[2] - 0.5) / (c[2] - 0.5) - fabs(c[2] - 1.1) / (c[2] - 1.1));
	s3 = 0.5 * (fabs(c[2] + 1.5) / (c[2] + 1.5) - fabs(c[2] + 0.5) / (c[2] + 0.5));
	s4 = 0.5 * (1.0 - fabs(c[2] + 1.5) / (c[2] + 1.5));
	s5 = 0.5 * (1.0 + fabs(c[2] - 2.18) / (c[2] - 2.18));
	s6 = 0.5 * (fabs(c[2] - 1.1) / (c[2] - 1.1) - fabs(c[2] - 2.18) / (c[2] - 2.18));

	cn[0] = a1 * (c[1] - c[0]) * s1 + a2 * (c[1] - c[0]) * s2 + a3 * (c[1] - c[0]) * s3 
		+ a4 * (c[1] - c[0]) * s4 + c[1] * s5 + c[1] * s6;
	cn[1] = (b1 * c[0] - c[0] * (c[2] - z1) / k1 - c[1]) * s1 + ((c2 - a2) * c[0] 
		+ c2 * c[1] - c[0] * (c[2] - z2) / k2) * s2 + (-c[0] * (c[2] - z3) / k3 
		+ c3 * c[1]) * s3 + (-fabs(c[0]) / c[0] * (c[2] - z4)) * s4 + (-a5 * c[1] 
		+ b5 * c[0] - c[0] * (c[2] - z5) / k5) * s5 + (c[0] - a6 * c[1] 
		- c[0] * (c[2] - z6) / k6) * s6;
	cn[2] = (c[0] * c[1] / k1 - c1 * (c[2] - z1)) * s1 + (c[0] * c[1] / k2 
		- b2 * (c[2] - z2)) * s2 + (c[0] * c[1] / k3 - b3 * (c[2] - z3)) * s3 
		+ (b4 * c[0] - c4) * s4 + (-(c[2] - z5) + c[0] * c[0] / k5) * s5 
		+ (-b6 * (c[2] - z6) + c[0] * c[0] / k6) * s6;
	if (DisplayOscillator(c, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Computer Assisted Proof of the Existence of the Lorenz Attractor in the Shimizu-Morioka System
	Maciej J. Capinski, Dmitry Turaev and Piotr Zgliczynski November 29, 2017
***************************************************************************/

int	DoComputerAssistedProof(void)

    {
    double	i, c1[3], cn[3], alpha, lambda;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alpha = param[0];
    lambda = param[1];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = (1.0 - c1[2]) * c1[0] - lambda * c1[1];
	cn[2] = -alpha * c1[2] + c1[0] * c1[0];
									// subtracted 'z' from the exponent above - this operation changed images a lot
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Connecting the Kuramoto Model and the Chimera State-II
	Tejas Kotwal, Xin Jiang and Daniel M. Abrams 11 Jan 2018
***************************************************************************/

int	DoConnectingKuramotoModel(void)

    {
    double	i, c1[3], cn[3], mu, ni, d, alpha, beta;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    mu = param[0];
    ni = param[1];
    d = param[2];
    beta = param[3];
    alpha = -PI / 2.0 + beta;
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = ((1.0 + c1[1] * c1[1]) / 2.0 / c1[1]) * (mu * c1[1] * sin(alpha) - ni * c1[2] * sin(c1[0] - alpha))
	    - ((1.0 + c1[2] * c1[2]) / 2.0 / c1[2] * (mu * c1[2] * sin(alpha) + ni * c1[1] * sin(c1[0] + alpha)));
	cn[1] = -d * c1[1] + ((1.0 - c1[1] * c1[1]) / 2.0) * (mu * c1[1] * cos(alpha) + ni * c1[2] * cos(c1[0] - alpha));
	cn[2] = -d * c1[2] + ((1.0 - c1[2] * c1[2]) / 2.0) * (mu * c1[2] * cos(alpha) + ni * c1[1] * cos(c1[0] + alpha));
	// subtracted 'z' from the exponent above - this operation changed images a lot
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Constructing a Chaotic System with any Number of Equilibria – 2 Equilibria
	Xiong Wang and Guanrong Chen 27 Jan 2012
	https://www.researchgate.net/publication/221660181
***************************************************************************/

int	DoConstructingChaoticSystem2Equilibria(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 0.5 * (c1[2] + 2 * c1[1] * c1[0] * c1[0] * c1[2] + a * c1[0] - 4 * c1[0] * c1[0] * c1[2] + 4 * c1[2] * c1[2] * c1[2]) / (c1[0] * c1[0] + c1[2] * c1[2]);
	cn[1] = sqr(c1[0] * c1[0] - c1[2] * c1[2]) - c1[1];
	cn[2] = -0.5 * (2 * c1[1] * c1[0] * c1[2] * c1[2] + a * c1[2] - 4 * c1[0] * c1[2] * c1[2] - c1[0] + 4 * c1[0] * c1[0] * c1[0]) / (c1[0] * c1[0] + c1[2] * c1[2]);
	// subtracted 'z' from the exponent above - this operation changed images a lot
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Constructing a Chaotic System with any Number of Equilibria – 3 Equilibria
	Xiong Wang and Guanrong Chen 27 Jan 2012
	https://www.researchgate.net/publication/221660181
***************************************************************************/

int	DoConstructingChaoticSystem3Equilibria(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 1.0 / 3.0 * (3 * c1[0] * c1[0] * c1[0] * c1[0] * c1[1] * c1[2] - 4 * c1[0] * c1[0] * c1[2] * c1[2] * c1[2] * c1[1] + c1[0] * c1[0] * a - 8 * c1[0] * c1[0] * c1[0] * c1[0] * c1[2] + 2 * c1[0] * c1[2] + 24 
	    * c1[0] * c1[0] * c1[2] * c1[2] * c1[2] + c1[2] * c1[2] * c1[2] * c1[2] * c1[2] * c1[1] - c1[2] * c1[2] * a) / (2 * c1[0] * c1[0] * c1[2] * c1[2] + c1[0] * c1[0] * c1[0] * c1[0] + c1[2] * c1[2] * c1[2] * c1[2]);
	cn[1] = sqr(c1[0] * c1[0] * c1[0] - 3 * c1[0] * c1[2] * c1[2]) - c1[1];
	cn[2] = -1.0 / 3.0 * (6 * c1[2] * c1[2] * c1[0] * c1[0] * c1[0] * c1[1] - 2 * c1[2] * c1[2] * c1[2] * c1[2] * c1[0] * c1[1] + 2 * c1[2] * c1[0] * a + 4 * c1[0] * c1[0] * c1[0] * c1[0] * c1[0] - c1[0] * c1[0] - 16 
	    * c1[2] * c1[2] * c1[0] * c1[0] * c1[0] + c1[2] * c1[2] + 12 * c1[2] * c1[2] * c1[2] * c1[2] * c1[0]) / (2 * c1[0] * c1[0] * c1[2] * c1[2] + c1[0] * c1[0] * c1[0] * c1[0] + c1[2] * c1[2] * c1[2] * c1[2]);
	// subtracted 'z' from the exponent above - this operation changed images a lot
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Constructing Chaotic Repellors
	Chunbiao Li, Zhenyu Gu, Zuohua Liu, Sajad Jafari and Tomasz Kapitaniak Jan 2021
	https://www.researchgate.net/requests/r83325279
***************************************************************************/

int	DoConstructingChaoticRepellors(void)

    {
    double	i, c1[3], cn[3], k, fx;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    k = param[0];
    c1[0] = 1.0 + k * PI;
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	fx = 5 * c1[0] * sin(0.2 * c1[0]);
	cn[0] = c1[2] * c1[1];
	cn[1] = fx - c1[1];
	cn[2] = 1 - fx * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Constructing Infinitely Many Attractors in a Programmable Chaotic Circuit -System 4
	CHUNBIAO LI, WESLEY JOO-CHEN THIO, JULIEN CLINTON SPROTT, HERBERT H. C. IU AND YUJIE XU 18 April 2018
	https://www.researchgate.net/publication/324378905
***************************************************************************/

int	DoConstructingInfinitelyManyAttractors(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[2] + c;
	cn[1] = -c1[0] * c1[0] - c1[1];
	cn[2] = a + b * c1[0] + c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Constructing Multiwing Attractors from a Robust Chaotic System with Non-Hyperbolic Equilibrium Points
	Chunlai Li and Wenhua Hai 13 Sep 2018
	https://www.tandfonline.com/doi/full/10.1080/00051144.2018.1516273
***************************************************************************/

int	DoConstructingMultiwingAttractors(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 30.0 * c1[1] - 50.0 * c1[0];
	cn[1] = 350.0 / 3.0 * c1[0] * fabs(c1[2]) / c1[2] - 250.0 / 3.0 * c1[0] * c1[2];
	cn[2] = -16.0 + 14.4 * (1 - 3.6 * sin(18 * c1[1])) * c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Control of Multistability in a Self-Excited Memristive Hyperchaotic Oscillator
	T. Fonzin Fozin, R. Kengne, J. Kengne, K. Srinivasan, M. Souffo Tagueu and F. B. Pelap January 12, 2019
	https://www.researchgate.net/requests/r59602658 sent by T. Fonzin Fozin
***************************************************************************/

int	DoControlMultistability(void)

    {
    double	i, c1[5], cn[5], a1, a2, c, e1, e3, k11, k22, e2, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v

    a1 = param[0];
    a2 = param[1];
    c = param[2];
    e1 = param[3];
    e2 = param[4];
    e3 = param[5];
    k11 = param[6];
    k22 = param[7];
    e = exp(1.0);
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a1 * c1[0] - c1[1] - c * exp(c1[4]) * sinh(c1[0] - c1[2]);
	cn[1] = c1[0] - k11 * c1[1];
	cn[2] = e1 * (c * pow(e, -c1[4]) * sinh(c1[0] - c1[2]) - c1[3]);
	cn[3] = e2 * (c1[2] - k22 * c1[3]);
	cn[4] = e3 * (c * pow(e, -c1[4]) * cosh(c1[0] - c1[2]) - a2 * c1[4] - c);
	// subtracted 'z' from the exponent above - this operation changed images a lot
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Constructing, Analysing and Synchronising a Chaotic System with Equilibria of Rectangle Loop
	Wei Feng and Yigang He  May 2, 2018
	http://www.jsoftware.us/vol13/327-JSW15328.pdf
***************************************************************************/

int	DoConstructingAnalysingSynchronisingChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, r;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    r = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[1] - c1[2];
	cn[1] = c1[2] * (b * c1[0] - c * c1[1] - c1[2] * c1[2] + c1[0]);
	cn[2] = c1[0] + 1.5 * c1[1] * c1[1] * c1[1] - r - c1[2] * (d * c1[0] - c1[2]);
									// subtracted 'z' from the exponent above - this operation changed images a lot
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Constructing Chaotic System With Multiple Coexisting Attractors
	QIANG LAI, CHAOYANG CHEN, XIAO-WEN ZHAO, JACQUES KENGNE and CHRISTOS VOLOS February 15, 2019
	Accepted paper sent by QIANG LAI
***************************************************************************/

int	DoConstructingChaoticSystemWithMultipleCoexistingAttractors(void)

    {
    double	i, c1[4], cn[4], a, b, c, L, k;

    a = param[0];
    b = param[1];
    c = param[2];
    L = param[3];
    k = param[4];
    totpasses = 10;

    c1[0] = 1 + 2 * k * PI;	// x
    c1[1] = 1 + 2 * L * PI;	// y
    c1[2] = param[12];		// z
    c1[3] = param[13];		// w

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - fabs(c1[1]) / c1[1] - c1[0] + fabs(c1[0]) / c1[0]);
	cn[1] = b * (c1[1] - fabs(c1[1]) / c1[1]) - 60 * (c1[0] + fabs(c1[0]) / c1[0]) * c1[2] - c1[3];
	cn[2] = 60 * b * (c1[0] - fabs(c1[0]) / c1[0]) * (c1[1] - fabs(c1[1]) / c1[1]) - c * c1[2];
	cn[3] = 60 * (c1[1] - fabs(c1[1]) / c1[1]) * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Constructing Chaotic Systems with Total Amplitude Control-AB1
	Chunbiao Li, Julien Clinton Sprott, Zeshi Yuan and Hongtao Li February 27, 2015
	https://www.semanticscholar.org/paper/Constructing-Chaotic-Systems-with-Total-Amplitude-Li-Sprott/1519139b404700eccf24bd56c9bcdfd5fcea78fb
***************************************************************************/

int	DoConstructingChaoticSystems(int kind)

    {
    double	i, c1[3], cn[3], m, a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    m = param[0];
    a = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	switch (kind)
	    {
	    case 1:
		cn[0] = c1[2] * fabs(c1[1]) / c1[1];
		cn[1] = c1[0] - c1[1];
		cn[2] = m - a * c1[1] * fabs(c1[0]) / c1[0];
		break;
	    case 5:
		cn[0] = c1[2] * c1[1];
		cn[1] = c1[0] * fabs(c1[0]) - c1[1] * fabs(c1[1]);
		cn[2] = m * fabs(c1[0]) - a * c1[0] * c1[1];
		break;
	    }

	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

int	DoConstructingChaoticSystemsAB1(void)
    {
    return DoConstructingChaoticSystems(1);
    }

int	DoConstructingChaoticSystemsAB5(void)
    {
    return DoConstructingChaoticSystems(5);
    }


/**************************************************************************
	Control Aspects of a Theoretical Model for Epileptic Seizures Images
	KOSTAS TSAKALIS. and LEON IASEMIDIS
	Simin Yu, Jinhu Lu, Guanrong Chen April 10, 2005
***************************************************************************/

int	DoEpilepticSeizures(void)

    {
    double	i, c1[3], cn[3], alpha, beta, gamma, w, b, e1, e2, x0, u1;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alpha = param[0];
    beta = param[1];
    gamma = param[2];
    w = param[3];
    b = param[4];
    e1 = param[5];
    e2 = param[6];
    u1 = param[7];

    x0 = c1[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -w * c1[1] - c1[2] + b + (e1 * c1[0] - e2 * x0) + u1;
	cn[1] = w * c1[0] + alpha * c1[1];
	cn[2] = beta * c1[0] + c1[2] * (c1[0] - gamma);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Control and Synchronisation of a Novel Seven-Dimensional Hyperchaotic System with Active Control
	METIN VARAN and AKIF AKGUL 14 November 2017
	Sent to manpWIN by AKIF AKGUL through https://www.researchgate.net/requests/r44317962
***************************************************************************/

int	DoControlSynchronisation7DHyperchaoticSystem(void)

    {
    double	i, c1[7], cn[7], a, b, c, d, e, f, g, h;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w
    c1[6] = param[16];	// r

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];
    h = param[7];
    totpasses = 10;

    InitOscillator(c1, 7);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[0] + a * c1[4] - b * c1[4] * c1[5] * c1[6];
	cn[1] = -c * c1[1] - d * c1[5] + c1[0] * c1[5] * c1[6];
	cn[2] = -a * c1[2] + a * c1[4] - g * c1[0] * c1[1] * c1[6];
	cn[3] = -a * c1[3] + e * c1[0] + c1[0] * c1[1] * c1[2];
	cn[4] = -a * c1[4] + e * c1[6] - c1[1] * c1[2] * c1[3];
	cn[5] = -e * c1[5] + e * c1[4] + c1[2] * c1[3] * c1[4];
	cn[6] = -b * c1[6] + f * c1[1] - h * c1[3] * c1[4] * c1[5];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 7, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Control of a Simple Chaotic Flow Having a Line Equilibrium by Means of a Single Passive Controller
	Yilmaz Uyaroglu and Ugur Erkin Kocamaz 2015
	http://www.cmsim.eu/papers_pdf/october_2015_papers/27_CMSIM_Journal_Kocamaz_1_2015_4_277-288.pdf
***************************************************************************/

int	DoControlSimpleChaoticFlow(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2];
	cn[1] = -a * c1[1] - c1[0] * c1[2];
	cn[2] = c1[2] - b * c1[2] * c1[2] + c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Control of New 3D Chaotic System
	MasoudTaleb Ziabari and Ali Reza Sahab February 2014
***************************************************************************/

int	DoControlNew3DChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[0] - a * c1[1] + c1[1] * c1[2] - sin(c1[0] + c1[1] + c1[2]);
	cn[1] = b * c1[1] - c1[0] * c1[2];
	cn[2] = -c * c1[2] + c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Controlling a Chaotic Resonator by Means of Dynamic Track Control
	hunni Wang, Runtong Chu and Jun Ma July 2014
	https://www.researchgate.net/publication/263701488_Controlling_a_chaotic_resonator_by_means_of_dynamic_track_control
***************************************************************************/

int	DoControllingChaoticResonator(void)

    {
    double	t, c1[3], cn[3], i, bc, bl, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    i = param[0];
    bc = param[1];
    bl = param[2];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	g = (fabs(c1[1]) > 2.9) ? 0.366 : 0.061;
	cn[0] = c1[1];
	cn[1] = (i - g * c1[1] - sin(c1[0]) - c1[2]) / bc;
	cn[2] = (c1[1] - c1[2]) / bl;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 25.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Controlling Extreme Multistability of Memristor Emulator-Based Dynamical Circuit in Flux-Charge Domain
	Mo Chen, Mengxia Sun, Bocheng Bao, Huagan Wu, Quan Xu and Jiang Wang 16 November 2017
	https://www.researchgate.net/publication/321296886
***************************************************************************/

int	DoControllingExtremeMultistability(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e, f, g, h, x9, n0;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];
    n0 = param[7];
    x9 = param[8];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	h = 0.3214 * c1[0] * c1[0] * c1[0] - 0.3214 * n0 * c1[0] * c1[0] + 0.1071 * n0 * n0 * c1[0] - 0.0714 * x9;
	cn[0] = -20.0 * h + 20.0 * c1[1];
	cn[1] = -0.05 * c1[0] + 0.8 * c1[1] - 0.15 * c1[2];
	cn[2] = -1.05 * c1[0] + 16.8 * c1[1] - 0.3 * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Controlling Hyperchaotic nXm-Scroll Attractors
	Guo-Ping Jiang, Wallace Kit-Sang Tang and Guanrong Chen  October 18-21, 2005
***************************************************************************/

int	DoControllingHyperchaotic(void)

    {
    double	i, c[6], cn[6], alpha, beta, m1, m2, a, b, c1, c2, d1, d2, n, f1, f2, k;

    c[0] = param[10];	// x
    c[1] = param[11];	// y
    c[2] = param[12];	// z
    c[3] = param[13];	// u
    c[4] = param[14];	// v
    c[5] = param[15];	// w

    alpha = param[0];
    beta = param[1];
    m1 = param[2];
    m2 = param[3];
    a = param[4];
    b = param[5];
    c1 = param[6];
    d1 = param[7];
    c2 = param[8];
    d2 = param[9];

    totpasses = 10;

    InitOscillator(c, 6);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	k = b * PI / 2.0 / a;
	n = 2.0 * a * c1;
	f1 = (c[0] >= n) ? k * (c[0] - n) : ((c[0] <= -n) ? k * (c[0] + n) : -b * sin(PI * c[0] / 2.0 / a + d1));
	cn[0] = alpha * (c[1] - f1);
	cn[1] = c[0] - c[1] + c[2] + m1 * (c[4] - c[1]);
	cn[2] = -beta * c[1];
	n = 2.0 * a * c2;
	f2 = (c[3] >= n) ? k * (c[3] - n) : ((c[0] <= -n) ? k * (c[3] + n) : -b * sin(PI * c[3] / 2.0 / a + d2));
	cn[3] = alpha * (c[4] - f2);
	cn[4] = c[3] - c[4] + c[5] + m2 * (c[1] - c[4]);
	cn[5] = -beta * c[4];
	if (DisplayOscillator(c, cn, dt, ((DWORD)(i / 60.0) % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Controlled Predator-Prey  Model Images
	Dynamic Analysis of an Impulsively Controlled Predator-Prey Model with
	Holling Type IV Functional Response Yanzhen Wang1 and Min Zhao 3 October 2011
***************************************************************************/

int	DoControlledPredatorPrey(void)

    {
    double	i, c1[3], cn[3], a, b, C1, c2, c3, c4, c5, c6, d1, d2, e1, e2, e3;

    c1[0] = param[10];	// x1
    c1[1] = param[11];	// x2
    c1[2] = param[12];	// x3

    e1 = 0.56;
    e2 = 0.62;
    e3 = 0.0;

    a = param[0];
    b = param[1];
    C1 = param[2];
    c2 = param[3];
    c3 = param[4];
    c4 = param[5];
    c5 = param[6];
    c6 = param[7];
    d1 = param[8];
    d2 = param[9];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = (c1[0] * (a - b * c1[0]) - C1 * c1[0] * c1[1] / (1.0 + e1 * c1[0] * c1[0]) - c5 * c1[0] * c1[2] / (1.0 + e3 * c1[0] * c1[0])) / 8.0;
	cn[1] = c2 * c1[0] * c1[1] / (1.0 + e1 * c1[0] * c1[0]) - c3 * c1[1] * c1[2] / (1.0 + e2 * c1[1] * c1[1]) - d1 * c1[1];
	cn[2] = (c4 * c1[1] * c1[2] / (1.0 + e2 * c1[1] * c1[1]) + c6 * c1[0] * c1[2] / (1.0 + e3 * c1[0] * c1[0]) - d2 * c1[2]) / 4.0;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Coronarian Artery Images
	Circuit Implementation of Coronary Artery Chaos Phenomenon and Optimal PID
	Synchronisation Controller Design Cheng-Yu Yeh, Jen Shiu, and Her-Terng Yau
	24 August 2012
***************************************************************************/

int	DoCoronarianArtery(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x1
    c1[1] = param[11];	// x2
    c1[2] = param[12];	// x3

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -0.15 * c1[0] - 1.7 * c1[1];
	cn[1] = 0.7475 * c1[0] - 0.455 * c1[1]  + .65 * c1[0] * c1[0] * c1[0] + 0.3 * cos(i);
	cn[2] = (c1[0] + c1[1]  + sqrt(fabs(c1[0] * c1[1] ))) / 3.0;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Cost Function Based on Gaussian Mixture
	Model for Parameter Estimation of a Chaotic Circuit with a Hidden Attractor
	Seng-Kin Lao, Yasser Shekofteh, Sajad Jafari, Julien Clinton Sprott August 10, 2013
***************************************************************************/

int	DoCostFunction(void)

    {
    double	i, c1[3], cn[3];


    c1[0] = param[10];
    c1[1] = param[11];
    c1[2] = param[12];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[2];
	cn[1] = -c1[0] - c1[2];
	cn[2] = 2.0 * c1[0] - 1.3 * c1[1] - 2.0 * c1[2] + c1[0] * c1[0] + c1[2] * c1[2] - c1[0] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Coullet Chaotic Oscillator Images
***************************************************************************/

int	DoCoullet(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = a * c1[0] + b * c1[1] + c * c1[2] + d * c1[0] * c1[0] * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	The Coupled Dynamics of Two Particles with Different Limit Sets
	C. Mulhern1, D. Hennig and A.D. Burbanks 24/MAY-2013
***************************************************************************/

int	DoCoupledDynamics(void)

    {
    double	i, c1[4], cn[4], gamma, h1, h2, omega, kappa;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    gamma = param[0];
    h1 = param[1];
    h2 = param[2];
    omega = param[3];
    kappa = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -gamma * c1[0] + h1 * sin(omega * i/* + TETAZERO*/) - kappa * (c1[0] - c1[2]);
//	cn[1] = -sin(2.0 * PI * c1[0]) - gamma * c1[0] + h1 * sin(omega * i/* + TETAZERO*/) - kappa * (c1[0] - c1[2]);
	cn[2] = c1[3];
	cn[3] = -gamma * c1[2] + h2 * sin(omega * i/* + TETAZERO*/) + kappa * (c1[0] - c1[2]);
//	cn[3] = -sin(2.0 * PI * c1[2]) - gamma * c1[2] + h2 * sin(omega * i/* + TETAZERO*/) + kappa * (c1[0] - c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Coupled Rossler Systems Images
	CHAOS-HYPERCHAOS TRANSITIONS IN COUPLED ROSSLER SYSTEMS
	S. YANCHUK, T. KAPITANIAK 27, september, 2001
***************************************************************************/

int	DoCoupledRossler(void)

    {
    double	i, c1[6], cn[6], a, b, c, d;

    c1[0] = param[10];	// x1
    c1[1] = param[11];	// x2
    c1[2] = param[12];	// x3
    c1[3] = param[13];	// y1
    c1[4] = param[14];	// y2
    c1[5] = param[15];	// y3

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 6);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[1] - c1[2];
	cn[1] = c1[0] + a * c1[1];
	cn[2] = b + c1[2] * (c1[0] - c) + d * (c1[5] - c1[2]);
	cn[3] = -c1[4] - c1[5];
	cn[4] = c1[3] + a * c1[4];
	cn[5] = b + c1[5] * (c1[3] - c) + d * (c1[5] - c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Coupled Systems with Hyperchaos and Quasiperiodicity
	Alexander P. Kuznetsov and Yuliya V. Sedova April 6, 2015
***************************************************************************/

int	DoCoupledSystems(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e, k, mu = 0.4, q = 0.0, r = 0.0, h = 0.0, p = 0.0;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    c = param[1];
    d = param[2];
    e = param[3];
    k = param[4];
    b = param[5];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + e * c1[1] * c1[2] + mu * (c1[0] - q);
	cn[1] = c * c1[0] - d * c1[0] * c1[2] + c1[1] + c1[3] + mu * (c1[1] - r);
	cn[2] = c1[0] * c1[1] - b * c1[2] + mu * (c1[2] - h);
	cn[3] = -k * c1[1] + mu * (c1[3] - p);
	q = a * (c1[1] - c1[0]) + e * c1[1] * c1[2] + mu * (c1[0] - q);
	r = c * c1[0] - d * c1[0] * c1[2] + c1[1] + c1[3] + mu * (c1[1] - r);
	h = c1[0] * c1[1] - b * c1[2] + mu * (c1[2] - h);
	p = -k * c1[1] + mu * (c1[3] - p);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Coupling of the Double-Well Duffing I
	Chaos Control for Coupling of the Double-Well Duffing System Based on Random Phase Disturbance
	Gang Wu • Longsuo Li • Xinrong Cong 16 October 2012
***************************************************************************/

int	DoCouplingDoubleWell(void)

    {
    double	i, c1[4], cn[4], a, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    k = param[1];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = (1.0 - 3.0 * c1[0] * c1[0] - k) * c1[0] - a * c1[1] + k * c1[2];
	cn[2] = c1[3];
	cn[3] = k * c1[0] + (1.0 - 3.0 * c1[2] * c1[2] - k) * c1[2] - a * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Coupling of the Double-Well Duffing II
	Chaos Control for Coupling of the Double-Well Duffing System Based on Random Phase Disturbance
	Gang Wu • Longsuo Li • Xinrong Cong 16 October 2012
***************************************************************************/

int	DoCouplingDoubleWell8D(void)

    {
    double	i, c1[8], cn[8], a, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w
    c1[4] = param[14];	// x1
    c1[5] = param[15];	// y1
    c1[6] = param[16];	// z1
    c1[7] = param[17];	// w1

    a = param[0];
    k = param[1];
    totpasses = 10;

    InitOscillator(c1, 8);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[4] = (c1[1] - c1[4]) / dt;
	cn[1] = (1.0 - 3.0 * c1[0] * c1[0] - k) * c1[0] - a * c1[1] + k * c1[2];
	cn[5] = ((1.0 - 3.0 * c1[0] * c1[0] - k) * c1[0] - a * c1[1] + k * c1[2] - c1[5]) / dt;
	cn[2] = c1[3];
	cn[6] = (c1[3] - c1[6]) / dt;
	cn[3] = k * c1[0] + (1.0 - 3.0 * c1[2] * c1[2] - k) * c1[2] - a * c1[3];
	cn[7] = (k * c1[0] + (1.0 - 3.0 * c1[2] * c1[2] - k) * c1[2] - a * c1[3] - c1[7]) / dt;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 8, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Crack Synchronisation of Chaotic Circuits Under Field Coupling
	Jun Ma, Fuqiang Wu, Ahmed Alsaedi and Jun Tang  22 April 2018
	All content following this page was uploaded by Jun Ma on 25 May 2018
***************************************************************************/

int	DoCrackSynchronisationChaoticCircuits(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] - c1[1];
	cn[1] = c * (c1[0] - c1[2]);
	cn[2] = d * (c1[1] - b * (exp(c1[2]) - 1.0));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Cracked beams Chaotic Oscillator Images
	Detection and Characterization of Cracks in 
	Beams via Chaotic Excitation and Statistical Analysis = 1 
	Chandresh Dubey and Vikram Kapila & Marcus 3 June 2011
***************************************************************************/

int	DoCrackedBeams(void)

    {
    double	i, c1[3], cn[3], d, k1, k2, f, w;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    d = param[0];
    k1 = param[1];
    k2 = param[2];
    f = param[3];
    w = param[4];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = f * cos(c1[2]) + k1 * c1[0] - k2 * c1[0] * c1[0] *c1[0] - d * c1[1];
	cn[2] = w * sin(c1[0]) / cos(c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Cryptanalysing and Improving a Novel Color Image Encryption Algorithm Using RT-Enhanced Chaotic Tent Maps
	CONGXU ZHU AND KEHUI SUN April 23, 2018.
	Sent to me by the second author
***************************************************************************/

/*
int	DoCryptanalysingNovelColorImageEncryption(void)

    {
    double	i, c1[3], cn[3], mu;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    mu = param[0];

    totpasses = 10;

    InitOscillator(c1, 1);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
        if (c1[0] < 0.5)
	    cn[0] = (4 - mu) * c1[0] * (1 - c1[0]) + mu / 2 * (1 - c1[0]);
	else
	    cn[0] = (4 - mu) * c1[0] * (1 - c1[0]) + mu / 2 * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 16.0) % threshold), i, 1, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }
*/

/**************************************************************************
	Crisis and Inverse Crisis Route to Chaos in a New 3-D Chaotic System with Saddle, Saddle Foci and Stable Node Foci Nature of Equilibria
	Jay Prakash Singh and B.K. Roy 30 September 2016
	Sent to me by the first author
***************************************************************************/

int	DoCrisisInverseCrisisRoute(void)

    {
    double	i, c1[3], cn[3], a, b, c, d,r, r0;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    r = param[4];
    r0 = param[5];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = (d - 1) * c1[1] - d * c1[0] - c1[2];
	cn[1] = (r + 1) * c1[0] - (1 - a) * c1[1] - c1[0] * c1[2];
	cn[2] = c1[0] * c1[1] - b * c1[2] + c1[2] * (c1[0] - c) + r0;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Cross Waves on Free Surface Images
	Chaos at Cross-waves in Fluid Free Surface
	Tatyana S. Krasnopolskaya,Viacheslav M. Spektor, Evgeniy D. Pechuk
	7-10 June 2014
***************************************************************************/

int	DoCrossWaves(void)

    {
    double	i, c1[4], cn[4], a, b, b1, b2, b3, b4, b5, b6, k, teta;
    DWORD	colour;

    c1[0] = param[10];	// p1
    c1[1] = param[11];	// q1
    c1[2] = param[12];	// p2
    c1[3] = param[13];	// q2

    k = param[0];
    a = param[1];
    b = param[2];
    b1 = param[3];
    b2 = param[4];
    b4 = param[5];
    b6 = param[6];
    colour = (DWORD)param[7];

    b3 = 1.3 * k;
    b5 = 0.235 * k;
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	teta = b1 + b6 / 2.0 * (c1[0] * c1[0] + c1[1] * c1[1]);
	cn[0] = -a * c1[0] - teta * c1[1] + b3 * c1[1] + b * (c1[1] * c1[2] - c1[0] * c1[3]);
	cn[1] = -a * c1[1] + teta * c1[0] + b3 * c1[0] + b * (c1[0] * c1[2] + c1[1] * c1[3]);
	cn[2] = -a * c1[2] - b2 * c1[3] - 2.0 * b4 * c1[0] * c1[1];
	cn[3] = -a * c1[3] + b2 * c1[2] + b4 * (c1[0] * c1[0] - c1[1] * c1[1]) + b5;
	    if (DisplayOscillator(c1, cn, dt, (colour == 0L ? (DWORD)(i / 20.0) % threshold : colour), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Cryptanalysis and Improvement on an Image Encryption Algorithm Design Using a Novel Chaos Based S-Box
	Congxu Zhu, Guojun Wang and Kehui Sun 14 September 2018
	https://www.researchgate.net/publication/327663837_Cryptanalysis_and_Improvement_on_an_Image_Encryption_Algorithm_Design_Using_a_Novel_Chaos_Based_S-Box
***************************************************************************/

int	DoCryptanalysisImprovementImageEncryptionAlgorithm(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c * c1[1] - c1[0] - b * c1[2];
	cn[1] = a * c1[0] * c1[2] - c1[0] * c1[1] - b * c1[0];
	cn[2] = d * c1[0] * c1[1] + b;
	    if (DisplayOscillator(c1, cn, dt, (DWORD)(i / 20.0) % threshold, i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Cryptanalysis of a Chaotic Communication Scheme Using Parameter Observer
	Haipeng Peng, Yan Shao, Lixiang Li, Yixian Yang & Marcus Rezende 3 December 2009 / 11 June 2015
***************************************************************************/

int	DoCryptanalysis(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, emezao, m, beta, f = 2.0;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    b = param[0];
    c = param[1];
    d = param[2];
    emezao = param[3];
    m = param[4];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	a = 10.0 + 0.5 * sin(0.5 * i);
	beta = (f - m) / (emezao - m);
	f = 2.0 + 2.0 * sin(0.5 * i);
	cn[0] = (25.0 * beta + a) * (c1[1] - c1[0]);
	cn[1] = (b - 35.0 * beta) * c1[0] - c1[0] * c1[2] + (29.0 * beta - c) * c1[1];
	cn[2] = c1[0] * c1[1] - (beta + d) * c1[2] / 3.0;
	cn[3] = -d * c1[0] - emezao * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Cubic-Equilibrium Chaotic System with Coexisting Hidden Attractors: Analysis and Circuit Implementation
	Victor Kamdoum Tamba, Karthikeyan Rajagopa, Viet-Thanh Pham and Duy Vo Hoang 30 January 2018
***************************************************************************/

int	DoCubicEquilibriumChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[2];
	cn[1] = c1[0] * c1[2] * c1[2] + a * fabs(c1[2]) / c1[2];
	cn[2] = c1[0] - c1[1] * c1[1] * c1[1] + c1[2] * (b * c1[1] * c1[1] - c1[2] * c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Cubic Trigonometric Nonuniform Spline Curves 
	Lanlan Yan 11 January 2016
	https://www.hindawi.com/journals/mpe/2016/7067408/
***************************************************************************/

int	DoCubicTrigonometricNonuniformSplineCurves(void)

    {
    double	c1[3], cn[3], t, a;

    c1[0] = cn[0] = param[10];	// x
    c1[1] = cn[1] = param[11];	// y
    c1[2] = cn[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t += dt)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	cn[0] = (1 - sin(t)) * (1 - sin(t)) * (1 - a * sin(t));
	cn[1] = sin(t) * (1 - sin(t)) * (1 - sin(t)) * (2 + a * (1 - sin(t)));
	cn[2] = cos(t) * (1 - cos(t)) * (1 - cos(t)) * (2 + a * (1 - cos(t)));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)t % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dadras Chaotic Oscillator Images
***************************************************************************/

int	DoDadras(void)

    {
    double	i, c1[3], cn[3], p, q, r, s, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    p = param[0];
    q = param[1];
    r = param[2];
    s = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - p * c1[0] + q * c1[1] * c1[2];
	cn[1] = r * c1[1] - c1[0] * c1[2] + c1[2];
	cn[2] = s * c1[0] * c1[1] - e * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Damage Assessment Using Hyperchaotic Excitation and Nonlinear Prediction Error in 5 Dimensions
	S. TORKAMANI, E. A. BUTCHER, M. D. TODD and G. PARK & Marcus Rezende SEP 2011 & MAY-2015
***************************************************************************/

int	DoDamageAssessment5D(void)

    {
    double	i, c1[5], cn[5], b, d, r, s, k, delta;
    int		kind;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// v
    c1[4] = param[14];	// w

    s = param[0];
    r = param[1];
    b = param[2];
    d = param[3];
    k = param[4];
    delta = param[5];
    kind = (int)param[6];						// little Marcus alterations that actually produce nice images
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = (s * (c1[1] - c1[0]) + c1[3]) * delta;
	switch (kind)
	    {
	    case 0:
		cn[1] = (r * c1[0] - c1[1] - c1[0] * c1[2] - c1[4]) * sin(delta);
		cn[2] = (c1[0] * c1[1] - b * c1[2]) * cos(delta);
		break;
	    case 1:
	    case 2:
		cn[1] = (r * c1[0] - c1[1] - c1[0] * c1[2] - c1[4]) / sin(delta);
		cn[2] = (c1[0] * c1[1] - b * c1[2]) / cos(delta);
		break;
	    case 3:
		cn[1] = (r * c1[0] - c1[1] - c1[0] * c1[2] - c1[4]) / cos(delta);
		cn[2] = (c1[0] * c1[1] - b * c1[2]) / sin(delta);
		break;
	    }
	if (kind == 2 || kind == 3)
	    cn[3] = (d * c1[3] - c1[0] * c1[2]) + tan(delta);
	else
	    cn[3] = (d * c1[3] - c1[0] * c1[2]) * tan(delta);
	cn[4] = (k * c1[1]) * sqrt(delta);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Data Analysis Techniques for Nonlinear Dynamical Systems
	Massimo Camplani March 2010
***************************************************************************/

int	DoDataAnalysis(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[1] - c1[2];
	cn[1] = c1[0] + a * c1[1] + c1[3];
	cn[2] = c1[0] * c1[2] + b;
	cn[3] = -c * c1[2] + d * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Data Analysis Techniques for Nonlinear Dynamical Systems: Conjugate Pairs
	Massimo Camplani March 2010
***************************************************************************/

int	DoDataAnalysisCP(void)

    {
    double	i, c1[8], cn[8], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w
    c1[4] = param[14];	// x1
    c1[5] = param[15];	// y1
    c1[6] = param[16];	// z1
    c1[7] = param[17];	// w1

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 8);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[1] - c1[2];
	cn[4] = (-c1[1] - c1[2] - c1[4]) / dt;
	cn[1] = c1[0] + a * c1[1] + c1[3];
	cn[5] = (c1[0] + a * c1[1] + c1[3] - c1[5]) / dt;
	cn[2] = c1[0] * c1[2] + b;
	cn[6] = (c1[0] * c1[2] + b - c1[6]) / dt;
	cn[3] = -c * c1[2] + d * c1[3];
	cn[7] = (-c * c1[2] + d * c1[3] - c1[7]) / dt;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 8, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Data-Assisted Reduced-Order Modelling of Extreme Events in Complex Dynamical Systems
	Zhong Yi Wan, Pantelis R. Vlachas, Petros Koumoutsakos and Themistoklis P. Sapsis March 12, 2018
	https://arxiv.org/pdf/1803.03365.pdf
***************************************************************************/

int	DoDataAssistedReducedOrderModeling(void)

    {
    double	i, c1[6], cn[6], x01, x04, b, c, beta, gamma;
    double	m, alpha1, alpha2, beta1, beta2, delta1, delta2, gamma01, gamma02, gamma1, gamma2, epsilon, sqrt2 = sqrt(2.0);	// we need some weird constants

    // STUDY DIFFERENT VALUES TILL GET FAIR LOOKING SOMETHING. PAPER OMITS THEM.
    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w

    x01 = param[0];
    x04 = param[1];
    c = param[2];
    beta = param[3];
    gamma = param[4];
    b = param[5];
    totpasses = 10;

    // calculate some weird constants

    m = 1.0;
    alpha1 = 8.0 * sqrt2 * m * m * (b * b + m * m - 1.0) / PI / (4.0 * m * m - 1.0) / (b * b + m * m);
    beta1 = beta * b * b / (b * b + m * m);
    delta1 = 64.0 * (sqrt2 * b * b - m * m + 1.0) / 15.0 / PI / (b * b + m * m);
    gamma01 = gamma * 4.0 * sqrt2 * m * b / PI / (4.0 * m * m - 1.0);
    gamma1 = gamma * 4.0 * sqrt2 * m * m * m * b / PI / (4 * m * m - 1.0) / (b * b + m * m);
    m = 2.0;
    alpha2 = 8.0 * sqrt2 * m * m * (b * b + m * m - 1) / PI / (4.0 * m * m - 1.0) / (b * b + m * m);
    beta2 = beta * b * b / (b * b + m * m);
    delta2 = 64.0 * (sqrt2 * b * b - m * m + 1.0) / 15.0 / PI / (b * b + m * m);
    gamma02 = gamma * 4.0 * sqrt2 * m * b / PI / (4.0 * m * m - 1.0);
    epsilon = 16.0 * sqrt2 / 5.0 / PI;
    gamma2 = gamma * 4.0 * sqrt2 * m * m * m * b / PI / (4.0 * m * m - 1.0) / (b * b + m * m);

    InitOscillator(c1, 6);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = gamma01 * c1[2] - c * (c1[0] - x01);
	cn[1] = -(alpha1 * c1[0] - beta1) * c1[2] - c * c1[1] - delta1 * c1[3] * c1[5];
	cn[2] = (alpha1 * c1[0] - beta1) * c1[1] - gamma1 * c1[0] - c * c1[2] + delta1 * c1[3] * c1[4];
	cn[3] = gamma02 * c1[5] - c * (c1[3] - x04) + epsilon * (c1[1] * c1[5] - c1[2] * c1[4]);
	cn[4] = -(alpha2 * c1[0] - beta2) * c1[5] - c * c1[4] - delta2 * c1[3] * c1[2];
//	cn[5] = (alpha2 * c1[0] - beta2) * c1[4] - gamma2 * c1[3] - c * c1[5]/* + delat2 * c1[3] * c1[1]*/;	// naughty Marcus
	cn[5] = (alpha2 * c1[0] - beta2) * c1[4] - gamma2 * c1[3] - c * c1[5] + delta2 * c1[3] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Decomposition Method for Studying Smooth Chua’s Equation with Application to Hyperchaotic Multiscroll Attractors
	DONATO CAFAGNA and GIUSEPPE GRASSI March 30, 2006
***************************************************************************/

int	DoDecompositionMethod(void)

    {
    double	i, c1[3], cn[3], alpha, beta, gamma, k, a, b, h;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alpha = param[0];
    beta = param[1];
    gamma = param[2];
    k = param[3];
    a = param[4];
    b = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	h = a * c1[0] * c1[0] * c1[0] + b * c1[0];
	cn[0] = k * alpha * (c1[1] - c1[0] - h);
	cn[1] = k * (c1[0] - c1[1] + c1[2]);
	cn[2] = k * (-beta * c1[1] - gamma * c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Degenerate Hopf bifurcations, hidden attractors, and control in the extended Sprott E system with only one stable equilibrium
	Zhouchao WEI1; Irene MOROZ, Anping LIU 23.05.2014
***************************************************************************/

int	DoDegenerateHopfbifurcations(void)

    {
    double	i, c1[3], cn[3], f, g, e, h;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    f = param[0];
    g = param[1];
    e = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	h = e * c1[0] * c1[0] + f * c1[0] + g;
	cn[0] = c1[1] * c1[2] + h;
	cn[1] = c1[0] * c1[0] - c1[1];
	cn[2] = 1.0 - 4.0 * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 2) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Degenerating the Butterfly Attractor in a Plasma Perturbation Model using Nonlinear Controllers
	Hayder Natiqa, Santo Banerjee, A.P. Misra and M.R.M. Said 13 March 2019
	Received directly by one of the authors: Hayder Natiq Kadhim
***************************************************************************/

int	DoDegeneratingButterflyAttractor(void)

    {
    double	i, c1[3], cn[3], a, h, d, eta;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    h = param[1];
    d = param[2];
    eta = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] * (c1[2] - 1) - d * c1[0];
	cn[1] = c1[0];
	cn[2] = eta * (h - c1[2] - c1[1] * c1[1] * c1[2]) + a * cos(c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 2) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Depth-Two Heteroclinic Network Images
	A minimal system with a depth-two heteroclinic network
	Tsuyoshi Chawanyaa and Peter Ashwin 20 June 2010
***************************************************************************/

int	DoDepthTwoHeteroclinic(bool variety)

    {
    double	i, c1[3], cn[3], a, b, w;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    w = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = (1.0 - c1[0] * c1[0]) * ((1.0 - c1[2]) * (c1[0] - w * c1[1] * c1[1] * c1[1]) + (1.0 + c1[2]) * (-c1[0] - c1[0] * c1[0] * c1[0] + (2.0 + b + b) * c1[0] * c1[1] * c1[1]));
	cn[1] = (1.0 - c1[1] * c1[1]) * ((1.0 - c1[2]) * (-c1[1] + 2.0 * c1[0] * c1[0] * c1[1] + w * c1[0] * c1[0] * c1[0]) + (1.0 + c1[2]) * (-2.0 * c1[1]));
	if (variety)
	    cn[2] = (1.0 - c1[2] * c1[2]) * (1.0 + a * (1.0 + c1[2]) - 2.0 * (1.0 - c1[0] * c1[0]) * (1.0 - c1[1] * c1[1]));
	else
	    cn[2] = (1.0 - c1[0] * c1[0]) * (1.0 + a * (1.0 + c1[2]) - 2.0 * (1.0 - c1[0] * c1[0]) * (1.0 - c1[1] * c1[1]));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / ((variety) ? 150.0 : 10.0)) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

int	DoDepthTwoHeteroclinic1(void)
    {
    return DoDepthTwoHeteroclinic(false);
    }

int	DoDepthTwoHeteroclinic2(void)
    {
    return DoDepthTwoHeteroclinic(true);
    }

/**************************************************************************
	Dequan-Li Chaotic Oscillator Images
***************************************************************************/

int	DoDequanLi(void)

    {
    double	i, c1[3], cn[3], a, c, d, e, k, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    c = param[1];
    d = param[2];
    e = param[3];
    k = param[4];
    f = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + d * c1[0] * c1[2];
	cn[1] = k * c1[0] + f * c1[1] - c1[0] * c1[2];
	cn[2] = c * c1[2] + c1[0] * c1[1] - e * c1[0] * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Describing Chaotic Attractors: Regular and Perpetual Points - L. Ying & Alli Model
	Dawid Dudkowski, Awadhesh Prasad and Tomasz Kapitaniak 03 March 2018
	https://www.researchgate.net/publication/323506242_Describing_chaotic_attractors_Regular_and_perpetual_points
***************************************************************************/

int	DoDescribingChaoticAttractors(void)

    {
    double	i, c1[3], cn[3], a3, b1, b2, b3, omega, a0, a1;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a3 = param[0];
    b1 = param[1];
    b2 = param[2];
    b3 = param[3];
    omega = param[4];
    a0 = param[5];
    a1 = param[6];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -b1 * c1[0] - (a0 + a1 * cos(omega * i) + c1[2]) * c1[1];
	cn[1] = -b2 * (c1[1] + 1) + (a0 + a1 * cos(omega * i) + c1[2]) * c1[0];
	cn[2] = -b3 * c1[2] - a3 * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Design and Control of a Multi-Wing Dissipative Chaotic System
	Amin Zarei and Saeed Tavakoli 20 February 2017
	https://www.researchgate.net/requests/r44231954 or received directly from the author
***************************************************************************/

int	DoDesignControlMultiWingDissipativeChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] + d * c1[1] * c1[2] - c1[0] * c1[1] * c1[1];
	cn[1] = b * c1[1] + c1[0] * c1[2];
	cn[2] = c * c1[2] - c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Design and DSP Implementation of a Fractional-Order Detuned Laser Hyperchaotic Circuit with Applications in Image Encryption
	Xuejun Li, Jun Mou, Santo Banerjee, Zhisen Wang and Yinghong Cao - Accepted 17 April 2022
	Received from Jun Mou and sent to him 1-2 hours after receiving. You can download it from, (that’s a free papers place) 
	https://www.hindawi.com/journals/complexity/2019/4047957/
***************************************************************************/

int	DoDesignDSPImplementationFractionalOrderDetunedLaser(void)

    {
    double	i, c1[7], cn[7], l1, l2,l3, l4, l5, l6;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w
    c1[6] = param[16];	// r

    l1 = param[0];
    l2 = param[1];
    l3 = param[2];
    l4 = param[3];
    l5 = param[4];
    l6 = param[5];
    totpasses = 10;

    InitOscillator(c1, 7);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = l1 * (c1[2] - c1[0] - l2 * c1[1]);
	cn[1] = l1 * (c1[3] - c1[1] - l2 * c1[0]);
	cn[2] = (l3 - c1[4]) * c1[0] - c1[2] + l2 * c1[3];
	cn[3] = (l3 - c1[4]) * c1[1] - c1[3] - l2 * c1[2];
	cn[4] = -l4 * c1[4] + c1[0] * c1[2] + c1[1] * c1[3] + c1[5] - c1[6];
	cn[5] = l5 * c1[0] + l6 * c1[2];
	cn[6] = l5 * c1[1] + l6 * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 7, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Design and Implementation of a New Memristive Chaotic System with Application in Touchless Fingerprint Encryption
	Qiang Lai, Zhiqiang Wan, Akif Akgul, Omer Faruk Boyraz and Mustafa Zahid Yildiz - 01 september 2020
	https://www.researchgate.net/publication/343921090_Design_and_Implementation_of_a_New_Memristive_Chaotic_System_with_Application_in_Touchless_Fingerprint_Encryption#fullTextFileContent
***************************************************************************/

int	DoDesignImplementationNewMemristiveChaoticSystem(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];	// k
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	srand((unsigned)time(NULL) / 1000);					// Seed the random-number generator with current time 
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = b * c1[0] - c1[0] * c1[2] - d * c1[3] * (double)rand() / (RAND_MAX) * c1[3] * c1[0];
	cn[2] = -c * c1[2] + c1[0] * c1[0];
	cn[3] = c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Design and Processing of a Novel Chaos-Based Stepped Frequency Synthesised Wideband Radar Signal -Bernoulli
	Tao Zeng, Shaoqiang Chang, Huayu Fan and Quanhua Liu 26 March 2018
	http://www.mdpi.com/1424-8220/18/4/985
***************************************************************************/

int	DoDesignProcessingNovelChaosBased(void)

    {
    double	i, c1[3], cn[3], b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = 1.0;	// z

    b = param[0];
    totpasses = 10;

    InitOscillator(c1, 2);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	if (c1[0] >= -0.5 && c1[0] < -0.25)
	    cn[0] = b * c1[0] + 1.5;
	else if (c1[0] >= -0.25 && c1[0] < 0.0)
	    cn[0] = b * c1[0] + 0.5;
	else if (c1[0] >= 0.0 && c1[0] < 0.25)
	    cn[0] = -b * c1[0] + 1.5;
	else
	    cn[0] = -b * c1[0] + 0.5;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 2, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Design and Simulation of a Memristor Chaotic Circuit Based on Current Feedback Op Amp.
	Hong Qing-Hui, Li Zhi-Jun, Zeng Jin-Fang and Zeng Yi-Cheng 3 May 2014
	http://wulixb.iphy.ac.cn/EN/Y2014/V63/I18/184101
***************************************************************************/

int	DoDesignSimulationMemristorChaoticCircuit(void)

    {
    double	i, c1[4], cn[4], alpha, beta, k, gamma,a, b, ww;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    alpha = param[0];
    beta = param[1];
    k = param[2];
    gamma = param[3];
    a = param[4];
    b = param[5];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	ww = (fabs(c1[3]) < 1.0) ? a : b;
	cn[0] = alpha * (c1[1] - c1[0]) * ww;
	cn[1] = beta * ((c1[1] - c1[0]) * ww - c1[2]);
	cn[2] = k * (c1[1] - gamma * c1[2]);
	cn[3] = c1[1] - c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Design of an Interface for Random Number Generators based on Integer and Fractional Order Chaotic Systems - Labyrinth Chaotic System
	AKIF AKGUL, COSKUN ARSLAN, AND BURAK ARICIOGLU
	https://img1.wsimg.com/blobby/go/e7a73760-dc77-4345-b7f8-fa68124b57b5/downloads/Article%201.pdf?ver=1592837421051
	2019
***************************************************************************/

int	DoDesignInterfaceRandomNumberGenerators(void)

    {
    double	i, c1[3], cn[3], b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    b = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -sin(c1[1]) - b * c1[0];
	cn[1] = -sin(c1[2]) - b * c1[1];
	cn[2] = -sin(c1[0]) - b * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 50.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Design of Fixed Point-Based Dual Entropy Core Chaotic True Random Number Generator on FPGA
	Murat Alcin, Murat TUNA and Ismail Koyuncu April 2019
	https://www.researchgate.net/publication/333024344
***************************************************************************/

int	DoDesignFixedPointBasedDualEntropyCore(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - c1[0] - a * c1[2];
	cn[1] = c1[0] * c1[2] - c1[0];
	cn[2] = -c1[0] * c1[1] - c1[1] + b;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Design of Multi-Wing 3D Chaotic Systems with only Stable Equilibria or No Equilibrium Point using Rotation Symmetry  (System 11)
	Yan Yang, Lilian Huang, Jianhong Xiang, Han Bao and Houzhen Li 18 March 2021
	https://sci-hub.wf/10.1016/j.aeue.2021.153710
***************************************************************************/

int	DoDesignMultiWing3DChaoticSystems11(void)

    {
    double	i, c1[3], cn[3], a, xy2, yx2;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y

    a = param[0];
    c1[2] = -a;		// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	xy2 = sqr(c1[0]) - sqr(c1[1]);
	yx2 = sqr(c1[0]) + sqr(c1[1]);

	cn[0] = ((a * c1[0] + c1[1]) * xy2 - 2 * c1[0] * sqr(c1[1]) + 2 * sqr(c1[0]) * c1[1] * c1[2]) / 2 / yx2;
	cn[1] = ((c1[0] - a * c1[1]) * xy2 - 2 * sqr(c1[0]) * c1[1] - 2 * c1[0] * sqr(c1[1]) * c1[2]) / 2 / yx2;
	cn[2] = 1 - 2 * c1[0] * c1[1] * xy2;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Design of Multi-Wing 3D Chaotic Systems with only Stable Equilibria or No Equilibrium Point using Rotation Symmetry  (System 15)
	Yan Yang, Lilian Huang, Jianhong Xiang, Han Bao and Houzhen Li 18 March 2021
	https://sci-hub.wf/10.1016/j.aeue.2021.153710
***************************************************************************/

int	DoDesignMultiWing3DChaoticSystems15(void)

    {
    double	i, c1[3], cn[3], a, s1, s2, s3, s4;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y

    a = param[0];
    c1[2] = -a;		// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	s1 = cube(c1[0]) - 3 * c1[0] * sqr(c1[1]);
	s2 = 3 * sqr(c1[0]) * c1[1] - cube(c1[1]);
	s3 = sqr(c1[0]) + sqr(c1[1]);
	s4 = sqr(c1[0]) - sqr(c1[1]);

	cn[0] = ((a * s4 + 2 * c1[0] * c1[1]) * s1 + (c1[2] * s4 - 2 * c1[0] * c1[1]) * s2) / 3 / (s3 * s3);
	cn[1] = ((s4 - 2 * a * c1[0] * c1[1]) * s1 - (s4 + 2 * c1[0] * c1[1] * c1[2]) * s2) / 3 / (s3 * s3);
	cn[2] = 1 - s1 * s2;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Design of Multiwing-Multiscroll 3D Chaotic Systems using Rotation Symmetry - Equation 21
	WYan Yang, Lilian Huang, Jianhong Xiang, Han Bao and Houzhen Li 18 March 2021
	https://www.researchgate.net/publication/350183560_Design_of_multi-wing_3D_chaotic_systems_with_only_stable_equilibria_or_no_equilibrium_point_using_rotation_symmetry
***************************************************************************/

int	DoDesignMultiwingMultiscroll3DChaoticSystems(void)

    {
    double	i, c1[3], cn[3], a;
    //    int		j;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = (pow(c1[1], 5) + 2 * c1[0] * pow(c1[1], 4) * c1[2] + 2 * c1[0] * c1[0] * cube(c1[1]) - 6 * cube(c1[0]) * sqr(c1[1]) * c1[2] + pow(c1[0], 4) * c1[1]) / 3 / sqr(sqr(c1[0]) + sqr(c1[1]));
	cn[1] = (-pow(c1[0], 5) - 3 * pow(c1[0], 4) * c1[1] * c1[2] - 2 * cube(c1[0]) * sqr(c1[1]) + 4 * sqr(c1[0]) * cube(c1[1]) * c1[2] - c1[0] * pow(c1[1], 4) - pow(c1[1], 5) * c1[2]) / 3 / sqr(sqr(c1[0]) + sqr(c1[1]));
	cn[2] = (cube(c1[0]) - 3 * c1[0] * sqr(c1[1])) * (3 * sqr(c1[0]) * c1[1] - cube(c1[1])) + 0.5 * sqr(cube(c1[0]) - 3 * c1[0] * sqr(c1[1])) - a;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Design of Multiwing-Multiscroll Grid Compound Chaotic System and its Circuit Implementation
	Wei Ai, Kehui Sun and Yuanli Fu 14 June 2018
	Sent by the second author
	Jerk-Jerk-Lorenz-Lorenz
***************************************************************************/

int	DoDesignMultiwingMultiscrollGridCompoundChaoticSystem(void)

    {
    double	i, c1[3], cn[3], f, c, beta, p, l1, l2, l3, a1, a2, z0, f0, f1, f2, e1, s1, s2, g, s, k;
    //    int		j;

    c1[0] = param[10];	// x
   c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    c = param[0];
    beta = param[1];
    p = param[2];
    l1 = param[3];
    l2 = param[4];
    l3 = param[5];
    a1 = param[6];
    a2 = param[7];
    z0 = param[8];
    //    n = (int)param[9];
    f0 = param[9];
    f1 = -20.5;
    e1 = 0.2;
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	s1 = 0.5 * (1 + fabs(c1[2] - z0) / (c1[2] - z0));
	s2 = 0.5 * (1 - fabs(c1[2] - z0) / (c1[2] - z0));
	g = fabs(c1[0]) / c1[0] + fabs(c1[0] - 2) / (c1[0] - 2) + fabs(c1[0] + 2) / (c1[0] + 2);
	f1 = 0.5 * a1 * (1 + fabs(c1[2] - l1) / (c1[2] - l1));
	f2 = a2 * (1 + fabs(c1[2] - l2 - l3) / (c1[2] - l2 - l3));
	s = 0;
	k = 0.1 * c1[0];
	//	for (j = 1; j <= n; j++)
	//	    {
	//	    r = f[j] * (1 + 0.5 * (k - e[j]) - 0.5 * (k + e[j]));
	//	    s = s + r
	//	    }
	f = f0 * k * k - s;
	cn[0] = 100 * (c1[1] - 0.1 * c1[0]) * s1 + (c1[2] - f1) * s2;
	cn[1] = (0.1 * (24 - 4 * c) * c1[0] - 0.1 * p * c1[0] * (c1[2] - f2 - l1) + c * c1[1]) * s1 + (-c1[0] - (c1[2] - f1) - beta * c1[1] + g) * s2;
	cn[2] = (f - 8 / 3 * (c1[2] - f2 - l1)) * s1 + c1[1] * s2;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Designing Cryptosystems Based on Hyperchaos
	A System Theory Approach for Designing Cryptosystems Based on Hyperchaos
	Giuseppe Grassi and Saverio Mascolo SEPTEMBER 1999
***************************************************************************/

int	DoDesigningCryptosystems(void)

    {
    double	i, c1[4], cn[4], a, b, e, k, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    k = param[2];
    e = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	g = (c1[0] - c1[2] < -1.0) ? -0.2 + 3.0 * (c1[0] - c1[2] + 1.0) : ((c1[0] - c1[2] <= 1.0) ? -0.2 * (c1[0] - c1[2]) : -0.2 + 3.0 * (c1[0] - c1[2] - 1.0));
	cn[0] = -c1[1] - g - e;
	cn[1] = c1[0] + 0.7 * c1[1];
	cn[2] = -10.0 * c1[3] + 10 * g + 10.0 * e;
	cn[3] = 1.5 * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Detecting chaos in a complex system Images
	Boyan Hristozov Petkov 2013
***************************************************************************/

int	DoDetectingChaos(void)

    {
    double	i, c[7], cn[7], a, m, n, p, r, rm, c1, c2, c3, c4, c5, c6, c7;

    c[0] = param[10];	// x1
    c[1] = param[11];	// x2
    c[2] = param[12];	// x3
    c[3] = param[13];	// x4
    c[4] = param[14];	// x5
    c[5] = param[15];	// x6
    c[6] = param[16];	// x7

    m = param[0];
    n = param[1];
    p = param[2];
    rm = param[3];

    a = sqrt(2.0) / 2.0;
    r = 6.75 * rm;
    c1 = 1.0 + m * m * a * a;
    c2 = 1.0 + n * n * a * a;
    c3 = 4.0 + (m - n) * (m - n) * a * a;
    c4 = m - n;
    c5 = m + n;
    c6 = 3.0 + c4 * c4 * a * a - m * m * a * a;
    c7 = 3.0 + c4 * c4 * a * a - n * n * a * a;

    totpasses = 10;

    InitOscillator(c, 7);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c5 * c7 * c[1] * c[2] / 4.0 / c1 + p * m * a * c[3] / c1 - p * c1 * c[0];
	cn[1] = -a * c5 * c6 * c[0] * c[2] / 4.0 / c2 + p * n * a * c[4] / c2 - p * c2 * c[1];
	cn[2] = -a * a * a * c4 * c5 * c5 * c[0] * c[1] / 4 / c3 + p * a * c4 * c[5] / c3 - p * c3 * c[2];
	cn[3] = a * c5 * (c[1] * c[5] - c[2] * c[4]) / 4.0 + m * a * c[0] * c[6] + m * a * r * c[0] - c1 * c[3];
	cn[4] = a * c5 * (c[0] * c[5] + c[2] * c[3]) / 4.0 + n * a * c[1] * c[6] + n * a * r * c[1] - c2 * c[4];
	cn[5] = -a * c5 * (c[0] * c[4] + c[1] * c[3]) / 4.0 + a * c4 * r * c[2] - c3 * c[5];
	cn[6] = -a * (m * c[0] * c[3] + n * c[1] * c[4]) / 2.0 - 4.0 * c[6];
	if (DisplayOscillator(c, cn, dt, ((DWORD)i % threshold), i, 7, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Deterministic Chaos Of A Spherical Pendulum Under Limited Excitation
	A. Yu. Shvets 2007
***************************************************************************/

int	DoDeterministicChaos(void)

    {
    double	i, c1[5], cn[5], c, d, f, e, k1, k2;

    c1[0] = param[10];	// y1
    c1[1] = param[11];	// y2
    c1[2] = param[12];	// y3
    c1[3] = param[13];	// y4
    c1[4] = param[14];	// y5

    c = param[0];
    d = param[1];
    f = param[2];
    e = param[3];

    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	k1 = (c1[0] * c1[0] + c1[1] * c1[1] + c1[3] * c1[3] + c1[4] * c1[4]) / 8.0;
	k2 = 0.75 * (c1[0] * c1[4] - c1[1] * c1[3]);
	cn[0] = c * c1[0] - (c1[2] + k1) * c1[1] - k2 * c1[3] + c1[1] + c1[1];
	cn[1] = c * c1[1] + (c1[2] + k1) * c1[0] - k2 * c1[4] + c1[0] + c1[0];
	cn[2] = d * (c1[0] * c1[1] + c1[3] * c1[4]) + e * c1[2] + f;
	cn[3] = c * c1[3] - (c1[2] + k1 / 8.0) * c1[4] + k2 * c1[0] + c1[4] + c1[4];	// this 'k1/8' is an error but made the star
	cn[4] = c * c1[4] + (c1[2] + k1 / 8.0) * c1[3] + k2 * c1[1] + c1[3] + c1[3];	// same again
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Deterministic Chaos vs. Stochastic Fluctuation in an Eco-epidemic Model
	Partha Sarathi Mandal and Malay Banerjee 12 May 2015
	https://www.researchgate.net/publication/267143963
***************************************************************************/

int	DoDeterministicChaosStochasticFluctuation(void)

    {
    double	i, c1[3], cn[3], k, lambda, mu, m, a, theta, delta, r;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    k = param[0];
    lambda = param[1];
    mu = param[2];
    m = param[3];
    a = param[4];
    theta = param[5];
    delta = param[6];
    r = param[7];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = r * c1[0] * (1 - (c1[0] + c1[1]) / k) - lambda * c1[0] * c1[1];
	cn[1] = lambda * c1[0] * c1[1] - mu * c1[1] - m * c1[1] * c1[2] / (c1[1] + a);
	cn[2] = theta * c1[1] * c1[2] / (c1[1] + a) - delta * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 40.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Determining the Chaotic Behavior in a Fractional-Order Finance System with Negative Parameters
	O. I. Tacha, J. M. Munoz-Pacheco, E. Zambrano-Serrano, I. N. Stouboulos and V.-T. Pham  23 June 2018
	Sent by the third author and https://www.researchgate.net/publication/325950847_Determining_the_chaotic_behavior_in_a_fractional-order_finance_system_with_negative_parameters
***************************************************************************/

int	DoDeterminingChaoticBehaviorFractionalOrderFinanceSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2] + c1[0] * (c1[1] - a);
	cn[1] = 1 - b * c1[1] - fabs(c1[0]);
	cn[2] = -c1[0] - c * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 100.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Deterministic Nonideal Hydrodynamic Systems
	Chaos And Hyperchaos In Deterministic Nonideal Hydrodynamic Systems
	A. Yu. Shvets, V. A. Sirenko September 21-24, 2010
***************************************************************************/

int	DoDeterministicHydrodynamic(void)

    {
    double	i, c1[5], cn[5], azao, b, mu, n1, n3, alpha, p, q, beta = 0.0, b1 = 0.0;	// naughty Marcus

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// v
    c1[4] = param[14];	// w

    azao = param[0];
    b = param[1];
    mu = param[2];
    n1 = param[3];
    n3 = param[4];
    alpha = param[5];

    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	q = beta + azao / 2.0 * (c1[0] * c1[0] + c1[1] * c1[1] + c1[3] * c1[3] + c1[4] * c1[4]);
	p = b * (c1[0] * c1[4] - c1[1] * c1[3]);
	cn[0] = alpha * c1[0] - q * c1[1] + p * c1[3];
	cn[1] = alpha * c1[1] + q * c1[0] + p * c1[4] + 1.0;
	cn[2] = n3 + b1 * beta - mu * c1[1];
	cn[3] = alpha * c1[3] - q * c1[4] - p * c1[0];
	cn[4] = alpha * c1[4] + q * c1[3] - p * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dichotomy of nonlinear systems: Application to chaos control of nonlinear electronic circuit
	Jinzhi Wang, Zhisheng Duan, Lin Huang 24 October 2005
***************************************************************************/

int	DoDichotomyNonlinear(void)

    {
    double	i, c1[3], cn[3], alpha, beta, gamma, m0, m1, k, f, u = 0.0;	// naughty Marcus

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alpha = param[0];
    beta = param[1];
    gamma = param[2];
    m0 = param[3];
    m1 = param[4];
    k = param[5];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	f = m1 * c1[0] + 0.5 * (m0 - m1) * (fabs(c1[0] + 1.0) - fabs(c1[0] - 1.0));
	cn[0] = k * alpha * (c1[1] - c1[0] - f);
	cn[1] = k * (c1[0] - c1[1] + c1[2]) + u;
	cn[2] = k * (-beta * c1[1] - gamma * c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	"Different" Chaotic Attractor with restricted bifurcations Images
***************************************************************************/

int	DoDifferent(void)

    {
    double	i, c1[3], cn[3], a, b, d, mi, psi, fi;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    d = param[2];
    mi = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i += dt / 8.0)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	fi = a * (c1[0] * c1[0]) - (c1[0] * c1[0] * c1[0]);
	psi = 1.0 - d * c1[0] * c1[0];
	cn[0] = c1[1] + fi - c1[2] + i;
	cn[1] = psi - c1[1];
	cn[2] = mi * (b * c1[0] - c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i * 12.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Different 5D Lorenz Look Alike
	Marcus 2015
***************************************************************************/

int	DoDifferent5DLorenzLookAlike(void)

    {
    double	i, c1[5], cn[5], sigma, r, b, k, d, delta;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// v
    c1[4] = param[14];	// w

    sigma = param[0];
    r = param[1];
    b = param[2];
    k = param[3];
    d = param[4];
    delta = param[5];
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = (sigma * (c1[1] - c1[0]) + c1[3]) * delta;
	cn[1] = (r * c1[0] - c1[1] - c1[0] * c1[2] - c1[4]) * delta;
	cn[2] = (c1[0] * c1[1] - b * c1[2]) * delta;
	cn[3] = (d * c1[3] - c1[0] * c1[2]) * delta;
	cn[4] = (k * c1[1]) * delta;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i * 1.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Different Chaos
	Marcus Rezende 2015
***************************************************************************/

int	DoDifferentChaos(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - a * c1[2];
	cn[1] = -c1[0] + 2.0 * b * c1[1] + c * c1[2];
	cn[2] = d * (c1[0] - c1[2] * c1[2] * c1[2] + c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 12.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Different Families of Hidden Attractors in a New Chaotic System with Variable Equilibrium
	Viet-Thanh Pham, Sajad Jafari, Christos Volos and Tomasz Kapitaniak April 13, 2017
	https://www.researchgate.net/publication/319628516_Different_Families_of_Hidden_Attractors_in_a_New_Chaotic_System_with_Variable_Equilibrium
***************************************************************************/

int	DoDifferentFamiliesHiddenAttractors(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = 0.4 * c1[0] * c1[2] - a;
	cn[2] = 0.3 * c1[1] - 0.1 * c1[2] - 1.4 * c1[1] * c1[1] - b * c1[0] * c1[1] - c;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 12.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Different Pairs Of Synchronized Chaotic Systems
	A CHAOS-BASED TWO-LEVEL SECURE COMMUNICATION SYSTEM ON THE BASIS OF 
	TWO DIFFERENT PAIRS OF SYNCHRONIZED CHAOTIC SYSTEMS
	Dragomir Chantov
***************************************************************************/

int	DoDifferentPairs(void)

    {
    double	i, c1[3], cn[3], ni, s, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    ni = param[0];
    s = param[1];
    b = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -ni * (c1[0] * c1[0] * c1[0] - s * c1[0] - c1[1]);
	cn[1] = c1[0] - c1[1] - c1[2];
	cn[2] = b * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 12.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dimensionality Reduction Reconstitution for Extreme Multistability in Memristor-Based Colpitts System
	Yunzhen Zhang, Zhong Liu, Mo Chen, Huagan Wu, Shengyao Chen and Bocheng Bao 26 November 2019
	Sent directly by Chen Mo through Research Gate
***************************************************************************/

int	DoDimensionalityReductionReconstitutionExtremeMultistability(void)

    {
    double	i, c1[4], cn[4], a, b, alpha, beta, w4;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    alpha = param[2];
    beta = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	w4 = alpha - beta * c1[3] * c1[3];
	cn[0] = a * c1[2] - a * w4 * c1[1];
	cn[1] = a * c1[2];
	cn[2] = -0.5 * (c1[0] + c1[1]) / a - b * c1[2];
	cn[3] = c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 12.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dimensions of an Attractor Images
	Analytical Approach To Estimating the Dimension of Attractors
	T. Hakamada, H. Imai, and N. Ishimura 14 October 1994
***************************************************************************/

int	DoDimensions(void)

    {
    double	i, c1[5], cn[5], r1, r2, b, e, sigma;

    c1[0] = param[10];	// x1
    c1[1] = param[11];	// x2
    c1[2] = param[12];	// y1
    c1[3] = param[13];	// y2
    c1[4] = param[14];	// z

    r1 = param[0];
    r2 = param[1];
    e = param[2];
    sigma = param[3];
    b = param[4];
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i ++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -sigma * c1[0] - sigma * c1[2];
	cn[1] = -sigma * c1[1] + sigma * c1[3];
	cn[2] = -c1[0] * c1[4] + r1 * c1[0] - r2 * c1[1] - c1[2] - e * c1[3];
	cn[3] = -c1[1] * c1[4] + r2 * c1[0] + r1 * c1[1] + e * c1[2] - c1[3];
	cn[4] = -b * c1[4] + c1[0] * c1[2] + c1[1] * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 12.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Discontinuity Induced Hopf And Neimark-Sacker Bifurcations
	in a Memristive Murali-Lakshmanan-Chua Circuit-Ii
	A. Ishaq Ahamed and M. Lakshmanan April 4, 2017
***************************************************************************/

int	DoDiscontinuityInducedBifurcations(void)

    {
    double	i, c1[4], cn[4], beta, f, omega, w0;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    beta = param[0];
    f = param[1];
    omega = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	w0 = (fabs(c1[0]) > 1.0) ? -0.55 : -1.02;
	cn[0] = c1[1];
	cn[1] = c1[2] - w0 * c1[1];
	cn[2] = -beta * (c1[1] + c1[2]) + f * sin(omega * c1[3]);
	cn[3] = 1.0;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 50.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dissipative and Conservative Chaotic Nature of a New Quasi-Periodically Forced Oscillator with Megastability
	Karthikeyan Rajagopal, Jay Prakash Singh, Binoy Krishna Roy and Anitha Karthikeyana February 13, 2019
	Sent by the author Jay Prakash Singh
***************************************************************************/

int	DoDissipativeConservativeChaoticNatureQuasiPeriodicallyForcedOscillator(void)

    {
    double	i, c1[3], cn[3], a1, a2, a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a1 = param[0];
    a2 = param[1];
    a = param[2];
    b = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[1] + c1[0] - c1[0] * c1[0] * c1[0] + a1 * sin(a * c1[2]) + a2 * sin(b * c1[2]);
	cn[2] = fabs(c1[0]);						// here the original was the number '1'
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 50.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dissipative Chaotic Attractor Images
	By Marcus Rezende
***************************************************************************/

int	DoDissipativeChaos(void)

    {
    double	i, c1[3], cn[3];
    int		a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = (int)param[0];
    b = (int)param[1];
    c = (int)param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] * (sin(c1[1]) + cos(c1[2]) * pow(-1.0, a));
	cn[1] = c1[1] * (sin(c1[2]) + cos(c1[0]) * pow(-1.0, b));
	cn[2] = c1[2] * (sin(c1[0]) - cos(c1[1]) * pow(-1.0, c));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dixon System
	J. C. Sprott 2011
	Elegant Chaos
***************************************************************************/

int	DoDixonSystem(void)

    {
    double	i, c1[3], cn[3], real, imag;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = 1.0;	// z

    real = param[0];
    imag = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] * c1[1] / (c1[0] * c1[0] + c1[1] * c1[1]);
	cn[1] = c1[1] * c1[1] / (c1[0] * c1[0] + c1[1] * c1[1]) - 0.7 * c1[1] - 0.3;
	cn[2] = imag * sin(c1[0]) + cos(c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	DNA Dynamic Coding Image Encryption Algorithm with a Meminductor Chaotic System
	Jianhui Wang, Wenqi Huang, Zian Wang, Junwei Wang and Kairui Chen 16 August 2024
	https://iopscience.iop.org/article/10.1088/1402-4896/ad6bce/pdf.....DOI 10.1088/1402-4896/ad6bce
	Corresponding author:  kray@gzhu.edu.cn
***************************************************************************/

int	DoDNADynamicCodingImageEncryptionAlgorithm(void)

    {
    double	i, c1[3], cn[3], real, imag;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = 1.0;	// z

    real = param[0];
    imag = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -0.8 * c1[1];
	cn[1] = 0.1 * (-3 * (0.2 * c1[2] - 0.8 * cube(c1[2])) - 3 * c1[1] + c1[0]);
	cn[2] = 2 * (0.2 * c1[2] - 0.8 * cube(c1[2])) + 3 * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Do We need More Chaos Examples?
	Julien C. Sprott
	Chaos Theory and applications November 2020
***************************************************************************/

int	DoDoWeneedMoreChaosExamples(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[0] - c1[1] * fabs(c1[2]) / c1[2];
	cn[2] = c1[1] * c1[1] - exp(-c1[0] * c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dormand-Prince the Eldest of Chaotic Oscillator Design of on the FPGA Implementation 
	(Dormand- Prince tabanh kaotik osilator tasariminin FPGA zerinde gerceklenmesi)
	Ismail Koyuncu, Halil Ibrahim Seker, Murat Tuna and Murat Alcin November 2018
	https://www.researchgate.net/publication/329610299
***************************************************************************/

int	DoDormandPrinceEldest(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - c1[0] - a * c1[2];
	cn[1] = c1[0] * c1[2] - c1[0];
	cn[2] = -c1[0] * c1[1] - c1[1] + b;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Double Attractor
	MARCUS REZENDE  -2015, MAY, the 14th
***************************************************************************/

int	DoDoubleAttractor(void)

    {
    double	i, c1[3], cn[3], r, a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    r = param[0];
    a = param[1];
    b = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = r * c1[0] * (1.0 - c1[0] * c1[0] * c1[1]);
	cn[1] = (r * c1[0] * (1.0 - c1[0] * c1[0] * c1[1]) - c1[1]) / dt;
	cn[2] = sqrt(sqr(sin(a * c1[0])) + sqr(cos(b * c1[1])));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 50.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Double-Well Duffing System
	Chaos Control for Coupling of the Double-Well Duffing System Based on Random Phase Disturbance
	Gang Wu, Longsuo Li, Xinrong Cong 16 October 2012
***************************************************************************/

int	DoDoubleWell(void)

    {
    double	i, c1[4], cn[4], a, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    k = param[1];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = (1.0 - 3.0 * c1[0] * c1[0] - k) * c1[0] - a * c1[1] + k * c1[2];
	cn[2] = c1[3];
	cn[3] = k * c1[0] + (1.0 - 3.0 * c1[2] * c1[2] - k) * c1[2] - a * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Drive-Response Synchronisation of a Fractional-Order Hyperchaotic System and Its Circuit Implementation
	Darui Zhu, Chongxin Liu and Bingnan Yan 21 July 2013
	https://www.hindawi.com/journals/mpe/2013/815765/
***************************************************************************/

int	DoDriveResponseSynchronisationFractionalOrderHyperchaoticSystem(void)

    {
    double	i, c1[4], cn[4], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - c1[0] - c1[1] * c1[1] - c1[3];
	cn[1] = a * c1[1] + c1[0] * c1[2] + c1[3];
	cn[2] = -b * c1[0] * c1[1] - c * c1[2] + c1[3];
	cn[3] = -c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Duffing 3D oscillator Images
***************************************************************************/

int	DoDuffings3D(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -b * c1[1] + c1[0] - c1[0] * c1[0] * c1[0] + a * cos(c1[2]);
	cn[2] = c;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dyadic Transformation with a modification I
	WIKIPEDIA: DYadic Transformation with a modification 2015
***************************************************************************/

int	DoDyadicTransformationI(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] * c1[0] - c / c1[1];				// the quadratic formula used only x^2+C but I “spiced” it dividing by ‘y’
	cn[1] = (c1[0] * c1[0] - c / c1[1] - c1[1]) / dt; 
	cn[2] = sqrt(sqr(sin(a*c1[0])) + sqr(cos(b*c1[1])));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i * 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dyadic Transformation with a modification II
	WIKIPEDIA: DYadic Transformation with a modification 2015
***************************************************************************/

int	DoDyadicTransformationII(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = pow(fabs(c1[0]), PI) - c / c1[1];				// the quadratic formula used only x^2+C but I “spiced” it dividing by ‘y’
	cn[1] = (pow(fabs(c1[0]), PI) - c / c1[1] - c1[1]) / dt; 
	cn[2] = sqrt(sqr(sin(a*c1[0])) + sqr(cos(b*c1[1])));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i * 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamic Analysis and Circuit Design of a Novel Hyperchaotic System with Fractional-Order Terms
	Abir Lassoued and Olfa Boubaker 26 October 2017
**************************************************************************/

int	DoDynamicAnalysis(void)

    {
    double	i, c1[4], cn[4], a, b, c, f, m, r, h, k, hx;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    f = param[3];
    m = param[4];
    r = param[5];
    h = param[6];
    k = param[7];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2]; 
	hx = (c1[0] < 0) ?  (-c - f) * c1[0] * c1[0] - m * pow(-c1[0], r - 1) : ((c1[0] > 0) ? (-c + f) * c1[0] * c1[0] + m * pow (c1[0], r - 1) : 0.0);
	cn[2] = -a * c1[2] - b * c1[1] + hx;
	cn[3] = k * c1[1] - h * c1[3] + hx;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamic Analysis and Synchronisation Control of an Unusual Chaotic System with Exponential Term and Coexisting Attractors
	Qiang Lai, Akif Akgul, Metin Varanb, Jacques Kengnec and Alper Turan Erguzel 14 September 2018
	https://www.researchgate.net/publication/327818555_Dynamic_analysis_and_synchronization_control_of_an_unusual_chaotic_system_with_exponential_term_and_coexisting_attractors
**************************************************************************/

int	DoDynamicAnalysisSynchronisationControl(void)

    {
    double	i, c1[4], cn[4], m, n;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    m = param[0];
    n = param[1];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = m * (c1[1] - c1[0]) + 4 * c1[3];
	cn[1] = 4 * c1[0] * c1[2] + exp(4 * c1[2]) / 50; 
	cn[2] = (n - 50 * c1[0]) / 4;
	cn[3] = 1 * c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamical Analysis and Electronic Circuit Realisation of an Equilibrium Free 3D Chaotic System with a Large Number of Coexisting Attractors
	Z.T. Njitacke, J. Kengne and A. Nguomkam Negou 24 October 2016
	Sent to ManpWIN by  Njitacke Zeric through https://www.researchgate.net/requests/r81096341
***************************************************************************/

int	DoDynamicalAnalysisElectronicCircuitRealisation(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - a;
	cn[1] = -c1[0] + c1[1] * c1[2];
	cn[2] = c1[1] - c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamical Analysis of a Chaotic System with Two Double Scroll Attractors Images
	WENBO LIU, GUANRONG CHEN February 27, 2003
***************************************************************************/

int	DoDynamicalAnalysis(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] - c1[1] * c1[2];
	cn[1] = -b * c1[1] + c1[0] * c1[2];
	cn[2] = -c * c1[2] + c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamical Analysis of a Quadratic Megastable Chaotic Oscillator and Its Application in Biometric Fingerprint Image Encryption
	Rajeskannan Subramanian, Serdar CiCek, Akif Akgul, Girma Adam, Anitha Karthikeyan and Karthikeyan Rajagopal
	26 Mar 2024
	https://www.hindawi.com/journals/complexity/2024/2005801/...... https://doi.org/10.1155/2024/2005801
***************************************************************************/

int	DoDynamicalAnalysisQuadraticMegastableChaoticOscillator(void)

    {
    double	i, c1[3], cn[3], a, b, azao;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    azao = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -b * tanh(azao * c1[0]) + a * sin(c1[2]);
	cn[2] = -c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamical Chaos and Uniformly Hyperbolic Attractors from Mathematics to Physics
	S P Kuznetsov 2011
***************************************************************************/

int	DoDynamicalChaos(void)

    {
    double	i, c1[3], cn[3], mu, k, delta;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    mu = param[0];
    k = param[1];
    delta = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - c1[0] * c1[0] * c1[0] + 3.0 * c1[0] * c1[0] - c1[2];
	cn[1] = 1.0 - 5.0 * c1[0] * c1[0] - c1[1];
	cn[2] = mu * (4.0 * (c1[0] - k) - c1[2] - delta);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamical Systems from Output Regular and Chaotic Signals
	Construction of Dynamical Systems from Output Regular and Chaotic Signals
	Evgeniy D. Pechuk, Tatyana S. Krasnopolskaya
***************************************************************************/

int	DoDynamicalSystems(void)

    {
    double	i, c1[3], cn[3], c, d, e, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    c = param[0];
    e = param[1];
    f = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c * c1[0] - c1[1] * c1[2] - 0.125 * (c1[0] * c1[0] * c1[1] + c1[1] * c1[1] * c1[1]);
	cn[1] = c * c1[1] + c1[0] * c1[2] + 0.125 * (c1[0] * c1[0] * c1[0] + c1[0] * c1[1] * c1[1]);
	cn[2] = d * c1[1] + e * c1[2] + f;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamical System Generalized Nose-Hoover Oscillators with Temperature Gradient
	Julien C. Sprott, William Graham Hoover and Carol Griswold Hoover April 15, 2014
***************************************************************************/

int	DoDynamicalNoseHoover(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] + 2.0 * c1[0] * c1[1] + c1[0] * c1[2];
	cn[1] = 1.0 - 2.0 * c1[0] * c1[0] + c1[1] * c1[2];
	cn[2] = c1[0] - c1[0] * c1[0] - c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamic Analysis and Circuit Design of a Novel Hyperchaotic System with Fractional-Order Terms - B
	Abir Lassoued and Olfa Boubaker 1 October 2017
	https://www.hindawi.com/journals/complexity/2017/3273408/
***************************************************************************/

int	DoDynamicAnalysisCircuitDesign(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, m, h, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    m = param[4];
    h = param[5];
    k = param[6];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = -a * c1[2] - b * c1[1] - 2 * c * c1[0] * c1[0] + 2 * d * fabs(c1[0]) * c1[0] + m / sqrt(2.0) * sqrt(fabs(c1[0])) * fabs(c1[0]) / c1[0];
	cn[3] = k * c1[1] - 80 * h * c1[3] - 2 * c * c1[0] * c1[0] + 2 * d * fabs(c1[0]) * c1[0] + m / sqrt(2.0) * sqrt(fabs(c1[0])) * fabs(c1[0]) / c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamic Analysis and Electronic Circuit Implementation of a Novel 3D Autonomous System Without Linear Terms
	J. Kengnea, S. Jafari, Z.T. Njitackea, M. Yousefi Azar Khanian and A. Cheukem April 2017
	https://www.researchgate.net/publication/316411505
***************************************************************************/

int	DoDynamicAnalysisElectronicCircuitImplementation(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[2] * c1[2] + 9.0;
	cn[1] = c1[0] * c1[0] - c1[2] * c1[2] + 1.0;
	cn[2] = c1[0] * c1[0] - c1[1] * c1[1] + c1[2] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamic Analysis for a Fractional-Order Autonomous Chaotic System
	Jiangang Zhang, Juan Nan, Wenju Du, Yandong Chu and Hongwei Luo 26 June 2016
***************************************************************************/

int	DoDynamicAnalysisFractOrderAutonomousChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
 
    a = param[0];
    b = param[1];
    c = param[2];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a + c1[2] * (c1[0] - b * c1[1]);
	cn[1] = c1[2] * (b * c1[0] - c * c1[1]);
	cn[2] = 1.0 - c1[0] * c1[0] - c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamic Analyses, FPGA Implementation and Engineering Applications of Multi-Butterfly Chaotic Attractors Generated from Generalised Sprott C System
	QIANG LAI, XIAO-WEN ZHAO, KARTHIKEYAN RAJAGOPAL, GUANGHUI XU, AKIF AKGUL and EMRE GULERYUZ 14 December 2017
	https://www.researchgate.net/publication/321796499_Dynamic_analyses_FPGA_implementation_and_engineering_applications_of_multi-butterfly_chaotic_attractors_generated_from_generalized_Sprott_C_system
***************************************************************************/

int	DoDynamicAnalysesFPGAImplementationEngineeringApplications(void)

    {
    double	i, c1[4], cn[4];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - c1[0];
	cn[1] = c1[0] * c1[2] - c1[0] * c1[3];
	cn[2] = 1.0 - c1[1] * c1[1];
	cn[3] = 5.0 * fabs(c1[2]) / c1[2] - c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamic Behaviors Analysis of a Chaotic Circuit Based on a Novel Fractional-Order Generalised Memristor
	Ningning Yang, Shucan Cheng, Chaojun Wu, Rong Jia and Chongxin Liu 21 May 2019
	https://www.hindawi.com/journals/complexity/2019/6083853/
***************************************************************************/

int	DoDynamicBehaviorsAnalysisChaoticCircuit(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[1] - (c1[2] + c) * tanh(c1[0]);
	cn[1] = b * (c1[0] + c1[1]);
	cn[2] = a * log(fabs(c * cosh(c1[0]))) - a * log(fabs((c1[2] + c)));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamic Behaviors of Far and Near Memristive Electromagnetic Induction in Spoon Neural Network
	Qiang Lai and Yudi Xu August 20 2024
	https://pubs.aip.org/aip/cha/article/34/8/083127/3309062....https://doi.org/10.1063/5.0216108
	Corresponding author: laiqiang87@126.com
***************************************************************************/

int	DoDynamicBehaviorsFarNearMemristiveElectromagneticInduction(void)

    {
    double	i, c1[5], cn[5], a, b, c, d, k, p, q, t1, t2, t3, t4, v1, w1;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w
    c1[4] = param[14];	// v

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    k = param[4];
    p = param[5];
    q = param[6];
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	t1 = tanh(c1[0]);
	t2 = tanh(c1[1]);
	t3 = tanh(c1[2]);
	t4 = tanh(c1[3]);

	v1 = c1[0] - c1[2];
	w1 = p - q * t1;

	cn[0] = -c1[0] - 2.5 * t1 + t2 + k * w1 * v1;
	cn[1] = -c1[1] + 3.4 * t1 + 1.5 * t3 + a * t4;
	cn[2] = -c1[2] - 3 * t2 + 2 * t3 + 0.1 * t4 - k * w1 * v1;
	cn[3] = -c1[3] + b * t3;
	cn[4] = -c1[4] + v1;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamic Evolution Analysis of Stock Price Fluctuation and Its Control
	Yuhua Xu, Zhongyi Ke, Chengrong Xie and Wuneng Zhou 29 January 2018
***************************************************************************/

int	DoDynamicEvolutionAnalysisStockPriceFluctuation(void)

    {
    double	i, c1[3], cn[3], a0, a1, a2, a3, q, w, r = 0.0;

    c1[0] = param[10];
    c1[1] = param[11];
    c1[2] = param[12];

    a0 = param[0];
    a1 = param[1];
    a2 = param[2];
    a3 = param[3];
    q = param[4];
    w = param[5];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -a1 * c1[0] + a2 / (a0 + c1[0] * fabs(c1[0]) / c1[0]) - a3 * r + q * cos(w * i);
	cn[2] = sin(c1[0]) + cos(c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamical Analysis of a Novel Fractional-Order Chaotic System Based on Memcapacitor and Meminductor
	Xingce Liu, Jun Mou, Jue Wang, Santo Banerjee and Peng Li 13 November 2022
	https://www.mdpi.com/2504-3110/6/11/671......https://doi.org/10.3390/fractalfract6110671
***************************************************************************/

int	DoDynamicalAnalysisNovelFractionalOrderChaoticSystem(void)

    {
    double	i, c1[5], cn[5], a, b, c, d, e;

    c1[0] = param[10];
    c1[1] = param[11];
    c1[2] = param[12];
    c1[3] = param[13];
    c1[4] = param[14];

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];

    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[2] - (a + b * cos(c1[4])) * c1[1];
	cn[1] = (c + d * cos(c1[3])) * c1[0];
	cn[2] = e * (c + d * cos(c1[3])) * c1[0];
	cn[3] = c1[0];
	cn[4] = c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamical Behavior of a 3D Jerk System with a Generalised Memristive Device
	Wei Feng,1,2 Yi-Gang He,1 Chun-Lai Li,3 Xun-Min Su,3 and Xiao-Qing Chen3 19 August 2018
	https://www.hindawi.com/journals/complexity/2018/5620956/
***************************************************************************/

int	DoDynamicalBehavior3DJerkSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, k;

    c1[0] = param[10];
    c1[1] = param[11];
    c1[2] = param[12];

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    k = param[4];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = d * c1[2];
	cn[2] = -a * c1[2] + b * c1[0] - c * c1[0] * c1[0] * c1[0] + k * (c1[0] * c1[0] - 2) * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamical Behaviors, Circuit Realisation, Chaos Control and Synchronisation of a New Fractional Order Hyperchaotic System
	A.M.A. El-Sayed, H.M. Nour, A. Elsaid, A.E. Matouk, A. Elsonbaty 7 October 2015
	https://www.researchgate.net/requests/r50466039
***************************************************************************/

int	DoDynamicalBehaviorsCircuitRealisationChaosControl(void)

    {
    double	i, c1[4], cn[4], a1, C1, a2, b2, h1, c2, b3, a3, h2, b1;

    c1[0] = param[10];
    c1[1] = param[11];
    c1[2] = param[12];
    c1[3] = param[13];

    a1 = param[0];
    C1 = param[1];
    a2 = param[2];
    b2 = param[3];
    h1 = param[4];
    c2 = param[5];
    b3 = param[6];
    a3 = param[7];
    h2 = param[8];
    b1 = param[9];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a1 * c1[0] + b1 * c1[1] + C1 * c1[0] * c1[3] * c1[3];
	cn[1] = a2 * c1[0] + b2 * c1[1] + h1 * c1[2] + c2 * c1[3];
	cn[2] = b3 * c1[1];
	cn[3] = a3 * c1[0] + h2 * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamical Study of a Novel 4D Hyperchaotic System: An Integer and Fractional Order Analysis
	Kulpash Iskakova, Mohammad Mahtab Alam, Shabir Ahmad, Sayed Saifullah, Ali Akgul and Gulnur Yilmaz 26 January 2023
	https://www.researchgate.net/requests/r109593282.....https://doi.org/10.1016/j.matcom.2023.01.024
***************************************************************************/

int	DoDynamicalStudyNovel4DHyperchaoticSystem(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[1] * c1[2];
	cn[1] = b * c1[0] - c1[0] * c1[2] - c * c1[0];
	cn[2] = d * c1[0] * c1[1] - c1[0] * c1[3];
	cn[3] = c1[0] - e * c1[3] + c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamics, Analysis and Implementation of a Multiscroll Memristor-Based Chaotic Circuit
	N. Henry Alombah, Hilaire Fotsin, E. B. Megam Ngouonkadi and Tekou Nguazon April 7, 2016
	https://www.researchgate.net/publication/305923714_Dynamics_Analysis_and_Implementation_of_a_Multiscroll_Memristor-Based_Chaotic_Circuit
***************************************************************************/

int	DoDynamicsAnalysisImplementationMultiscroll(void)

    {
    double	i, c1[4], cn[4], a, b, c, l1, l2, p, r;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    l1 = param[3];
    l2 = param[4];
    p = param[5];
    r = param[6];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c * c1[1];
	cn[1] = -l1 * (c1[0] + b * (c1[3] * c1[3] - 1) * (c1[1] + c1[2])) + r * (c1[1] + c1[2]);
	cn[2] = -l2 * (b * (c1[3] * c1[3] - 1) * (c1[1] + c1[2]) + r * (c1[1] + c1[2]));
	cn[3] = -p * (c1[1] + c1[2]) - a * c1[3] + c1[3] * (c1[1] + c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamics, Chaos Control and Synchronisation in a Fractional-Order Samardzija-Greller Population System with Order Lying in (0, 2)
	A. Al-khedhairi, S. S. Askar, A. E. Matouk, A. Elsadany and M. Ghazel5 10 September 2018
	https://www.hindawi.com/journals/complexity/2018/6719341/
***************************************************************************/

int	DoDynamicsChaosControlSynchronisationFractionalOrder(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];
    c1[1] = param[11];
    c1[2] = param[12];

    a = param[0];
    b = param[1];
    c = param[2];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] * (1 - c1[1]) + (c - a * c1[2]) * c1[0] * c1[0];
	cn[1] = (c1[0] - 1) * c1[1];
	cn[2] = (a * c1[0] * c1[0] - b) * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamics, Circuit Design, and Synchronisation of a New Chaotic System with Closed Curve Equilibrium-II
	Xiong Wang, Viet-Thanh Pham and Christos Volos 16 February 2017
***************************************************************************/

int	DoDynamicsCircuitDesignSynchronization(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2];
	cn[1] = -c1[2] * (a * c1[1] + b * fabs(c1[1])) - c1[0] * fabs(c1[2]);
	cn[2] = fabs(c1[0]) + fabs(c1[1]) - 1.0;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamics and Circuit of a Chaotic System with a Curve of Equilibrium Points 
	Viet–Thanh Pham, Christos Volos, Tomasz Kapitaniak, Sajad Jafarid and  Xiong Wange June 25, 2017
***************************************************************************/

int	DoDynamicsCircuitChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, error;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    error = param[4];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[2];
	cn[1] = c1[0] * c1[2] * ((error == 0.0) ? c1[2] : 1.0) + a * tanh(b * c1[2]);
	cn[2] = c1[0] + c * c1[1] - c * tanh(b * c1[1]) + c1[2] * (d * c1[1] * c1[1] - c1[2] * c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamics and Circuit Realization of a No-equilibrium Chaotic System with a Boostable Variable
	Viet-Thanh Pham, Akif Akgul, Christos Volos, Sajad Jafari and Tomasz Kapitaniak 20 May 2017
***************************************************************************/

int	DoDynamicsCircuitRealization(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] + a;
	cn[1] = -c1[0] + c1[2];
	cn[2] = -b * c1[0] * c1[0] + c1[2] * c1[2] + c;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamics and Complexity of a New 4D Chaotic Laser System
	Hayder Natiq, Mohamad Rushdan Md Said, Nadia M. G. Al-Saidi and Adem Kilicman 7 January 2019
	https://www.mdpi.com/search?q=&journal=entropy&sort=pubdate&page_count=50
***************************************************************************/

int	DoDynamicsComplexityNew4DChaoticLaserSystem(void)

    {
    double	i, c1[4], cn[4], sigma, delta, r, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// z

    sigma = param[0];
    delta = param[1];
    r = param[2];
    b = param[3];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = sigma * (c1[1] - c1[0]);
	cn[1] = -c1[1] - delta * c1[2] + (r - c1[3]) * c1[0];
	cn[2] = delta * c1[1] - c1[2];
	cn[3] = -b * c1[3] + c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamics and Entropy Analysis for a New 4-D Hyperchaotic System with Coexisting Hidden Attractors
	Licai Liu, Chuanhong Du, Xiefu Zhang, Jian Li and Shuaishuai Shi 15 March 2019
	https://www.researchgate.net/publication/331854459_Dynamics_and_Entropy_Analysis_for_a_New_4-D_Hyperchaotic_System_with_Coexisting_Hidden_Attractors
***************************************************************************/

int	DoDynamicsEntropyAnalysis(void)

    {
    double	i, c1[4], cn[4], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// z

    a = param[0];
    b = param[1];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[1] + c1[0] * c1[2];
	cn[1] = -b * c1[0] + c1[1] * c1[2];
	cn[2] = 1 - c1[0] * c1[0] - c1[1] * c1[1];
	cn[3] = c1[2] * (c1[3] - 1);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamics, FPGA Realisation and Application of a Chaotic System with an Infinite Number of Equilibrium Points
	Esteban Tlelo-Cuautle, Luis Gerardo de la Fraga, Viet-Thanh Pham, Christos Volos, Sajad Jafari and Antonio de Jesus Quintas-Valles 26 March 2017
	https://www.researchgate.net/publication/315796908
***************************************************************************/

int	DoDynamicsFPGARealisationApplicationChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, h;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    h = param[1];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] - h * c1[2];
	cn[1] = c1[1] + h * c1[0] * c1[2] * c1[2];
	cn[2] = c1[2] + h * (c1[0] - a * exp(c1[1]) + c1[2] * (c1[1] * c1[1] - c1[2] * c1[2]));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamics and Control of Tokamak System with Symmetric and Magnetically Confined Plasma
	Sundarapandian Vaidyanathan August 2015
	https://www.researchgate.net/publication/281649670
***************************************************************************/

int	DoDynamicsControlTokamaks(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[0] - c1[0] * c1[0] * c1[0];
	cn[2] = a - b * c1[2] * c1[2] - c1[0] * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamics and Synchronisation of a Memristor-Based Chaotic System with No Equilibrium
	Hong-Min Li, Yan-Feng Yang, Yang Zhou, Chun-Lai Li, Kun Qian, Zhao-Yu Li and Jian-Rong Du 28 Oct 2019
	https://www.hindawi.com/journals/complexity/2019/4647608/
***************************************************************************/

int	DoDynamicsSynchronisationMemristorBasedChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c, w;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	w = 3 * a * c1[0] * c1[0] + b;
	cn[0] = c1[1];
	cn[1] = -w * c1[0] + c1[1] * c1[2];
	cn[2] = c - c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamics at Infinity and a Hopf Bifurcation Arising in a Quadratic System with Coexisting Attractors
	ZHEN WANG1, IRENE MOROZ, ZHOUCHAO WEI and HAIPENG REN 4 September 2017
	https://www.researchgate.net/publication/322085646_Dynamics_at_infinity_and_a_Hopf_bifurcation_arising_in_a_quadratic_system_with_coexisting_attractors
***************************************************************************/

int	DoDynamicsAtInfinityHopfBifurcation(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - 16 * a * c1[2] + c1[1] * c1[2] / 16 - c1[0] * c1[0] * c1[0] - c1[0] * c1[0] * c1[2] / 2 + c1[0] * c1[2];
	cn[1] = -4 * c1[0] * c1[2] - c1[1] * c1[0] * c1[0] - c1[0] * c1[1] * c1[2] / 2 + c1[1] * c1[2];
	cn[2] = -c1[2] * c1[0] * c1[0] - c1[0] * c1[2] * c1[2] / 2 + c1[2] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamics, Control and Symmetry Breaking Aspects of an Infinite-Equilibrium Chaotic System
	Leandre Kamdjeu Kengne,Jacques Kengne, Justin Roger Mboupda Pone, Herve Thierry Kamdem Tagne 14 February 2020
	https://www.researchgate.net/publication/339254351
***************************************************************************/

int	DoDynamicsControlSymmetryBreaking(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[2];
	cn[1] = c1[0] * c1[2] * c1[2] + a * fabs(c1[2]) / c1[2];
	cn[2] = c1[0] - b * sinh(c * c1[1]) + c1[2] * (d * c1[1] * c1[1] - c1[2] * c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamics Feature and Synchronisation of a Robust Fractional-Order Chaotic System
	Xuan-Bing Yang, Yi-Gang He and Chun-Lai Li 2 December 2018
	https://www.hindawi.com/journals/complexity/2018/8797314/
***************************************************************************/

int	DoDynamicsFeatureSynchronisation(void)

    {
    double	i, c1[3], cn[3], a, b, c, m, n;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    n = param[3];
    m = param[4];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - a * c1[0];
	cn[1] = -b * c1[0] - c * c1[0] * c1[2];
	cn[2] = -n + m * c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamics of a Cubic Nonlinear System with No Equilibrium Point
	J. O. Maaita, Ch. K. Volos, I. M. Kyprianidis, and I. N. Stouboulos 9 July 2015
***************************************************************************/

int	DoDynamicsCubicNonlinearSystem(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[0] * c1[0] * c1[0] - c1[2] * c1[1];
	cn[2] = c1[1] * c1[1] - a;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamics of A New Composite Four - scroll Chaotic System with complex dynamics
	Le Xiong, Sen Zhang, Yicheng Zeng and Boquan Liu 13 April 2018 Sent from the second author
***************************************************************************/

int	DoDynamicsANewCompositeFourscrollChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e, h;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	h = c * c1[0] + d * c1[0] * fabs(c1[0]) + e * c1[0] * c1[0] * c1[0];
	cn[0] = a * (c1[1] - h);
	cn[1] = c1[0] + c1[2];
	cn[2] = -b * c1[1] + fabs(c1[0]) / c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamics of a New Hyperchaotic System with Only One Equilibrium Point
	Xiang Li and Ranchao Wu 2 July 2013
***************************************************************************/

int	DoDynamicsNewHyperchaoticSystem(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e, alpha, beta;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    alpha = param[5];
    beta = param[6];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = c * c1[0] - c1[0] * c1[2] - c1[1] + e * c1[3];
	cn[2] = c1[0] * c1[0] * c1[0] * c1[0] + c1[0] * c1[0] - b * c1[2];
	cn[3] = -d * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamics of a New Three-Dimensional Chaotic Systems with Multiple Attractors
	Sujay Goldar* and Sk. Sarif Hassan - 2024
	https://mail.google.com/mail/u/0/#inbox/FMfcgzQVxbjQMZMnFdpZxtxtTzTPpnGZ?projector=1&messagePartId=0.1
	Corresponding authors:sksarifhassan@pinglacollege.ac.in,,,sujaygoldar@pinglacollege.ac.in,
***************************************************************************/

int	DoDynamicsNew3DChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[0] + b * c1[1] * c1[2];
	cn[1] = -a * sqr(c1[1]) + c * c1[0] * c1[2];
	cn[2] = d * c1[2] - c * c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamics and Feedback Control for a New Hyperchaotic System
	Kejun Zhuang, Hailong Zhu  2012-08-24
***************************************************************************/

int	DoDynamicsAndFeedback(void)

    {
    double	i, c1[4], cn[4], a, b, c, h, f, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    h = param[3];
    f = param[4];
    k = param[5];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[3] - k * c1[0];
	cn[1] = b * c1[0] + c * c1[1] + c1[0] * c1[2] + c1[3] - k * c1[1];
	cn[2] = -c1[0] * c1[0] - k * c1[2];
	cn[3] = -f * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamics and Synchronisation of New Hyperchaotic Complex Lorenz System in 7 Dimensions
	Emad E. Mahmoud 17 November 2011
***************************************************************************/

int	DoDynamicsAndSynchronisation(void)

    {
    double	i, c1[7], cn[7], a, b, g, k1, k2;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w
    c1[6] = param[16];	// q

    a = param[0];
    b = param[1];
    g = param[2];
    k1 = param[3];
    k2 = param[4];
    totpasses = 10;

    InitOscillator(c1, 7);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[2] - c1[0]);
	cn[1] = a * (c1[3] - c1[1]);
	cn[2] = g * c1[0] - c1[0] * c1[4] - c1[2] + c1[5];
	cn[3] = g * c1[1] - c1[1] * c1[4] - c1[3] + c1[6];
	cn[4] = c1[0] * c1[2] + c1[1] * c1[3] - b * c1[4];
	cn[5] = k1 * c1[0] + k2 * c1[2];
	cn[6] = k1 * c1[1] + k2 * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 50.0) % threshold), i, 7, 2) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamics of an Airfoil with Higher-Order Plunge and Pitch Stiffnesses in Incompressible Flow
	Karthikeyan Rajagopal, Yesgat Admassu, Riessom Weldegiorgis, Prakash Duraisamy and Anitha Karthikeyan 30 October 2019
	https://www.researchgate.net/publication/336922337
***************************************************************************/

int	DoDynamicsAirfoil(void)

    {
    double	i, c1[4], cn[4], b, fx, fz;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    b = param[0];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	fz = 5 * c1[2] * c1[2] + 10 * pow(c1[2], 3) + 40 * pow(c1[2], 5);
	fx = 5 * c1[0] * c1[0] + 20 * pow(c1[0], 3) + 40 * pow(c1[0], 5);
	cn[0] = c1[1];
	cn[1] = 1.0 / 1.75 * (4 * c1[0] * (0.065 * b - 0.5) + 0.1 * c1[3] + 0.2 * c1[2] + fz - 4 * fx - 0.4 * c1[1]);
	cn[2] = c1[3];
	cn[3] = -1.0 / 1.75 * (c1[0] * (0.24 * b - 0.5) + 0.2 * c1[3] + 0.4 * c1[2] + 2 * fz - fx - 0.1 * c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 150.0) % threshold), i, 4, 2) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamics of Coupled Nonlinear Oscillators of Different Attractors;
	van der Pol Oscillator and Damped Duffing Oscillator
***************************************************************************/

int	DoDynamicsCoupledOscillators(void)

    {
    double	i, c1[4], cn[4], mi, alpha, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    mi = param[0];
    alpha = param[1];
    k = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = mi * (1.0 - c1[0] * c1[0]) * c1[1] - c1[0] + k * (c1[2] - c1[0]);
	cn[2] = c1[3];
	cn[3] = -alpha * c1[3] + c1[2] - c1[2] * c1[2] * c1[2] + k * (c1[0] - c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamics of a Nonautonomous Predator-Prey Model with Infertility Control in the Prey
	Xiaomei Feng, Zhidong Teng and Fengqin Zhang 2014
***************************************************************************/

int	DoDynamicsNonautonomous(void)

    {
    double	i, c1[4], cn[4], mi, b1, a11, a12, a21, a22, d2, b2;
    double	pi = 4.0 * atan(1.0);

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	b1 = 10.0 + sin(6.0 * i / pi); 
	a11 = 0.09 + 0.001 * sin(6.0 * i / pi);
	mi = 9.0 * (0.35 + 0.1 * cos(i / 4) + 0.1 * sin(i / 4));
	a12 = 1.2 + cos(i / 6.0);
	d2 = 2.0 + .005 * sin(6.0 * i / pi);
	b2 = 1.5 + cos(i / 6.0);
	a21 = 0.7 + 0.3 * cos(6.0 * i / pi);
	a22 = 5.0 + 3.0 * sin(i / 6.0);

	cn[0] = c1[0] * (b1 - a11 * c1[0] + c1[1] - mi - a12 * c1[2]);
	cn[1] = mi * c1[0] - d2 * c1[1] - a11 * (c1[0] + c1[1]) * c1[1] - a12 * c1[1] * c1[2];
	cn[2] = c1[2] * (b2 + a21 * (c1[0] + c1[1])) - a22 * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamics of Impurities in a Three-Dimensional Volume-Preserving Map
	Swetamber Das and Neelima Gupte 15 November 2017
	https://www.researchgate.net/publication/263200911_Dynamics_of_impurities_in_a_three-dimensional_volume-preserving_map
***************************************************************************/

int	DoDynamicsOfImpurities(void)

    {
    double	i, c1[3], cn[3], a, b, c, pi;
    bool	UseInt;

    c1[0] = cn[0] = param[10];	// x
    c1[1] = cn[1] = param[11];	// y
    c1[2] = cn[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    pi = param[3];
    UseInt = (param[4] != 0.0);
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	if (UseInt)
	    {
	    cn[0] = (double)(int)(fmod((c1[0] + a * sin(c1[2]) + c * cos(c1[1])), (2.0 * pi)));
	    cn[1] = (double)(int)(fmod((c1[1] + b * sin(cn[0]) + a * cos(c1[2])), (2.0 * pi)));
	    cn[2] = (double)(int)(fmod((c1[2] + c * sin(cn[1]) + b * cos(cn[0])), (2.0 * pi)));
	    }
	else
	    {
	    cn[0] = fmod((c1[0] + a * sin(c1[2]) + c * cos(c1[1])), (2.0 * pi));
	    cn[1] = fmod((c1[1] + b * sin(cn[0]) + a * cos(c1[2])), (2.0 * pi));
	    cn[2] = fmod((c1[2] + c * sin(cn[1]) + b * cos(cn[0])), (2.0 * pi));
	    }
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Dynamics, Synchronisation and Electronic Implementations of a New Lorenz-like Chaotic System with Nonhyperbolic Equilibria
	P. D. Kamdem Kuate, Qiang Lai and Hilaire Fotsin May 13, 2019
	https://www.researchgate.net/publication/338176647_Dynamics_Synchronization_and_Electronic_Implementations_of_a_New_Lorenz-like_Chaotic_System_with_Nonhyperbolic_Equilibria
***************************************************************************/

int	DoDynamicsSynchronizationElectronicImplementations(void)

    {
    double	i, c1[3], cn[3], a, c;

    c1[0] = cn[0] = param[10];	// x
    c1[1] = cn[1] = param[11];	// y
    c1[2] = cn[2] = param[12];	// z

    a = param[0];
    c = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = -fabs(c1[2]) / c1[2] * c1[0];
	cn[2] = fabs(c1[1]) - c;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Economic Systems With Fractional Order Dynamics
	Synchronisation OF ECONOMIC SYSTEMS WITH FRACTIONAL ORDER DYNAMICS USING ACTIVE SLIDING MODE CONTROL
	Atefeh Marvi Moghadam, Saeed Balochian 2014
***************************************************************************/

int	DoEconomicSystems(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2] + (c1[1] - a) * c1[0];
	cn[1] = 1.0 - b * c1[1] - c1[0] * c1[0];
	cn[2] = -c1[0] - c * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Effect of Market Confidence on a Financial System from the Perspective of Fractional Calculus: Numerical Investigation and Circuit Realisation
	Shu-BoChen, Hadi Jahanshahi, Oumate Alhadji Abba, J.E.Solis-Perez, Stelios Bekiros, J.F.Gomez-Aguilar, AminYousefpour and Yu-MingChu September 2020
	Sent to ManpWIN by J.F.Gomez-Aguilar through https://www.sciencedirect.com/science/article/pii/S0960077920306196
***************************************************************************/

int	DoEffectMarketConfidenceFinancialSystem(void)

    {
    double	i, c1[4], cn[4];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 0.5 * c1[2] + 5 * c1[0] * c1[1] - 2.1 * c1[0] + 4.2 * c1[3];
	cn[1] = 0.2 - 0.01 * c1[1] - 3.2 * c1[0] * c1[0] + 2.56 * c1[3];
	cn[2] = 0 - 2 * c1[0] - 2.6 * c1[2] + 2.2 * c1[3];
	cn[3] = -20 * c1[0] * c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 40.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Effects of Padé Numerical Integration in Simulation of Conservative Chaotic Systems
	Denis Butusov, Artur Karimov, Aleksandra Tutueva, Dmitry Kaplun and Erivelton G. Nepomuceno 3 April 2019
	https://www.researchgate.net/publication/332180513
***************************************************************************/

int	DoEffectsPadeNumericalIntegration(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[0] - a * c1[1] * c1[2];
	cn[2] = b * (c1[1] * c1[1] - 1);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 40.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Effect of Symmetry Breaking in an Inertial Neural System with a Non-Monotonic Activation Function: Theoretical Study, Asymmetric Coexistence and Experimental Investigation.
	Bertrand Frederick BOUI A BOYA, Jacques KENGNE, Joseph Yves EFFA 
	Corresponding author: Bertrand Frederick BOUI A BOYA E-mail: larocheezebio@gmail.com 17 Feb 2022
	https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3983130
***************************************************************************/

int	DoEffectSymmetryBreakingInertialNeuralSystem(void)

    {
    double	i, c1[4], cn[4], C1, C2, b, f1, f2, k1, k2;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    C1 = param[0];
    C2 = param[1];
    b = param[2];
    k1 = param[3];
    k2 = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	f1 = c1[0] * exp(-sqr(c1[0] - b) / 2);
	f2 = c1[1] * exp(-sqr(c1[1] - b) / 2);

	cn[0] = c1[2];
	cn[1] = c1[3];
	cn[2] = -k1 * c1[2] - c1[0] + C1 * f2;
	cn[3] = -k2 * c1[3] - c1[1] + C2 * f1;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 40.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	An Eight Term Novel Four Scroll Chaotic System with Cubic Nonlinearity and its Circuit Simulation
	S. Sampath, S. Vaidyanathan,Ch.K. Volos and V.T. Pham 14 November 2014
***************************************************************************/

int	DoEightTermFourScrollChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + b * c1[1] * c1[2];
	cn[1] = -10.0 * c1[1] * c1[1] * c1[1] - c1[1] + 4.0 * c1[0] * c1[2];
	cn[2] = c * c1[2] - c1[0] * c1[1];

	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Eight Wing Chaotic Attractor Images
	ATTRACTOR FROM QI 3-D FOUR-WING CHAOTIC SYSTEM
	GUOYUAN QI, ZHONGLIN WANG, YANLING GUO February 17, 2012
***************************************************************************/

int	DoEightWing(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, m, k, w, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    m = param[4];
    k = param[5];
    w = param[6];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	f = m * ((sin(w * i) <= 0) ? -1.0 : 1.0) + k;
	cn[0] = a * (c1[1] - c1[0]) + f * c1[1] * c1[2];
	cn[1] = c * c1[0] + d * c1[1] - c1[0] * c1[2];
	cn[2] = -b * c1[2] + c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Electronic Circuit of Freire et al Images
	http://www.macs.hw.ac.uk/~gabriel/auto/node218.html#SECTION002110000000000000000
***************************************************************************/

int	DoElectronicCctFreire(void)

    {
    double	i, c1[3], cn[3], ni, beta, gamma, r, a3, b3;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    ni  = param[0];
    beta = param[1];
    gamma = param[2];
    r  = param[3];
    a3 = param[4];
    b3 = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = (-(beta + ni) * c1[0] + beta * c1[1] - a3 * c1[0] * c1[0] * c1[0] + b3 * pow((c1[1] - c1[0]), 3)) / r;
	cn[1] = beta * c1[0] - (beta + gamma) * c1[1] - c1[2] - b3 * pow((c1[1] - c1[0]), 3);
	cn[2] = c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Elegant Chaos Equation 1.3 as a Fractal Map
	J. C. Sprott 2010
	Book Elegant Chaos
***************************************************************************/

int	DoElegantChaos(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10]; // x
    c1[1] = param[11]; // y
    c1[2] = param[12]; // z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = (1.0 - c1[0] * c1[0]) * c1[1] - sin(c1[0]);
	cn[2] = sqrt(sqr(b*sin(c1[0])) + sqr(a*cos(c1[1])));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 12.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Elegant Chaos in Fractional-Order System without Equilibria
	Donato Cafagna and Giuseppe Grassi 30 November 2013
***************************************************************************/

int	DoElegantChaosFractionalOrderSystem(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a  = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = -c1[1] - c1[0] * c1[2] - c1[1] * c1[2] + a;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 12.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Elegant Chaos, from Elegant Chaos Book - VF3
	Julien Clinton Sprott 2010
***************************************************************************/

int	DoElegantChaosVF3(void)

    {
    double	i, c1[3], cn[3], real, imag;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = 1.0;	// z

    real  = param[0];
    imag  = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] + sin(sqrt(i));
	cn[1] = c1[1] * cos(0.9 * c1[0]) - 0.1 * c1[0];
	cn[2] = imag * sin(c1[0]) + real * cos(c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 12.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Elementary Quadratic Chaotic Flows with No Equilibria – NE - 16
	Sajad Jafari, J.C. Sprott, S. Mohammad Reza Hashemi Golpayegani 16 January 2013
	https://www.researchgate.net/publication/236016065_Elementary_quadratic_chaotic_flows_with_no_equilibria
***************************************************************************/

int	DoElementaryQuadraticChaoticFlows(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -0.8 * c1[0] - 0.5 * c1[1] * c1[1] + c1[0] * c1[2] + a;
	cn[1] = -0.8 * c1[1] - 0.5 * c1[2] * c1[2] + c1[1] * c1[2] + a;
	cn[2] = -0.8 * c1[2] - 0.5 * c1[0] * c1[0] + c1[2] * c1[1] + a;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 12.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Elhadj-Sprott Chaotic Oscillator Images
***************************************************************************/

int	DoElhadjSprott(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = -a * c1[0] - b * c1[1] * c1[2];
	cn[2] = -c + c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Elhadj-Sprott-1 Chaotic Oscillator Images
***************************************************************************/

int	DoElhadjSprott1(void)

    {
    double	i, c1[3], cn[3], alpha, beta, a, m0, m1, fx, ha;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alpha = param[0];
    beta = param[1];
    a = param[2];
    m0 = param[3];
    m1 = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	fx = m1 * c1[0] + 0.5 * (m0 - m1) * (fabs(c1[0] + 1.0) - fabs(c1[0] - 1.0));
	ha = (fabs(c1[0]) >= a) ? fx : -fx;
	cn[0] = alpha * (c1[1] - ha);
	cn[1] = c1[0] - c1[1] + c1[2];
	cn[2] = -beta * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Emergence of a Square Chaotic Attractor through the Collision of Heteroclinic 2 Orbits
	Hector E. Gilardi-Velazquez, Rodolfo J. Escalante-Gonzalez and Eric Campos 26 March 2020
	Sent to ManpWIN by Hector E. Gilardi-Velazquez through https://www.researchgate.net/requests/r79813383
***************************************************************************/

int	DoEmergenceSquareChaoticAttractor(void)

    {
    double	i, c[3], cn[3], c1, c2, s1, s2, w;

    c[0] = param[10];	// x
    c[1] = param[11];	// y
    c[2] = param[12];	// z

    c1 = param[0];
    c2 = param[1];
    s1 = param[2];
    s2 = param[3];
    w = param[4];
    totpasses = 10;

    InitOscillator(c, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	if (c[0] + c[2] < 0.0)
	    {
	    cn[0] = -s1 * c[0] + w * c[1];
	    cn[1] = -w * c[0] - s1 * c[1];
	    cn[2] = c1 * c[2] + 0.2;
	    }
	else
	    {
	    cn[0] = -c2 * c[0] + 0.225;
	    cn[1] = s2 * c[1] - w * c[2];
	    cn[2] = w * c[1] + s2 * c[2];
	    }
	if (DisplayOscillator(c, cn, dt, ((DWORD)(i / 12.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Empirical Nonlinear Model Images
	MODELING AND EMPIRICAL NONLINEAR MODEL REDUCTION OF DISSIPATIVE DYNAMICAL SYSTEMS
	ERIK BOLLT May 26, 2006
***************************************************************************/

int	DoEmpiricalNonlinear(void)

    {
    double	i, c1[3], cn[3], alpha, beta, gamma, m0, m1, d, k, a, b, fc;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alpha = param[0];
    beta = param[1];
    gamma = param[2];
    m0 = param[3];
    m1 = param[4];
    d = param[5];
    k = param[6];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	a = -35.0 * sqr(d * d - 1.0) * (m0 - m1) / 16.0 / pow(d, 7);
	b = (45.0 * pow(d, 4) - 50.0 * sqr(d) + 21.0) * (m0 - m1) / 16.0 / pow(d, 5) + m1;
	fc = a * c1[0] * c1[0] * c1[0] + b * c1[0];
	cn[0] = k * alpha * (c1[1] - c1[0] - fc);
	cn[1] = k * (c1[0] - c1[1] + c1[2]);
	cn[2] = k * (-beta * c1[1] - gamma * c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Emulating Complex Business Cycles by Using an Electronic Analogue
	S. Bouali, A. Buscarino, L. Fortuna, M. Frasca, L.V. Gambuzza 19 February 2012
***************************************************************************/

int	DoEmulatingComplexBusiness(void)

    {
    double	i, c1[3], cn[3], k, mu, b, p, q, s;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    k = param[0];
    mu = param[1];
    b = param[2];
    p = param[3];
    q = param[4];
    s = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = k * c1[1] + mu * c1[0] * (b - c1[1] * c1[1]);
	cn[1] = -c1[0] + s * c1[2];
	cn[2] = p * c1[0] - q * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Energy Feed Back and Synchronous Dynamics of Hindmarsh–Rose Neuron Model with Memristor
	K Usha and P A Subha 10 January 2019
	http://cpb.iphy.ac.cn; http://iopscience.iop.org/cpb
***************************************************************************/

int	DoEnergyFeedBackSynchronousDynamicsHindmarshRoseNeuronModel(void)

    {
    double	t, c1[4], cn[4], a, b, errao, r, i, xc, alpha, beta, gamma, k1, k2 = 0.9, k3 = 0.5, fw;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    errao = param[2];
    r = param[3];
    i = param[4];
    xc = param[5];
    alpha = param[6];
    beta = param[7];
    gamma = param[8];
    k1 = param[9];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	fw = alpha * c1[3] * c1[3] + beta * c1[3] + gamma;
	cn[0] = c1[1] + a * c1[0] * c1[0] - c1[0] * c1[0] * c1[0] - c1[2] + i - k1 * fw * c1[0];
	cn[1] = 1 - b * c1[0] * c1[0] - c1[1];
	cn[2] = r * (errao * (c1[0] - xc) - c1[2]);
	cn[3] = k2 * c1[0] - k3 * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 25.0) % threshold), t, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Energy Resource System with Constraint Images
	Robust Adaptive Synchronisation of the Energy Resource 
	System with Constraint Duo Meng 5 June 2013
***************************************************************************/

int	DoEnergyResource (void)

    {
    double	i, c1[3], cn[3], m, n, a1, a2, b1, b2, b3, C1, c2, c3;

    c1[0] = param[10];	// x1
    c1[1] = param[11];	// x2
    c1[2] = param[12];	// x3

    m = param[0];
    n = param[1];
    a1 = param[2];
    a2 = param[3];
    b1 = param[4];
    b2 = param[5];
    b3 = param[6];
    C1 = param[7];
    c2 = param[8];
    c3 = param[9];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a1 * c1[0] * (1.0 - c1[0] / m) - a2 * (c1[1] + c1[2]);
	cn[1] = -b1 * c1[1] - b2 * c1[2] + b3 * c1[0] * (n - (c1[0] - c1[2]));
	cn[2] = C1 * c1[2] * (c2 * c1[0] - c3);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Energy Stochastic System Images
	Adaptive Neural Networks Synchronisation of a Four-Dimensional 
	Energy Resource Stochastic System DuoMeng 2 March 2014
***************************************************************************/

int	DoEnergyStochastic (void)

    {
    double	i, c1[4], cn[4], m, n, a1, a2, b1, b2, b3, C1, c2, c3, d1, d2, d3;

    c1[0] = 0.82;	// x1
    c1[1] = 0.29;	// x2
    c1[2] = 0.48;	// x3
    c1[3] = 0.1;	// x4

    m = param[0];
    n = param[1];
    a1 = param[2];
    a2 = param[3];
    b1 = param[4];
    b2 = param[5];
    b3 = param[6];
    C1 = param[7];
    c2 = param[8];
    c3 = param[9];

    d1 = 0.1;
    d2 = 0.06;
    d3 = 0.07;
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a1 * c1[0] * (1.0 - c1[0] / m) - a2 * (c1[1] + c1[2]) - d3 * c1[3];
	cn[1] = -b1 * c1[1] - b2 * c1[2] + b3 * c1[0] * (n - (c1[0] - c1[2]));
	cn[2] = C1 * c1[2] * (c2 * c1[0] - c3);
	cn[3] = d1 * c1[0] - d2 * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Chaos Entanglement Function Images
	Hopf Bifurcation Analysis in a New Chaotic System with
	Chaos Entanglement Function
	Zhang Jiangang, Chu Yandong, DuWenju, Chang Yingxiang, and An Xinlei
	22 July 2014
***************************************************************************/

int	DoEntangled(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e;

    c1[0] = param[10];	// x1
    c1[1] = param[11];	// x2
    c1[2] = param[12];	// x3

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] + b * c1[1];
	cn[1] = -b * c1[0] + a * c1[1] + d * sin(c1[2]);
	cn[2] = c * c1[2] + e * sin(c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Entropy Analysis and Image Encryption Application Based on a New Chaotic System Crossing a Cylinder
	Alaa Kadhim Farhan, Nadia Al-Saidi, Abeer Tariq Maolood, Fahimeh Nazarimehr and Iqtadar Hussain September 2019
	https://www.researchgate.net/publication/336144849_Entropy_Analysis_and_Image_Encryption_Application_Based_on_a_New_Chaotic_System_Crossing_a_Cylinder
***************************************************************************/

int	DoEntropyAnalysisImageEncryptionApplication(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2];
	cn[1] = c1[0] * c1[0] + c1[1] * c1[1] - a * a;
	cn[2] = 0.4 * c1[2] + 3 * c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Entropy Analysis and Neural Network-based Adaptive Control of a Non-Equilibrium 4D Chaotic System with Hidden Attractors
	Hadi Jahanshahi, Maryam Shahriari-Kahkeshi, Raúl Alcaraz, Xiong Wang, Vijay P. Singh and Viet-Thanh Pham 7 February 2019
	https://www.researchgate.net/publication/330944445
***************************************************************************/

int	DoEntropyAnalysisNeuralNetworkBasedAdaptiveControl(void)

    {
    double	i, c1[4], cn[4], a, b, c, e, f, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    e = param[3];
    f = param[4];
    g = param[5];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = c1[3];
	cn[3] = -a * c1[3] + b * c1[0] * c1[0] - c * c1[1] * c1[1] + e * c1[0] * c1[1] + f * c1[0] * c1[2] + g;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Equivalent circuit in function and topology to Chua’s circuit and the design methods of these circuits
	Zhang Xin-Guo, Sun Hong-Tao, Zhao Jin-Lan, Liu Ji-Zhao, Ma Yi-De, Han Ting-Wu 2014
***************************************************************************/

int	DoEquivalentCircuitChua(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 2.0 * c1[1] + a * c1[0] - b * c1[0] * c1[0] * c1[0];
	cn[1] = c * c1[0] - c1[1] + d * c1[2];
	cn[2] = -e * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Ergodic Time-Reversible Chaos for Gibbs' Canonical Oscillator
	William Graham Hoover, Julien Clinton Sprott, Puneet Kumar Patra April 13, 2015
***************************************************************************/

int	DoErgodicTimeReversible(void)

    {
    double	i, c1[3], cn[3], r, ni;
    int		type;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    r = param[0];
    ni = param[1];
    type = (int)param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] * (1.0 + c1[2] * ni) + ((type == 1) ? c1[1] : 0.0);
	cn[1] = -c1[0] - c1[2] * c1[1] - ((type == 1 || type == 2) ? c1[0] : 0.0);
	cn[2] = c1[1] * c1[1] - r - c1[0] * c1[1] * ni / ((type == 1 || type == 2) ? c1[0] : 1.0);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Evolving Chaos: Identifying New Attractors of the Generalised Lorenz Family-XY21
	Indranil Pan and Saptarshi Das 2016 ?
	https://arxiv.org/ftp/arxiv/papers/1803/1803.00052.pdf
***************************************************************************/

int	DoEvolvingChaosLorenzXY21(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] * c1[0] - c1[0] * c1[2] - c1[1] - c1[2];
	cn[1] = -c1[0] * (c1[2] - a);
	cn[2] = c1[0] * c1[1] - c1[2] * 8.0 / 3.0;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Evolving Chaos: Identifying New Attractors of the Generalised Lorenz Family-XZ11
	Indranil Pan and Saptarshi Das 2016 ?
	https://arxiv.org/ftp/arxiv/papers/1803/1803.00052.pdf
***************************************************************************/

int	DoEvolvingChaosLorenzXZ11(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[2] - b * c1[1] * (c1[0] - c1[1]);
	cn[1] = 28.0 * c1[0] - c1[0] * c1[2] - c1[1];
	cn[2] = c1[0] * c1[1] - c * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Evolving Chaos: Identifying New Attractors of the Generalised Lorenz Family-XYZ4
	Indranil Pan and Saptarshi Das 2016 ?
	https://arxiv.org/ftp/arxiv/papers/1803/1803.00052.pdf
***************************************************************************/

int	DoEvolvingChaosLorenzXYZ4(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[2] * (c1[0] - c1[1]);
	cn[1] = c1[0];
	cn[2] = c1[0] * c1[0] - b * c1[0] + c1[2] - c;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Evolving Chaos: Identifying New Attractors of the Generalised Lorenz Family-YZ76
	Indranil Pan and Saptarshi Das 2016 ?
	https://arxiv.org/ftp/arxiv/papers/1803/1803.00052.pdf
***************************************************************************/

int	DoEvolvingChaosLorenzYZ76(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 10.0 * (c1[1] - c1[0]);
	cn[1] = -c1[0] * (c1[2] - a);
	cn[2] = c1[0] * (c1[0] + b) - c * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Existence and Stability of Chimera States in a Minimal System of Phase Oscillators
	Mary Thoubaan and Peter Ashwin 24 October 2018
	http://aip.scitation.org/toc/cha/28/10
***************************************************************************/

int	DoExistenceStabilityChimeraStates(void)

    {
    double	i, c1[3], cn[3], a, b, p;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    p = param[0];
    a = param[1];
    b = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 2 * cos(c1[1]) * cos(c1[0]) - 2 * cos(c1[1]) * cos(c1[1]);
	cn[1] = 2 * sin(c1[1]) * sin(c1[0]);
	cn[2] = sin(c1[0]) + cos(c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Experimental Study of the Dynamic Behavior of a Double Scroll Circuit
	Christos K. Volos, Ioannis M. Kyprianidis, Ioannis N. Stouboulos and Antonios N. Anagnostopoulos - 2009
	https://www.academia.edu/920224/Non_Corpus_Parametrization_for_Studying_Long_range_Correlations_in_Natural_Languages?email_work_card=title
***************************************************************************/

int	DoExperimentalStudyDynamicBehaviorDoubleScrollCircuit(void)

    {
    double	i, c1[3], cn[3], a, b, c, k, fx;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    k = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	if (c1[0] > k) fx = 1;
	else if (c1[0] < -k) fx = -1; 
	else fx = c1[0] / k;
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = -a * (c1[0] + c1[1]) - b * c1[2] + c * fx;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Experimental Verification of Volt-Ampere Characteristic Curve for a Memristor-Based Chaotic Circuit
	Li Xiong, Xinguo Zhang and Yan Chen November 2019
***************************************************************************/

int	DoExperimentalVerificationVoltAmpereCharacteristicCurve(void)

    {
    double	i, c1[4], cn[4], a, b, p;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    p = param[0];
    a = param[1];
    b = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 4 * c1[0] + 16 * c1[1] - 0.1 * c1[3] - 2 * c1[0] * c1[3] * c1[3];
	cn[1] = c1[0] - c1[1] + c1[2];
	cn[2] = -15 * c1[1] - 0.5 * c1[2];
	cn[3] = c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Exponential Chen Chaotic Attractor Images
	A NEW CHAOTIC ATTRACTOR WITH QUADRATIC
	EXPONENTIAL NONLINEAR TERM FROM CHEN'S ATTRACTOR
	IFTIKHAR AHMED, CHUNLAI MU, AND FUCHEN ZHANG 2014
***************************************************************************/

int	DoExponentialChen(void)

    {
    double	i, c1[3], cn[3], a, b, c, e = exp(1.0);

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = (c - a) * c1[0] + c * c1[1] - c1[0] * c1[2];
	cn[2] = pow(e, (c1[0] * c1[1])) - b * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 1) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Extreme Multi-Stability Analysis of a Novel 5D Chaotic System with Hidden Attractors, Line Equilibrium, Permutation Entropy and its Secure Communication Scheme
	Abdul Jalil M. Khalaf, Hamid Reza Abdolmohammadi, Atefeh Ahmadi, Lazaros Moysis, Christos Volos, and Iqtadar Hussain November 2020
	Sent to ManpWIn by Atefeh Ahmadi through https://www.researchgate.net/publication/340290107
***************************************************************************/

int	DoExtremeMultistabilityAnalysis5D(void)

    {
    double	i, c1[5], cn[5], a;
    int		start;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v

    a = param[0];
    start = abs((int)param[1]);
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = start; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = c1[3];
	cn[3] = -0.16 * c1[3] * c1[3] - 0.86 * c1[3] + c1[4] + 3.35 * c1[0] * c1[2] - 0.36 * c1[1] * c1[2];
	cn[4] = 1.09 * c1[1] * c1[1] - 0.96 * c1[1] + 1.09 * c1[0] * c1[2] - 1.92 * c1[2] * c1[3];
	if (i > start)
	    {
	    if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 5, 1) < 0)
		break;
	    }
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Extreme Multistability Analysis of Memristor-Based Chaotic System and its Application in Image Decryption
	Chuang Li, Fuhong Mina, Qiusen Jin and Hanyuan Ma November 2017
	https://aip.scitation.org/doi/full/10.1063/1.5006593
***************************************************************************/

int	DoExtremeMultistabilityAnalysis(void)

    {
    double	i, c1[5], cn[5], a, b, c, m, n, m5;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v

    a = param[0];
    b = param[1];
    c = param[2];
    m = param[3];
    n = param[4];
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	m5 = m + n * c1[4] * c1[4];
	cn[0] = a * c1[2] - c1[0] * m5;
	cn[1] = c1[2] - c1[3];
	cn[2] = -b * (c1[1] + c1[0] + c1[2]);
	cn[3] = c * c1[1];
	cn[4] = c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 5, 1) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Extreme Multistability and Complex Dynamics of a Memristor-Based Chaotic System
	Hui Chang, Yuxia Li, Guanrong Chen and Fang Yuan November 22, 2019
	https://www.researchgate.net/publication/342936291
***************************************************************************/

int	DoExtremeMultistabilityComplexDynamics(void)

    {
    double	i, c1[4], cn[4], a, b, c, r;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u

    a = param[0];
    b = param[1];
    c = param[2];
    r = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[2] - (1 + c1[3] * c1[3]) * c1[0]);
	cn[1] = b * c1[1] - r * c1[2];
	cn[2] = c * (c1[1] - c1[0]);
	cn[3] = -c1[3] * c1[3] * c1[3] + 10 * (c1[3] + c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 1) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Extreme Multi-Stability in Hyperjerk Memristive System with Hidden Attractors  2D Version
	Dimitrios A. Prousalis, Christos K. Volos, Bocheng Bao, Efthymia Meletlidou, Ioannis N. Stouboulos and Ioannis M. Kyprianidis January 2019
	https://www.researchgate.net/publication/330338582
***************************************************************************/

int	DoExtremeMultiStabilityHyperjerkMemristiveSystem2D(void)

    {
    double	i, c1[3], cn[3], f, a, p;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    f = param[0];
    a = param[1];
    p = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = (1 - c1[0]) * a * sin(2 * PI * f * i);
	cn[1] = c1[0] + c1[1] * (p + sin(c1[0] * c1[0] - c1[1] * c1[1]));			// original formula  yn = x + x * (p - (x * x + y * y));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 2, 1) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Extreme Multi-Stability in Hyperjerk Memristive System with Hidden Attractors and its Adaptive Synchronisation Scheme
	Dimitrios A. Prousalis*, Christos K. Volos, Ioannis N. Stouboulos and Ioannis M. Kyprianidis 2018
	Received from the second author
***************************************************************************/

int	DoExtremeMultiStabilityHyperjerkMemristiveSystem(void)

    {
    double	i, c1[4], cn[4], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = c1[3];
	cn[3] = -c1[2] - a * c1[3] - b * sin(c1[2]) * c1[3] - (1 - c1[0]) * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 1) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Extremely Rich Dynamics from Hyperchaotic Hopeld Neural Network: Analog Circuit Implementation
	Z. Tabekoueng Njitacke, Sami Doubla Isaa, J. Kengne, A. Nguomkam Negou and Gervais Dolvis Leutcho - 26 March 2020
	https://www.researchgate.net/requests/r101766037 
***************************************************************************/

int	DoExtremelyRichDynamics(void)

    {
    double	i, c1[4], cn[4], w22, w33, w44, t1, t2, t3, t4;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    w22 = param[0];
    w33 = param[1];
    w44 = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	t1 = tanh(c1[0]);
	t2 = tanh(c1[1]);
	t3 = tanh(c1[2]);
	t4 = tanh(c1[3]);

	cn[0] = -c1[0] + t1 + .5 * t2 - 3 * t3 - t4;
	cn[1] = -c1[1] + w22 * t2 + 3 * t3;
	cn[2] = -c1[2] + 3 * t1 - 3 * t2 + w33 * t3;
	cn[3] = -100 * c1[3] + 100 * t1 + w44 * t4;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 1) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Fast Adaptive Image Encryption using Chaos by Dynamic State Variables Selection
	Daniel Roohbakhsh, Mahdi Yaghoobi March 2015
***************************************************************************/

int	DoFastAdaptive(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e, f, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -(a + b * c1[2]) * c1[0] - (a + b * c1[2]) * c1[0] * c1[0] * c1[0] - c * c1[1] + d * c1[2];
	cn[2] = c1[3];
	cn[3] = -e * c1[2] + f * (1.0 - c1[2] * c1[2]) * c1[3] + g * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 1) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Feigenbaum-Like Chaotic 3D System
	A New Feigenbaum-Like Chaotic 3D System
	Huitao Zhao, Yiping Lin and Yunxian Dai 13 March 2014
***************************************************************************/

int	DoFeigenbaumLike(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[1];
	cn[1] = c1[0] + c1[2] * c1[2];
	cn[2] = b + c * c1[0] + d * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	FPGA Based Chaotic Oscillator Designs with Different Numerical Algorithms
	Ismail Koyuncu, Murat Tuna and Murat Alcin November 2018
	Received from Researchgate
***************************************************************************/

int	DoFPGABasedChaoticOscillator(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - c1[0] - a * c1[2];
	cn[1] = c1[0] * c1[2] - c1[0];
	cn[2] = -c1[0] * c1[1] - c1[1] + b;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Field Coupling Synchronisation Between Chaotic Circuits via a Memristor
	Xiufang Zhang, Fuqiang Wu, Jun Ma, Aatef Hobiny, Faris Alzahrani and Guodong Ren 22 December 2019
	Sent to us by Jun Ma through https://www.researchgate.net/requests/r68561486
***************************************************************************/

int	DoFieldCouplingSynchronisation(void)

    {
    double	i, c1[7], cn[7], a, b, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w
    c1[6] = param[16];	// r

    a = param[0];
    b = param[1];
    k = param[2];
    totpasses = 10;

    InitOscillator(c1, 7);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - 0.5 * c1[2];
	cn[1] = -c1[0] + 0.4 * c1[1] + 0.8 * c1[2];
	cn[2] = 1.4 * (c1[0] + c1[2] - c1[2] * c1[2] * c1[2]) - (1.4 * a + 4.2 * b * c1[6] * c1[6]) * (c1[2] - c1[5]);
	cn[3] = c1[4] - 0.5 * c1[5];
	cn[4] = -c1[3] + 0.4 * c1[4] + 0.8 * c1[5];
	cn[5] = 1.4 * (c1[3] + c1[5] - c1[5] * c1[5] * c1[5]) - (1.4 * a + 4.2 * b * c1[6] * c1[6]) * (c1[5] - c1[2]);
	cn[6] = k * (c1[2] - c1[5]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 7, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Finance Chaotic Oscillator Images
***************************************************************************/

int	DoFinance(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = (1 / b - a) * c1[0] + c1[2] + c1[0] * c1[1];
	cn[1] = -b * c1[1] - c1[0] * c1[0];
	cn[2] = -c1[0] - c * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Finite-Time Observer for Nonlinear Systems Applications to Synchronization of Lorenz-Like Systems
	Ricardo Aguilar-Lopez and Juan L. Mata-Machuca 30 August 2016
***************************************************************************/

int	DoFiniteTimeObserver(void)

    {
    double	i, c1[4], cn[4], a, b, c, alpha, beta;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    alpha = param[3];
    beta = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = alpha * c1[0] - c1[1] - c * c1[2] + a * c1[2] * c1[2] / c1[0] - c1[0] * c1[3];
	cn[2] = beta * c1[0] + c * c1[1] - c1[2] - a * c1[1] * c1[2] / c1[0];
	cn[3] = -b * c1[3] + c1[0] * c1[1];

	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 40.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Finite Time Stabilization
	Sliding Mode Control in Finite Time Stabilization for Synchronisation of Chaotic Systems
	Zhan-Shan Zhao,ing Zhang, and Lian-Kun Sun 16 September 2013
***************************************************************************/

int	DoFiniteTime(void)

    {
    double	i, c1[3], cn[3], a1, a2, a3, h, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a1 = param[0];
    a2 = param[1];
    a3 = param[2];
    k = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	h = (fabs(c1[0]) < 1.0 / k) ? h = k * c1[0] : fabs(c1[0]) / c1[0];
	cn[2] = a1 * c1[0] + a2 * c1[1] + a3 * c1[2] + 12.0 * h;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	FitzHugh-Nagumo model
	http://www.scholarpedia.org/article/FitzHugh-Nagumo_model
	Richard FitzHugh 27 January 2012
***************************************************************************/

int	DoFitzHughNagumoe(void)

    {
    double	i, j, c1[3], cn[3], step, a, limit;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    step = param[0];
    limit = param[1];
    a = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (j = 0; j < limit; j += step)
	{
	curpass = (int)(j * totpasses / 3.0);
//	InitOscillator(c1, 3);						// pass in number of dimensions
	for (i = 0; i < iterations; i++)
	    {
	    double oldx = c1[0];
	    double oldy = c1[1];
	    if (user_data(GlobalHwnd) == -1)				// user pressed a key?
		return -1;
	    cn[0] = c1[0] - c1[0] * c1[0] * c1[0] / 3.0 - c1[1] + j;
	    cn[1] = 0.08 * (c1[0] + 0.7 - 0.8 * c1[1]);
//	    cn[2] = sqrt(sqr(sin(i) + sqr(cos(i))));
	    cn[2] = (sqrt(sqr(sin(oldx)) + sqr(cos(oldy)))) * a;
//	    cn[2] = 0.0;
	    if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 40.0) % threshold), i, 3, 0) < 0)
		break;
	    }
	PlotExtras();
	}
    return 0;
    }

/**************************************************************************
	Five-Dimensional Lorenz-Like System
	On a Five-Dimensional Chaotic System Arising from Double-Diffusive Convection in a Fluid Layer
	R. Idris, Siri, and I. Hashim 14 January 2013
***************************************************************************/

int	DoFiveDLorenzLike(void)

    {
    double	i, c1[5], cn[5], le, rs, r, pr, lambda, r01 = 0.0;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// w

    le = param[0];
    rs = param[1];
    r = param[2];
    pr = param[3];
    lambda = param[4];
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = pr * (c1[1] - c1[0] - c1[3]);
	cn[1] = r * c1[0] - c1[1] - (r - 1.0) * c1[0] * c1[2];
	cn[2] = lambda * (c1[0] * c1[1] - c1[2]);
	cn[3] = rs * c1[0] - c1[3] / le - (r01) * c1[0] * c1[4];
	cn[4] = lambda * (c1[0] * c1[3] - c1[4] / le);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Five-Dimensional Hyperchaotic System and its Circuit Simulation by EWB
	K. Kemih, M. Ghanes, R. Remmouche and A. Senouc 1 Jan. 2015
***************************************************************************/

int	DoFiveDCircuitSimulation(void)

    {
    double	i, c1[5], cn[5], a1, a2, a3, a4, a5;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z
    c1[3] = param[13];    // v
    c1[4] = param[14];    // w

    a1 = param[0];
    a2 = param[1];
    a3 = param[2];
    a4 = param[3];
    a5 = -9.5;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a1 * (c1[1] - c1[0]) + c1[1] * c1[2] * c1[3] * c1[4];
	cn[1] = a2 * (c1[0] + c1[1]) - c1[0] * c1[2] * c1[3] * c1[4];
	cn[2] = -c1[2] + 0.1 * c1[0] * c1[0];
	cn[3] = -a3 * c1[3] + c1[0] * c1[1] * c1[2] * c1[4];
	cn[4] = -a4 * (c1[4] - c1[3]) + a5 * c1[0] + c1[0] * c1[1] * c1[2] * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Fluid Instabilities Images
	A Parametric Investigation of Geometric Variation on
	Fluid Dynamic Instabilities in Axial Compression Systems
	Ananth SivaramakrishnanMalathi and A. Kushari 2 October 2012
***************************************************************************/

int	DoFluidInstabilities(void)

    {
    double	i, c1[3], cn[3], h, w, alpha, m, b, l, k, p0;

    c1[0] = param[10];	// p
    c1[1] = param[11];	// f
    c1[2] = param[12];	// a

    p0 = 0.3;

    h = param[0];
    w = param[1];
    alpha = param[2];
    m = param[3];
    b = param[4];
    l = param[5];
    k = param[6];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = w / h / 4.0 / b * b * (c1[1] / w - 1.0 / w * sqrt(fabs(2 * c1[0] / k))) * h / l;
	cn[1] = (-(c1[0] - p0) / h + 1.0 + 1.5 * (c1[1] / w - 1.0) * (1.0 - c1[2] * c1[2] / 2) - 0.5 * pow(c1[1] / w - 1, 3.0)) * h / l;
	cn[2] = c1[2] / 2.0 * (1 - pow(c1[1] / w - 1.0, 2.0) - c1[2] * c1[2] / 4.0) * 3.0 * c1[2] * h / (1.0 + m * alpha) / w;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Flux of Fluids in 5 Dimensions Images
	Function Projective Synchronisation of Two Identical New Hyperchaotic Systems
***************************************************************************/

int	DoFluxOfFluids5D(void)

    {
    double	i, c[5], cn[5], re;

    c[0] = param[10]; // x
    c[1] = param[11]; // y
    c[2] = param[12]; // z
    c[3] = param[13]; // w
    c[4] = param[14]; // q

    re = param[0];				// number of Reynolds

    InitOscillator(c, 5);			// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)	// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = -2.0 * c[0] + 4.0 * c[1] * c[2] + 4.0 * c[3] * c[4];
	cn[1] = -9.0 * c[1] + 3.0 * c[0] * c[2];
	cn[2] = -5.0 * c[2] - 7.0 * c[0] * c[1] + re;
	cn[3] = -5.0 * c[3] - c[0] * c[4];
	cn[4] = -c[4] - 3.0 * c[0] * c[3];
	if (DisplayOscillator(c, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Forced Synchronisation of a Self-Sustained Chaotic Oscillator
	J. S. Gonzalez Salas, E. Campos Cantón, F. C. Ordaz Salazar, and I. Campos Cantu 30 June 2008
	https://aip.scitation.org/doi/pdf/10.1063/1.2947661 - that is not the site I saw. This one is paid.
***************************************************************************/

int	DoForcedSynchronisation(void)

    {
    double	i, c1[3], cn[3], delta, alpha, epsilon, gamma, sigma, f;

    c1[0] = param[10]; // x
    c1[1] = param[11]; // y
    c1[2] = param[12]; // z

    delta = param[0];
    alpha = param[1];
    epsilon = param[2];
    gamma = param[3];
    sigma = param[4];

    InitOscillator(c1, 3);			// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)	// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1];
	cn[1] = -c1[0] - delta * c1[1] + c1[2];
	f = alpha * sin(epsilon * i) * c1[2] + c1[1] - 0.7 * c1[0];	// this 'f' was my pure, free invention (Marcus)
	cn[2] = gamma * (alpha * f - c1[2]) - sigma * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Four-Dimensional Autonomous Dynamical Systems with Conservative Flows - Two-Case Study
	Shijian Cang, Aiguo Wu, Zenghui Wang and Zengqiang Chen and Marcus Rezende 21 June 2017 and 24/05/2018
	https://www.researchgate.net/publication/318169724_Four-dimensional_autonomous_dynamical_systems_with_conservative_flows_two-case_study
***************************************************************************/

int	DoFourDimensionalAutonomousDynamicalSystems(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10]; // x
    c1[1] = param[11]; // y
    c1[2] = param[12]; // z
    c1[3] = param[13]; // w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];

    InitOscillator(c1, 4);			// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)	// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c * c1[1] * c1[3];
	cn[1] = c1[1] * c1[2];
	cn[2] = -c1[1] * c1[1] + d * c1[3];
	cn[3] = -c * c1[0] * c1[1] - d * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Four Memristor Chaotic Oscillators Images
	Compound Synchronisation of four memristor chaotic oscillator systems
	and secure communication
	Junwei Sun, Yi Shen, Quan Yin, and Chengjie Xu  11 March 2013
***************************************************************************/

int	DoFourMemristor(void)

    {
    double	i, c[4], cn[4], a1, a2, a3, a4, a5;

    c[0] = param[10];	// x
    c[1] = param[11];	// y
    c[2] = param[12];	// z
    c[3] = param[13];	// w

    a1 = param[0];
    a2 = param[1];
    a3 = param[2];
    a4 = param[3];
    a5 = param[4];

    InitOscillator(c, 4);			// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)	// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = a1 * c[1] + a2 * c[0] - a3 * c[0] * c[3] * c[3];
	cn[1] = c[0] - c[1] + c[2];
	cn[2] = -a4 * c[1] - a5 * c[2];
	cn[3] = c[0];
	if (DisplayOscillator(c, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Four-Wing Chaotic Attractor Generated from a New 3-D Quadratic Autonomous System
	Guoyuan Qi, Guanrong Chen, Michae¨l Antonie van Wyk, Barend Jacobus van Wyk and Yuhui Zhang 2 January 2007
***************************************************************************/

int	DoFourWingChaoticAttractor(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];

    InitOscillator(c1, 3);			// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)	// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = a * (c1[1] - c1[0]) + e * c1[1] * c1[2];
	cn[1] = c * c1[0] + d * c1[1] - c1[0] * c1[2];
	cn[2] = -b * c1[2] + c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Four-Wing Attractors in a Novel Chaotic System with Hyperbolic Sine Nonlinearity
	Zhen Wang, Christos Volos, Sifeu Takougang Kingni, Ahmad Taher Azar and Viet-Thanh Pham 7 December 2016
	https://www.researchgate.net/publication/311964482_Four-wing_attractors_in_a_novel_chaotic_system_with_hyperbolic_sine_nonlinearity
***************************************************************************/

int	DoFourWingAttractors(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];

    InitOscillator(c1, 3);			// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)	// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = -a * c1[0] + c1[1] * c1[2];
	cn[1] = -sinh(c1[1]) + c1[0] * c1[2];
	cn[2] = c1[2] - c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Four Wing 1 Chaotic Oscillator Images
***************************************************************************/

int	DoFourWing1(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    k = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] - b * c1[1] * c1[2];
	cn[1] = -c * c1[1] + c1[0] * c1[2];
	cn[2] = k * c1[0] - d * c1[2] + c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Four Wing 2 Chaotic Oscillator Images
***************************************************************************/

int	DoFourWing2(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] + b * c1[1] + c * c1[1] * c1[2];
	cn[1] = d * c1[1] - c1[0] * c1[2];
	cn[2] = e * c1[2] + f * c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Four Wing 3 Chaotic Oscillator Images
***************************************************************************/

int	DoFourWing3(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] + c1[1] + c1[1] * c1[2];
	cn[1] = c1[1] * c1[2] - c1[0] * c1[2];
	cn[2] = -c1[2] - a * c1[0] * c1[1] + 1.0;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	FPGA Implementation of Adaptive Sliding Mode Control and Genetically Optimised PID Control for Fractional-Order Induction Motor System with Uncertain Load
	Karthikeyan Rajagopal, Guessas Laarem, Anitha Karthikeyan and Ashokkumar Srinivasan 2017
	https://link.springer.com/article/10.1186/s13662-017-1341-9
***************************************************************************/

int	DoFPGAImplementationAdaptiveSlidingModeControl(void)

    {
    double	i, c1[4], cn[4];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 10.0 * (c1[1] - c1[0]) + c1[3];
	cn[1] = 15.0 * c1[0] - c1[0] * c1[2];
	cn[2] = 4.0 * c1[0] * c1[0] - 2.5 * c1[2];
	cn[3] = -10.0 * c1[1] - c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	FPGA Implementation of a Novel Chaotic Oscillator System With Odd and Even Symmetry
	M.F. Tolba, Ahmed S. Elwakil, Hammam Orabi, Hammam Orabi, Mohammed Elnawawy, Fadi A. Aloul and  Ahmed G Radwan, 2020
	Received from Fadi A. Aloul through https://www.researchgate.net/publication/339418875
***************************************************************************/

int	DoFPGAImplementationNovelChaoticOscillator(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[0] + c1[1] * fabs(c1[2]) / c1[2];
	cn[1] = c1[0];
	cn[2] = 1 - fabs(c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	FPGA Tabanh Farkh Numerik Algoritmalar Ile Kaotik Osilator Tasarimlari
	Ismail Koyuncu, Murat Tuna and Murat Alcin November 2018
***************************************************************************/

int	DoFPGATabanhFarkhNumerik(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - c1[0] - a * c1[2];
	cn[1] = c1[0] * c1[2] - c1[0];
	cn[2] = -c1[0] * c1[1] - c1[1] + b;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Fractional Order Biological Snap Oscillator: Analysis and Control 
	Pushali Trikha , Emad E. Mahmoud, Lone Seth Jahanzaib, R.T. Matoog abd Mahmoud Abdel-Aty - 30 January 2021
	https://www.researchgate.net/publication/349493191
***************************************************************************/

int	DoFractionalOrderBiologicalSnapOscillator(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = a * c1[2];
	cn[2] = c1[3];
	cn[3] = -c1[0] - b * c1[2] - c * c1[1] - c1[3] + d * c1[1] * (1 - c1[0] * c1[0] + e * pow(c1[0], 4) - f * pow(c1[0], 6));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 35.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Fractional-Order Form of a System with Stable Equilibria and its Synchronisation
	Xiong Wang, Adel Ouannas, Viet-ThanhPham and Hamid Reza Abdolmohammad 2018
	https://www.researchgate.net/publication/322536031_A_fractional-order_form_of_a_system_with_stable_equilibria_and_its_synchronization
***************************************************************************/

int	DoFractionalOrderFormSystem(void)

    {
    double	i, c1[3], cn[3], a, b, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    e = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[2] - c1[0]);
	cn[1] = -c1[0] * c1[2] + e;
	cn[2] = c1[0] * c1[1] - b * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Fractional Order-Induced Bifurcations in a Delayed Neural Network with Three Neurons
	Chengdai Huang, Huanan Wang and Jinde Cao  MARCH 27 2023
	https://pubs.aip.org/aip/cha/article/33/3/033143/2881445....https://doi.org/10.1063/5.0135232
	Authors email: huangchengdai@163.com and chdhuang1986@xynu.edu.cn
***************************************************************************/

int	DoFractionalOrderInducedBifurcations(void)

    {
    double	i, c1[3], cn[3], k11, k12, k13, k21, k22, k23, k31, k32, k33, l1, l2, l3, f1, f2, f4, f5, f6;

    c1[0] = cn[0] = param[10];	// x
    c1[1] = cn[1] = param[11];	// y
    c1[2] = cn[2] = param[12];	// z

    k11 = param[0];
    k12 = param[1];
    k13 = param[2];
    k21 = param[3];
    k22 = param[4];
    k23 = param[5];
    k31 = param[6];
    k32 = param[7];
    k33 = param[8];
    l1 = param[9];
    l2 = 1.4; l3 = 1.2;
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	f1 = tanh(c1[0]);
	f2 = tanh(c1[1]);
	f4 = tanh(cn[0]);
	f5 = tanh(cn[1]);
	f6 = tanh(cn[2]);

	cn[0] = -l1 * c1[0] + k11 * f1 + k12 * f5 + k12 * f6;
	cn[1] = -l2 * c1[1] + k22 * f2 + k21 * f4 + k23 * f6;
	cn[2] = -l3 * c1[2] + k33 * f6 + k31 * f4 + k32 * f5;
	if (i > 2000.0)
	    if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 3, 0) < 0)
		break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Fractional Order Memristor No Equilibrium Chaotic System with Its Adaptive Sliding Mode 
	Synchronization and Genetically Optimized Fractional Order PID Synchronization
	Karthikeyan Rajagopal, Laarem Guessas, Anitha Karthikeyan, Ashokkumar Srinivasan and Girma Adam 26 March 2017
***************************************************************************/

int	DoFractionalOrderMemristor(void)

    {
    double	i, c1[4], cn[4], a, b, c, a1, b1;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    a1 = param[3];
    b1 = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[2] + c1[0] * c1[1];
	cn[1] = 1.0 - c1[0] * c1[0] - c1[2] * c1[2] - c1[3] * c1[3];
	cn[2] = -b * c1[0] + c1[1] * c1[2];
	cn[3] = c * c1[2] - c1[3] - (a1 + b1 * c1[0] * c1[0]) * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 4, 2) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Fractional-Order PWC Systems Without Zero Lyapunov Exponents
	Marius-F. Danca, Michal Fekckan, Nikolay V. Kuznetsov and Guanrong Chen 8 February 2018
	https://www.researchgate.net/publication/323013661_Fractional-order_PWC_systems_without_zero_Lyapunov_exponents
***************************************************************************/

int	DoFractionalOrderPWCSystems(void)

    {
    double	i, c1[4], cn[4], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[0] + c1[1];
	cn[1] = -c1[2] * fabs(c1[0]) / c1[0] + c1[3];
	cn[2] = fabs(c1[0]) - a;
	cn[3] = -b * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 4, 2) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Fractional Order Simple Chaotic Oscillator with Saturable Reactors and Its Engineering Applications
	Karthikeyan Rajagopal, Sajad Jafari, Sezgin Kacar, Anitha Karthikeyan and Akif Akgul 2018/12/18
	https://www.researchgate.net/publication/332329166
***************************************************************************/

int	DoFractionalOrderSimpleChaoticOscillator(void)

    {
    double	i, c1[3], cn[3], a1, a2, a3, a4, a5, a6, a7;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a1 = param[0];
    a2 = param[1];
    a3 = param[2];
    a4 = param[3];
    a5 = param[4];
    a6 = param[5];
    a7 = param[6];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -a1 * c1[1] - a2 * c1[0] * c1[0] * c1[0] - a3 * c1[0] * c1[2] * c1[2] + a4 * cos(i);
	cn[2] = -a5 * c1[0] * c1[0] * c1[2] - a6 * c1[2] * c1[2] * c1[2] + a7;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 2) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Fractional-Order Simplest Memristor-based Chaotic Circuit with New Derivative
	Jingya Ruan, Kehui Sun, Jun Mou, Shaobo He and Limin Zhang 5 January 2018
	https://www.researchgate.net/publication/322230263_Fractional-order_simplest_memristor-based_chaotic_circuit_with_new_derivative
***************************************************************************/

int	DoFractionalOrderSimplestMemristor(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[0] / 3.0 + a * (c1[1] - c1[2] * c1[2] * c1[1]);
	cn[2] = -c1[1] - 0.6 * c1[2] + c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 2) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Fractional Symbolic Network Entropy Analysis for the Fractional-Order Chaotic Systems
	Shaobo He, Kehui Sun and, Xianming Wu May 2019
	Received from the author Kehui Sun through Research Gate
***************************************************************************/

int	DoFractionalSymbolicNetworkEntropyAnalysis(void)

    {
    double	i, c1[3], cn[3], e, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    e = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] + c1[1] * c1[2];
	cn[1] = -c1[0] * c1[2] + c1[1] * c1[2];
	cn[2] = -e * c1[2] - c1[0] * c1[1] + b;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 2) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Frequency Limitations from the Circuit Realisation of Saw-Tooth Based Multi-Scroll Oscillators
	R. Trejo-Guerra, E. Tlelo-Cuautle, J. M. Muñoz-Pacheco and C. Sánchez-López July 25 - 27, 2011
	https://www.researchgate.net/requests/r43436777
***************************************************************************/

int	DoFrequencyLimitationsCircuitRealisation(void)

    {
    double	i, c1[3], cn[3], b, p, k, alpha, beta, gamma, epsilon, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alpha = param[0];
    beta = param[1];
    gamma = param[2];
    epsilon = param[3];
    b = param[4];
    p = param[5];
    k = param[6];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	if (fabs(c1[0]) <= b * p) 
	    f = -epsilon * c1[0];
	else if (fabs(c1[0]) <= (1 + 2 * k) * b * p && fabs(c1[0]) > (2 * k - 1) * b * p)
	    f = epsilon * (2 * k * b * p * fabs(c1[0]) / c1[0] - c1[0]);
	else
	    f = epsilon * (b * p * fabs(c1[0]) / c1[0] * (2 * k - 1) - c1[0]);
	cn[0] = alpha * c1[1] + f;
	cn[1] = alpha * c1[0] - gamma * c1[1] - alpha * c1[2];
	cn[2] = beta * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 2) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Fully Integrated Memristor and Its Application on the Scroll-Controllable Hyperchaotic System
	Jie Jin1 and Li Cui 10 January 2019
	https://www.hindawi.com/journals/complexity/2019/4106398/
***************************************************************************/

int	DoFullyIntegratedMemristor(void)

    {
    double	i, c1[4], cn[4], a, b, beta, alpha, fx, ww;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    beta = param[0];
    alpha = param[1];
    a = param[2];
    b = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	ww = a + 3 * b * c1[3] * c1[3];
	fx = (c1[0] < 0) ? -1 : ((c1[0] > 0) ? 1 : 0);
	cn[0] = c1[1];
	cn[1] = c1[2] - alpha * ww * c1[2];
	cn[2] = -beta * (c1[0] + c1[1] + c1[2]) + fx;
	cn[3] = c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 4, 2) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Fuzzy Synchronisation for Fractional Order Chaos
	Linear Matrix Inequality Based Fuzzy Synchronisation for Fractional Order Chaos
	Bin Wang, Hongbo Cao, Yuzhu Wang, and Delan Zhu 27 March 2015
***************************************************************************/

int	DoFuzzySynchronisation(void)

    {
    double	i, c1[4], cn[4], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = (c - a) * c1[0] - c1[0] * c1[2] + c * c1[1];
	cn[2] = c1[0] * c1[1] - b * c1[2];
	cn[3] = c1[0] + (1.0 - 3.0 * c1[2] * c1[2] - c1[3]) * c1[2] - a * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 4, 2) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Gaussian mixture model based cost function for parameter estimation of chaotic biological systems
	Yasser Shekofteh, Sajad Jafari, Julien Clinton Sprott 397 and
	S. Mohammad Reza Hashemi Golpayegani, Farshad Almasganj 24 May 2014
***************************************************************************/

int	DoGaussianMixture(void)

    {
    double	t, c[3], cn[3], i, ro;

    c[0] = param[10];	// x
    c[1] = param[11];	// y
    c[2] = param[12];	// z

    ro = param[0];
    i = param[1];
    totpasses = 10;

    InitOscillator(c, 3);							// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 3.0 * c[0] * c[0] - c[0] * c[0] * c[0] + c[1] - c[2] + i;
	cn[1] = 1.0 - 5.0 * c[0] * c[0] - c[1];
	cn[2] = ro * (4.0 * (c[0] + 1.6) - c[2]);
	if (DisplayOscillator(c, cn, dt, ((DWORD)(t / 5.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Gene Networks Images
	ON THE CHAOS IN GENE NETWORKS 
	VITALY A. LIKHOSHVAI, STANISLAV I. FADEEV, VLADISLAV V. KOGAI, and TAMARA M. KHLEBODAROVA
	1 February 2013
***************************************************************************/

double	CalcF3(double f0, double b)
    {
    if (b <= 0.0 || b >= 1.0)
	return 0.0;
    if (b < 0.125) return (f0 * b);
    if (b < 0.375) return (f0 * (0.25 - b));
    if (b < 0.500) return (f0 * (0.50 - b));
    if (b < 0.625) return (f0 * (b - 0.50));
    if (b < 0.750) return (f0 * (0.75 - b));
    if (b < 0.875) return (f0 * (b - 0.75));
    return (f0 * (1.0 - b));
    }

int	DoGeneNetworks(void)

    {
    double	i, c1[3], cn[3], r, f0;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    r = param[0];

    totpasses = 10;

    f0 = 8.0 * r * r * r;
    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = CalcF3(f0, c1[2]) - c1[0];
	cn[1] = CalcF3(f0, c1[0]) - c1[1];
	cn[2] = CalcF3(f0, c1[1]) - c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Generalised Combination Complex Synchronisation for Fractional-Order Chaotic Complex Systems
	PCuimei Jiang, Shutang Liu and DaWang 24 July 2015
***************************************************************************/

int	DoGenCombinationComplexSync(void)

    {
    double	i, c1[8], cn[8], a1, a2, a3, a4, a5, b1, b2, b3, b4;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w
    c1[6] = param[16];	// p
    c1[7] = param[17];	// q

    a1 = param[0];
    a2 = param[1];
    a3 = param[2];
    a4 = param[3];
    a5 = param[4];
    b1 = param[5];
    b2 = param[6];
    b3 = param[7];
    b4 = param[8];
    totpasses = 10;

    InitOscillator(c1, 9);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a1 * (c1[1] - c1[0]) + c1[3];
	cn[1] = a4 * c1[0] - c1[0] * c1[2] + a3 * c1[1];
	cn[2] = c1[0] * c1[1] - a2 * c1[2];
	cn[3] = c1[1] * c1[2] + a5 * c1[3];				// that is the first master fractional order system
	cn[4] = -c1[5] - c1[6];
	cn[5] = c1[4] + b1 * c1[5] + c1[7];
	cn[6] = b2 + c1[4] * c1[6];
	cn[7] = -b3 * c1[6] + b4 * c1[7];				// that is the second master fractional order system
									// the third system, a 3D slave fractional and complex order system was not implemented. 
									// complex like (a + b * i), i = sqr(-1)
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 9, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Generalised Dynamic Switched Synchronisation between Combinations of Fractional-Order Chaotic Systems
	Wafaa S. Sayed, MohebM. R. Henein, Salwa K. Abd-El-Hafiz, and Ahmed G. Radwan 16 February 2017
***************************************************************************/

int	DoGenDynamicSwitchedSync(void)

    {
    double	i, c[9], cn[9], a1, a2, a3, b1, b2, b3, c1, c2, c3, d1, d2 = 1, f2 = 4, g1 = 3.21, g2 = 4.0;
    double	fx, fy, fz;

    c[0] = param[10];	// x
    c[1] = param[11];	// y
    c[2] = param[12];	// z
    c[3] = param[13];	// u
    c[4] = param[14];	// v
    c[5] = param[15];	// w
    c[6] = param[16];	// p
    c[7] = param[17];	// q
    c[8] = param[18];	// q

    a1 = param[0];
    a2 = param[1];
    a3 = param[2];
    b1 = param[3];
    b2 = param[4];
    b3 = param[5];
    c1 = param[6];
    c2 = param[7];
    c3 = param[8];
    d1 = param[9];
    totpasses = 10;

    InitOscillator(c, 9);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	fx = 0.5 * (fabs(c[0] + 1.0) - fabs(c[0] - 1.0));
	fy = 0.5 * (fabs(c[1] + 1.0) - fabs(c[1] - 1.0));
	fz = 0.5 * (fabs(c[2] + 1.0) - fabs(c[2] - 1.0));
	cn[0] = -c[0] + a1 * fx - g1 * fy - g1 * fz;
	cn[1] = -c[1] - g1 * fx + b1 * fy - d1 * fz;
	cn[2] = -c[2] - g1 * fx + d1 * fy + c1 * fz;
	cn[3] = -a2 * c[3] + d2 * c[4] * c[4];
	cn[4] = b2 * c[4] - g2 * c[3] * c[5];
	cn[5] = -c2 * c[5] + f2 * c[3] * c[4];
	cn[6] = c[8] + (c[7] - a3) * c[6];
	cn[7] = 1.0 - b3 * c[7] - c[6] * c[6];
	cn[8] = -c[6] - c3 * c[8];
	if (DisplayOscillator(c, cn, dt, ((DWORD)i % threshold), i, 9, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Generalised Polynomial Chaos for Analysing the Stability of Oscillators Images
	Roland Pulch July 2007
	https://www.newton.ac.uk/files/seminar/20070703100010301-150734.pdf
***************************************************************************/

int	DoGenPolynomialChaos(void)

    {
    double	i, c1[3], cn[3], a, b, g, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    g = param[2];
    k = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = a * sin(2.0 * PI * i) - b * c1[1] - g * c1[0] + k * c1[0] * c1[0] * c1[0];
	cn[2] = (c1[0] * c1[1]) - (b * c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Generalised Stability Theorem for Discrete-Time Nonautonomous Chaos System with Applications
	Mei Zhang, Danling Wang, Lequan Min, and Xue Wang & Marcus Rezende 7 July 2015; 08/01/2017
***************************************************************************/

int	DoGeneralizedStabilityTheorem(void)

    {
    double	i, c1[4], cn[4];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 1.675 * c1[0] * cos(c1[0]) * sin(c1[1]) - sin(c1[0]) * cos(c1[2]) + cos(c1[1]) * sin(c1[2]);
	cn[1] = 5.125 * sin(c1[1]) - 52.0 * cos(c1[2]) * sin(c1[0]) + c1[1] / (c1[3] + 1.0) * sin(c1[2]);
	cn[2] = sin(c1[0] + c1[1]) + sin(c1[2]);
	cn[3] = cos(c1[0] + c1[3]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Generated by the Second-Generation Current Conveyor Circuit
	Ting Zuo, Kehui Sun, Xingxing Ai and Huihai Wang OCTOBER 2014
	https://www.researchgate.net/profile/Kehui_Sun/publication/266378208_High-Order_Grid_Multiscroll_Chaotic_Attractors_Generated_by_the_Second-Generation_Current_Conveyor_Circuit/links/5547644b0cf249186bb0e8d3/High-Order-Grid-Multiscroll-Chaotic-Attractors-Generated-by-the-Second-Generation-Current-Conveyor-Circuit.pdf
***************************************************************************/

int	DoGeneratedSecondGenerationCurrentConveyorCircuit(void)

    {
    double	i, c1[4], cn[4], gx, gy, gz, gw, fx, fx1, fx2, fx3;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	gx = 0.5 * (1 + fabs(c1[0] - 0.5)) / (c1[0] - 0.5);
	gy = 0.5 * (1 + fabs(c1[1] - 0.5)) / (c1[1] - 0.5);
	gz = 0.5 * (1 + fabs(c1[2] - 0.5)) / (c1[2] - 0.5);
	gw = 0.5 * (1 + fabs(c1[3] - 0.5)) / (c1[3] - 0.5);
	fx1 = 4 * (fabs(c1[0]) / c1[0]);
	fx2 = 4 * (fabs(c1[0] + 1) / (c1[0] + 1));
	fx3 = 4 * (fabs(c1[0] - 1) / (c1[0] - 1));
	fx = fx1 + fx2 + fx3;

	cn[0] = c1[1] - gy - 0.5;
	cn[1] = c1[2] - gz - 0.5;
	cn[2] = c1[3] - gw - 0.5;
	cn[3] = fx - 7.9 * c1[0] - 9.19 * (c1[1] - gy) - 4 * (c1[2] - gz) - 7.278 * (c1[3] - gw) + 10.734;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multi-Folded Hidden Chua’s Attractors: Two-case study (Eq. 30)
	Ning Wang, Mengkai Cui, Xihong Yu, Yufan Shan, and Quan Xu, 9 November 2023
	https://doi.org/10.1016/j.chaos.2023.114242
	https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
***************************************************************************/

int	DoMultiFoldedHiddenChuasAttractors30(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, xz1, xz2;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	xz1 = (c1[0] * c1[0] - c1[2] * c1[2]);
	xz2 = 2 * (c1[0] * c1[0] + c1[2] * c1[2]);

	cn[0] = (a * c1[0] * c1[1] - b * c1[1] * c1[2] - a * c1[0] * (d + 1) * xz1 - a * c1[0] * (c - d) * tanh(xz1)) / xz2;
	cn[1] = xz1 - c1[1] + 2 * c1[0] * c1[2];
	cn[2] = (-b * c1[0] * c1[1] - a * c1[1] * c1[2] + a * c1[2] * (d + 1) * xz1 + a * c1[2] * (c - d) * tanh(xz1)) / xz2;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multi-Folded Hidden Chua’s Attractors: Two-case study (Eq. 33)
	Ning Wang, Mengkai Cui, Xihong Yu, Yufan Shan, and Quan Xu, 9 November 2023
	https://doi.org/10.1016/j.chaos.2023.114242
	https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
***************************************************************************/

int	DoMultiFoldedHiddenChuasAttractors33(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = (a * (c1[0] * c1[0] - c1[2] * c1[2]) * (c1[1] - (d + 1) * (c1[0] * c1[0] * c1[0] - 3 * c1[0] * c1[2] * c1[2]) - (c - d) * tanh(c1[0] * c1[0] * c1[0] - 3 * c1[0] * c1[2] * c1[2])) - 2 * b * c1[0] * c1[1] * c1[2]) / 3 / sqr(c1[0] * c1[0] + c1[2] * c1[2]);
	cn[1] = c1[0] * c1[0] * c1[0] - 3 * c1[0] * c1[2] * c1[2] - c1[1] + 3 * c1[0] * c1[0] * c1[2] - c1[2] * c1[2] * c1[2];
	cn[2] = (-b * c1[1] * (c1[0] * c1[0] - c1[2] * c1[2]) - 2 * a * c1[0] * c1[2] * (c1[1] - (d + 1) * (c1[0] * c1[0] * c1[0] - 3 * c1[0] * c1[2] * c1[2]) - (c - d) * tanh(c1[0] * c1[0] * c1[0] - 3 * c1[0] * c1[2] * c1[2]))) / 3 / sqr(c1[0] * c1[0] + c1[2] * c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Generation and Suppression of a New Hyperchaotic Nonlinear Model with Complex Variables
	Emad E.Mahmoud 1 September 2014
	https://www.sciencedirect.com/science/article/pii/S0307904X14000821?dgcid=raven_sd_recommender_email
***************************************************************************/

int	DoGenerationSuppressionNewHyperchaoticNonlinearModel(void)

    {
    double	i, c1[6], cn[6], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 6);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[2] - c1[0]);
	cn[1] = a * (c1[3] - c1[1]);
	cn[2] = (c - a) * c1[0] - c1[0] * c1[4] + c1[1] * c1[5] + c * c1[2];
	cn[3] = (c - a) * c1[1] - c1[1] * c1[4] - c1[0] * c1[5] + c * c1[3];
	cn[4] = c1[0] * c1[2] + c1[1] * c1[3] - b * c1[4];
	cn[5] = c1[0] * c1[3] - b * c1[5];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Generating Hidden Extreme Multistability in Memristive Chaotic Oscillator via Micro-Perturbation
	Lu Wang, Sen Zhang and Yicheng Zeng 15 May 2018.
	https://www.researchgate.net/publication/325050390_Generating_hidden_extreme_multistability_in_memristive_chaotic_oscillator_via_micro-perturbation
***************************************************************************/

int	DoGeneratingHiddenExtremeMultistability(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, alpha, beta;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    alpha = param[4];
    beta = param[5];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - c1[2];
	cn[1] = -a * c1[0] + c * c1[1];
	cn[2] = b * (c1[0] - c1[2] * (alpha + 3 * beta * c1[3] * c1[3])) - d;
	cn[3] = c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Generating Tri-Chaos Attractors with Three Positive Lyapunov Exponents in New Four Order System via Linear Coupling
	Shih-Yu Li, Sheng-Chieh Huang, Cheng-Hsiung Yang, Zheng-Ming Ge 18 January 2012
***************************************************************************/

int	DoGeneratingTriChaos(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e, f, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -(a + b * c1[2]) * c1[0] - (a + b * c1[2]) * pow(c1[0], 3) - c * c1[1] + d * c1[2];
	cn[2] = c1[3];
	cn[3] = -e * c1[2] + f * (1.0 - c1[2] * c1[2]) * c1[3] + g * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Generating 3-Scroll Attractors from one Chua Circuit
	Zerzouilia Elhadj, J. C. Sprott October 26, 2013
***************************************************************************/

int	DoGenerating3Scroll(void)

    {
    double	i, c1[3], cn[3], a, m0, m1, alpha, beta, h, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    m0 = param[0];
    m1 = param[1];
    a = param[2];
    alpha = param[3];
    beta = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	f = m1 * c1[0] + 0.5 * (m0 - m1) * (fabs(c1[0] + 1.0) - fabs(c1[0] - 1.0));
	h = (fabs(c1[2]) >= a / 3.0) ? f : -f;
									// replaced above the original 'a' for 'a/3'
									// the image gets more interesting than the 'squared' 3 scrolls
	cn[0] = alpha * (c1[1] - h);
	cn[1] = c1[0] - c1[1] + c1[2];
	cn[2] = -beta * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Generating Chaos with a Switching Piecewise-Linear Controller
	Jinhu Lu, Tianshou Zhou. Guanrong Chen and Xiaosong Yang 10 May 2002!
	https://www.researchgate.net/profile/Jinhu Lu/publication/10731026 Generating chaos with a switching piecewise-linear controller/links/541aadae0cf25ebee988b84a.pdf
***************************************************************************/

int	DoGeneratingChaosSwitchingPiecewiseLinearController(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    k = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	if (-c1[2] + (sqrt(c1[0] * c1[0] + c1[1] * c1[1])) >= k)
	    {
	    cn[0] = a * c1[0] + b * c1[1] - k * c1[0];
	    cn[1] = -b * c1[0] + a * c1[1] - k * c1[1];
	    cn[2] = c * c1[2] - k * d;
	    }
	else
	    {
	    cn[0] = a * c1[0] + b * c1[1];
	    cn[1] = -b * c1[0] + a * c1[1];
	    cn[2] = c * c1[2];
	    }
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Generating Multiscroll Chaotic Attractors - Theories, Methods And Applications
	JINHU LU and GUANRONG CHEN March 17, 2005
	http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.722.3479&rep=rep1&type=pdf
***************************************************************************/

int	DoGeneratingMultiscrollChaoticAttractors(void)

    {
    double	i, c1[3], cn[3], a, b, c, alpha, beta, d, fx;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alpha = param[0];
    beta = param[1];
    a = param[2];
    b = param[3];
    c = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	d = (c / 2.0 > floor(c)) ? 0 : PI;
	if (c1[0] > 2 * a * c)
	    fx = b * PI / 2 / a * (c1[0] - 2 * a * c);
	else if (c1[0] <= -2 * a * c)
	    fx = b * PI / 2 / a * (c1[0] + 2 * a * c);
	else
	    fx = -b * sin(PI * c1[0] / 2 / a + d);

	cn[0] = alpha * (c1[1] - fx);
	cn[1] = c1[0] - c1[1] + c1[2];
	cn[2] = -beta * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Generating One to Four-Wing Hidden Attractors in a Novel 4D No-Equilibrium Chaotic System with Extreme Multistability
	Sen Zhang, Yicheng Zeng, Zhijun Li, Mengjiao Wang, and Le Xiong 12 January 2018
	https://www.researchgate.net/publication/322460530_Generating_one_to_four-wing_hidden_attractors_in_a_novel_4D_no-equilibrium_chaotic_system_with_extreme_multistability
***************************************************************************/

int	DoGeneratingOneToFourWingHiddenAttractors(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * b / (a + b) * c1[0] - c1[1] * c1[2] + c;
	cn[1] = -a * c1[1] + c1[0] * c1[2] - e * c1[3];
	cn[2] = -b * c1[2] + c1[0] * c1[1];
	cn[3] = -d * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Generation of a Family of Fractional Order Hyper-Chaotic Multi-Scroll Attractors
	Liping Chen, Wei Pan, Kunpeng Wang, Ranchao Wu, J. A. Tenreiro Machado and Antonio M. Lopes 28 October 2017
	Send directly by J. A. Tenreiro Machado, and found in https://www.researchgate.net/requests/r66987741
***************************************************************************/

int	DoGenerationFamilyFractionalOrderHyperChaoticMultiScrollAttractors(void)

    {
    double	i, c1[4], cn[4], a1, a2, k, mu, p1, p2, C1, c2, s1, s2, b1, b2;
    int		j;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a1 = param[0];
    a2 = param[1];
    k = param[2];
    mu = param[3];
    p1 = param[4];
    p2 = param[5];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	s1 = 0;
	for (j = 1; j <= p1; j++)
	    {
	    b1 = fabs(c1[1] + (2 * j - 1)) / (c1[1] + (2 * j - 1));
	    b2 = fabs(c1[1] - (2 * j - 1)) / (c1[1] - (2 * j - 1));
	    s1 += b1 + b2;
	    }

	s2 = 0;
	for (j = 1; j <= p2; j++)
	    {
	    C1 = fabs(c1[1] + (2 * j - 1)) / (c1[1] + (2 * j - 1));
	    c2 = fabs(c1[1] - (2 * j - 1)) / (c1[1] - (2 * j - 1));
	    s2 += C1 + c2;
	    }
	s2 = k * s2 - a1 * c1[0] - a2 * c1[2];

	cn[0] = c1[1] + c1[2] - s1;
	cn[1] = mu * c1[2];
	cn[2] = -c1[0] - c1[2];
	cn[3] = -c1[3] + s2;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Generation of a Family of Fractional Order Hyper-Chaotic Multi-Scroll Attractors in 5 D
	Liping Chen, Wei Pan, Kunpeng Wang, Ranchao Wu, J. A. Tenreiro Machado and Antonio M. Lopes 28 October 2017
	Send directly by J. A. Tenreiro Machado, and found in https://www.researchgate.net/requests/r66987741
***************************************************************************/

int	DoGenerationFamilyFractionalOrderHyperChaoticMultiScrollAttractors5D(void)

    {
    double	i, c1[5], cn[5], a1, a2, d1, d2, d3, k1, k2, mu, p1, p2, p3, C1, c2, s1, s2, s3, b1, b2;
    int		j;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v

    a1 = param[0];
    a2 = param[1];
    d1 = param[2];
    d2 = param[3];
    d3 = param[4];
    k1 = param[5];
    k2 = param[6];
    p1 = param[7];
    p2 = param[8];
    p3 = param[9];
    mu = param[15];
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	s1 = 0;
	for (j = 1; j <= p1; j++)
	    {
	    b1 = fabs(c1[1] + (2 * j - 1)) / (c1[1] + (2 * j - 1));
	    b2 = fabs(c1[1] - (2 * j - 1)) / (c1[1] - (2 * j - 1));
	    s1 += b1 + b2;
	    }

	s2 = 0;
	for (j = 1; j <= p2; j++)
	    {
	    C1 = fabs(c1[1] + (2 * j - 1)) / (c1[1] + (2 * j - 1));
	    c2 = fabs(c1[1] - (2 * j - 1)) / (c1[1] - (2 * j - 1));
	    s2 += C1 + c2;
	    }
	s2 = k1 * s2 - a1 * c1[0] - a2 * c1[2];

	s3 = 0;
	for (j = 1; j <= p3; j++)
	    {
	    C1 = fabs(c1[1] + (2 * j - 1)) / (c1[1] + (2 * j - 1));
	    c2 = fabs(c1[1] - (2 * j - 1)) / (c1[1] - (2 * j - 1));
	    s3 += C1 + c2;
	    }
	s3 = k2 * s3 - d1 * c1[0] - d2 * c1[2] - d3 * c1[3];

	cn[0] = c1[1] + c1[2] - s1;
	cn[1] = mu * c1[2];
	cn[2] = -c1[0] - c1[2];
	cn[3] = -c1[3] + s2;
	cn[4] = -c1[4] + s3;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Genesio-Tesi Chaotic Attractor Images
***************************************************************************/

int	DoGenesioTesi(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = -c * c1[0] - b * c1[1] - a * c1[2] + c1[0] * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Geometry, Surfaces, Curves, Polyhedra
	http://paulbourke.net/geometry/
	Paul Burke March 2015)
***************************************************************************/

int	DoGeometrySurfacesCurvesPolyhedra(void)

    {
    double	i, c1[4], cn[4], r, iGap, rGap, col;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    iGap = param[0];
    rGap = param[1];
    col = param[2];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0.001; i < TWO_PI; i += iGap)
	{
	curpass = (int)(i * totpasses / iterations);
	for (r = 0.5; r <= 1.0; r+= 0.0015)
	    {
	    if (user_data(GlobalHwnd) == -1)				// user pressed a key?
		return -1;
	    c1[0] = -2.0 * r * cos(i) + 2.0 * cos(i) / r - 2.0 * r * r * r * cos(3.0 * i) / 3.0;
	    c1[1] = 6.0 * r * sin(i) - .02 * sin(i) / r - 2.0 * r * r * r * sin(3.0 * i) / 3.0;
	    c1[2] = 4.0 * log(r);
	    c1[3] = sqrt(fabs(c1[2] + c1[1] - c1[0]));

	    cn[0] = c1[0] + r / i;
	    cn[1] = c1[1] - r / i;
	    cn[2] = c1[2] - i / r;
	    cn[3] = c1[3] - i / r;
	    if (DisplayOscillator(c1, cn, dt, ((DWORD)((r - i) * col) % threshold), i, 4, 0) < 0)
		break;
	    }
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Gissinger Chaotic Oscillator Function Projetive Synchronisation of New Chaotic Reversal System
	Olurotii S. Ojpniyi october 2014
***************************************************************************/

int	DoGissinger(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] - c1[1] * c1[2];
	cn[1] = -b * c1[1] + c1[0] * c1[2];
	cn[2] = c - c1[2] + c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Global Analysis on n-scroll Chaotic Attractors of Modified Chua’s Circuit
	Fei Xu, Pei Yu and Xiaoxin Liao April 28, 2008
***************************************************************************/

int	DoGlobalAnalysis(void)

    {
    double	i, c1[3], cn[3], alpha, beta, a, b, c, d, f;
    int		n;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    n = (int)param[0];
    alpha = param[1];
    beta = param[2];
    a = param[3];
    b = param[4];
    c = n - 1;
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	if (c1[0] >= 2.0 * a * c)
	    f = b * PI / 2.0 / a * (c1[0] - 2.0 * a * c);
	else if (c1[0] <= -2.0 * a * c)
	    f = b * PI / 2.0 / a * (c1[0] + 2.0 * a * c);
	else
	    {
	    d = (n % 2 == 0) ? 0.0 : PI;
	    f = -b * sin(PI * c1[0] / 2.0 / a + d);
	    }
	cn[0] = alpha * (c1[1] - f);
	cn[1] = c1[0] - c1[1] + c1[2];
	cn[2] = -beta * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Globally Exponential Synchronisation Criterion of Chaotic Oscillators using Active Control
	Israr Ahmad, Sharifa Al Mahrouqi and Mohammad Shahzad November 2017
	https://www.researchgate.net/publication/321009212
***************************************************************************/

int	DoGloballyExponentialSynchronisationCriterionChaoticOscillators(void)

    {
    double	i, c1[3], cn[3], a, b, delta, d1, d2, d3;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    delta = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	d1 = -0.2 * sin(3 * TWO_PI * i);
	d2 = -0.2 * sin(PI * i);
	d3 = 0.2 * cos(PI * i);
	cn[0] = a * c1[0] - c1[2] + tanh(delta * c1[0]) + d1;
	cn[1] = -b * c1[1] + c1[2] + d2;
	cn[2] = c1[0] - c1[1] + d3;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Golden Mean 3D Chaotic System
	A new 3D chaotic system with golden proportion equilibria: Analysis
	and electronic circuit realization
	Ihsan Pehlivan, Yilmaz Uyaroglu 27 September 2012
***************************************************************************/

int	DoGoldenMean(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - c1[0] - a * c1[2];
	cn[1] = c1[0] * c1[2] - c1[0];
	cn[2] = -c1[0] * c1[1]- c1[1] + b;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Grassi-Mascolo Synchroniser Images
	Function Projective Synchronisation of Two Identical New Hyperchaotic Systems
***************************************************************************/

int	DoGrassiMascolo(void)

    {
    double	i, c1[4], cn[4], h;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z
    c1[3] = param[13];    // w
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 0.7 * c1[0] - c1[1] - c1[2];
	cn[1] = c1[0];
	cn[2] = 3.0 * (c1[0] - c1[3]);
	h = (c1[3] - 1.0 < 0.0) ? 0.0 : 1.0;
	cn[3] = 3.0 * c1[2] - 30.0 * (c1[3] - 1.0) * h;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Grid Multiwing Chaotic System with only Non-Hyperbolic Equilibria
	Sen Zhang, Yicheng Zeng, li Zhijun, Mengjiao Wang and Le Non-Hyperbolic Equilibria Xiong May, 2018
	https://www.researchgate.net/publication/324484013_A_novel_grid_multiwing_chaotic_system_with_only_non-hyperbolic_equilibria
***************************************************************************/

int	DoGridMultiwingChaoticSystem(void)

    {
    double	t, c1[3], cn[3], a, b, c, f, bezao = 0.5, sf, sh, intn, h = 0.0;
    int		i, n, m = 0;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z

    a = param[0];
    b = param[1];
    c = param[2];
    n = (int)param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	sf = 0.0, sh = 0.0;
	for (i = 1; i < n; i++)
	    {
	    intn = fabs(c1[2] + 2 * i) / (c1[2] + 2 * i) + fabs(c1[2] - 2 * i) / (c1[2] - 2 * i);
	    sf += intn;
	    }
	f = c1[2] - sf;
/*
    FOR j = 1 TO m: REM this looping is not running correctly due to paper's wrong formula.
        intm = ABS(y - 2 * j * bezao)
        sh = sh + intm
    NEXT j
    h = bezao * sh
*/
	cn[0] = -a * c1[0] + f;
	cn[1] = b - f * f;
	cn[2] = c * c1[0] * (c1[1] - h);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 2.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hadley Chaotic Circulation images
***************************************************************************/

int	DoHadley(void)

    {
    double	i, c1[3], cn[3], a, b, f, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    f = param[2];
    g = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[1] * c1[1] - c1[2] * c1[2] - a * c1[0] + a * f;
	cn[1] = c1[0] * c1[1] - b * c1[0] * c1[2] - c1[1] + g;
	cn[2] = b * c1[0] * c1[1] + c1[0] * c1[2] - c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Half-Duplex Relay Channel Using a Logistics Fractal Map
	A Proposed Chaotic-Switched Turbo Coding Design and Its Application for Half-Duplex Relay Channel
	Tamer H. M. Soliman, Fengfan Yang, and S. Ejaz 29 March 2015
***************************************************************************/

int	DoHalfDuplexRelay(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	c1[0] = 1.0 - 2.0 * fabs(c1[0] - 0.5);
	if (c == 0.0)
	    {
	    if (c1[0] < 0.5)
		{
		cn[0] = 2.0 * c1[0];
		cn[1] = (2.0 * c1[0] - c1[1]) / dt; 
		}
	    else
		{
		cn[0] = 2.0 * (1.0 - c1[0]);
		cn[1] = (2.0 * (1.0 - c1[0]) - c1[1]) / dt;
		}
	    }
	else
	    {
	    cn[0] = 2.0 * c1[0] * (1.0 - c1[0]);
	    cn[1] = (2.0 * c1[0] * (1.0 - c1[0]) - c1[1]) / dt;
	    }
	cn[2] = sqrt(sqr(sin(a*c1[0])) + sqr(cos(b*c1[1])));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Half Inverted Rossler Chaotic Attractor images
***************************************************************************/

int	DoHalfInverted(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] - c1[0] * c1[1] - c1[2];
	cn[1] = c1[0] * c1[0] - a * c1[1];
	cn[2] = b * c1[0] - c * c1[2] + d;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Halvorsen Chaotic Attractor Images
***************************************************************************/

int	DoHalvorsen(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[0] - 4.0 * c1[1] - 4.0 * c1[2] - c1[1] * c1[1];
	cn[1] = -a * c1[1] - 4.0 * c1[2] - 4.0 * c1[0] - c1[2] * c1[2];
	cn[2] = -a * c1[2] - 4.0 * c1[0] - 4.0 * c1[1] - c1[0] * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hamilton Energy, Complex Dynamical Analysis and Information Patterns of a New Memristive Fitzhugh-Nagumo Neural Network
	Zeric Tabekoueng Njitacke, Clovis Ntahkie Takembo, Jan Awrejcewicz, Henri Paul Ekobena Fouda and Jacques Kengne - May 2022
	https://www.researchgate.net/requests/r101101462
	https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
***************************************************************************/

int	DoHamiltonEnergy(void)

    {
    double	i, c1[3], cn[3], a, b, c, e, ii, alpha;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    e = param[3];
    ii = param[4];
    alpha = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] - b * c1[0] * c1[0] * c1[0] - c1[1] + ii + alpha * sin(c1[2]) * c1[0];
	cn[1] = 1 / e * (c1[0] + a - c * c1[1]);
	cn[2] = cos(c1[2]) + c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Harb Chaotic System Images
	GENERALIZED Synchronisation OF BIDIRECTIONAL COUPLED CHAOTIC SYSTEMS
	P. Karmokar and N. Islam 1 August 2013
***************************************************************************/

int	DoHarb(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[2];
	cn[1] = c1[0] - c1[1];
	cn[2] = a * c1[0] + c1[1] * c1[1] + b * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hardware Optimised FPGA Implementations of High-Speed True Random Bit Generators Based on Switching-Type Chaotic Oscillators
	Talal Bonny, Ridhwan Al Debsi, Sohaib Majzoub and Ahmed S. Elwakil 19 July 2018
	Sent directly by Sohaib Majzoub answering https://www.researchgate.net/requests/r67095131
***************************************************************************/

int	DoHardwareOptimisedFPGAImplementations(void)

    {
    double	i, c1[4], cn[4], a, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	f = (c1[1] >= 1.0) ? c1[1] : 0.0;
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = c1[3];
	cn[3] = -c1[3] - c1[2] - a * (c1[1] + c1[0]) - f;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Heat Conduction, and the Lack Thereof, in Time-Reversible Dynamical Systems
	Generalized Nose-Hoover Oscillators with a Temperature Gradient
	Julien Clinton Sprott, William Graham Hoover and Carol Griswold Hoover April 15, 2014)
***************************************************************************/

int	DoHeatConduction(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] + 2.0 * c1[0] * c1[1] + c1[0] * c1[2];
	cn[1] = 1.0 - 2.0 * c1[0] * c1[0] + c1[1] * c1[2];
	cn[2] = c1[0] - c1[0] * c1[0] - c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hénon-Heiles System Images
	Wikipedia
***************************************************************************/

int	DoHenonHeiles(void)

    {
    double	i, c1[4], cn[4], a, b, lambda;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// px
    c1[3] = param[13];	// py

    a = param[0];
    b = param[1];
    lambda = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2];
	cn[1] = c1[3];
	cn[2] = -c1[0] - 2.0 * lambda * c1[0] * c1[1];
	cn[3] = -c1[1] - lambda * (c1[0] * c1[0] - c1[1] * c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Heterogeneous Multistability in a Novel System with Purely Nonlinear Terms
	Z. Tabekoueng Njitacke, R. L. Tagne Mogue, G. D. Leutcho, T. Fonzin Fozin and J. Kengne 4 October 2020
	Sent to ManpWIN by Gervais Dolvis Leutchothrough https://www.researchgate.net/requests/r80700152
***************************************************************************/

int	DoHeterogeneousMultistability(void)

    {
    double	i, c1[3], cn[3], a, b, c, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    k = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = b * fabs(c1[1]) / c1[1] * (c1[2] + k);
	cn[1] = c1[0] * fabs(c1[0]) - c * c1[1] * fabs(c1[1]);
	cn[2] = fabs(c1[0]) - a * c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hidden Attractor and its Dynamical Characteristic in Memristive Self-Oscillating System
	Bao Han, Bao Bo-Cheng, Lin Yi, Wang Jiang and Wu Hua-Gan 6 June 2016
	https://www.researchgate.net/publication/309113737
***************************************************************************/

int	DoHiddenAttractorDynamicalCharacteristic(void)

    {
    double	i, c1[4], cn[4], a, beta, mu, b, w0, ww;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    beta = param[1];
    mu = param[2];
    b = param[3];
    w0 = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	ww = a + b * fabs(c1[3]);
	cn[0] = c1[1];
	cn[1] = (c1[2] + c1[0] * c1[0] - beta * c1[0] * c1[0] * c1[0] * c1[0]) * c1[1] - w0 * w0 * ww * c1[0];
	cn[2] = mu - c1[0] * c1[0];
	cn[3] = c1[0] - c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hidden Attractor in Smooth Chua Systems
	Leonov G.A., Kuznetsov N.V., Vagaitsev V.I. 2012
***************************************************************************/

int	DoHiddenAttractor(void)

    {
    double	i, c1[3], cn[3], alpha, beta, e = exp(1.0), f, gamma, m0, m1;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alpha = param[0];
    beta = param[1];
    gamma = param[2];
    m0 = param[3];
    m1 = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	f = m1 * c1[0] + (m0 - m1) * (pow(e, c1[0]) - pow(e, -c1[0])) / (pow(e, c1[0]) + pow(e, -c1[0]));
	cn[0] = alpha * (c1[1] - c1[0]) - alpha * f;
	cn[1] = c1[0] - c1[1] + c1[2];
	cn[2] = -(beta * c1[1] + gamma * c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hidden Attractors on One Path - Glukhovsky-Dolzhansky, Lorenz, and Rabinovich Systems - Glukhovsky-Dolzhansky System
	G. Chen, N.V. Kuznetsov, G.A. Leonov and T.N. Mokaev May 18, 2017 - Received from the authors
***************************************************************************/

int	DoHiddenAttractorOnOnePathGlukhovskyDolzhansky(void)

    {
    double	i, c1[3], cn[3], r, a, b, sigma;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    r = param[0];
    a = param[1];
    b = param[2];
    sigma = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -sigma * (c1[0] - c1[1]) - a * c1[1] * c1[2];
	cn[1] = r * c1[0] - c1[1] - c1[0] * c1[2];
	cn[2] = c1[0] * c1[1] - b * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hidden Attractors On One Path-Glukhovsky-Dolzhansky, Lorenz, and Rabinovich Systems
	G. Chen, N.V. Kuznetsov, G.A. Leonov and  T.N. Mokaev  June 1, 2017
	https://arxiv.org/pdf/1705.06183.pdf
***************************************************************************/

int	DoHiddenAttractorOnOnePath(void)

    {
    double	i, c1[3], cn[3], r, a, s, b, q;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    r = param[0];
    a = param[1];
    s = param[2];
    b = param[3];
    q = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -s * c1[0] + q * c1[2] + a * c1[1] * c1[2];
	cn[1] = r - c1[1] - c1[0] * c1[2];
	cn[2] = -c1[2] + c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hidden Bifurcations and Attractors in Nonsmooth Dynamical System
	Jeffrey, M. R, Marcus A.R. 2016/2017
***************************************************************************/

int	DoHiddenBifurcations(void)

    {
    double	i, c1[3], cn[3], m, b, p, q, s, l1, l2, l3;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    m = param[0];
    b = param[1];
    p = param[2];
    q = param[3];
    s = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	l1 = fabs(c1[0]) / c1[0];
	l2 = fabs(c1[1]) / c1[1];
	l3 = fabs(c1[2]) / c1[2];
	cn[0] = 5.0 * (l2 - l1) - 75.0 * c1[0];
	cn[1] = -l1 - 15.0 * l1 * l3 - l2 / 2.0 - 75.0 * c1[1];
	cn[2] = 15.0 * l1 * l2 - 4.0 / 3.0 - 4.0 / 3.0 * l3 - 75.0 * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hidden Chaotic Path Planning and Control of A Flexible Robot Manipulator
	Kshetrimayum Lochan, Jay Prakash Singh, Binoy Krishna Roy and Bidyadhar Subudhi - 2016 - Received from the authors
***************************************************************************/

int	DoHiddenChaoticPathPlanningControl(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = -c1[0] - 2.9 * c1[2] * c1[2] + c1[0] * c1[1] + 1.1 * c1[0] * c1[2] - 1.0;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hidden Chua Attractor Images
	Analytical-numerical localization of hidden attractor in electrical Chua's circuit
***************************************************************************/

int	DoHiddenChua(void)

    {
    double	i, c1[3], cn[3], a, b, d, e, f, g, m0, m1;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    d = param[2];
    e = param[3];
    g = param[4];
    m0 = param[5];
    m1 = param[6];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	f = m1 * c1[0] + 1.0 / 2.0 * (m0 - m1) * (fabs(c1[0] + d) - fabs(c1[0] - d));
	cn[0] = a * (c1[1] - c1[0]) - e * a * f;
	cn[1] = c1[0] - c1[1] + c1[2];
	cn[2] = (b * c1[1] + g * c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hidden Hyperchaotic Attractor in a Novel Simple Memristive Neural Network
	VIET-THANH PHAM, C. VOLOS, S. JAFARI, XIONG WANG, SUNDARAPANDIAN VAIDYANATHAN December 2014
	https://www.researchgate.net/publication/269048672
***************************************************************************/

int	DoHiddenHyperchaoticAttractor(void)

    {
    double	i, c[4], cn[4], e = exp(1.0), r1, r4, r5, r8, r11, r13, r2, r3, r10, r6, r7, r9, r12, c1, c2, c3, c4, thx, thy, thz, vb;

    c[0] = param[10];	// x
    c[1] = param[11];	// y
    c[2] = param[12];	// z
    c[3] = param[13];	// w

    r1 = param[0];
    r4 = param[1];
    r5 = param[2];
    r8 = param[3];
    r11 = param[4];
    r13 = param[5];
    r2 = param[6];
    r3 = param[7];
    r10 = param[8];
    r6 = param[9];
    r7 = 6.666;
    r9 = 3.333;
    r12 = 100.0;
    c1 = 10.0;
    c2 = 10.0;
    c3 = 10.0;
    c4 = 10.0;
    vb = 0.1;

    totpasses = 10;

    InitOscillator(c, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	thx = (pow(e, c[0]) - pow(e, -c[0])) / (pow(e, c[0]) + pow(e, -c[0]));
	thy = (pow(e, c[1]) - pow(e, -c[1])) / (pow(e, c[1]) + pow(e, -c[1]));
	thz = (pow(e, c[2]) - pow(e, -c[2])) / (pow(e, c[2]) + pow(e, -c[2]));
	cn[0] = -c[0] / r1 / c1 + thx / r2 / c1 + thy / r3 / c1 + thz / r4 / c1;
	cn[1] = -c[1] / r5 / c2 - thx / 100 / r6 / c2 * c[3] * c[3] + thy / r7 / c2;
	cn[2] = -c[2] / r8 / c3 + thx / r9 / c3 - thy / r10 / c3 + thz / r11 / c3 - vb / r12 / c3;
	cn[3] = -thx / r13 / c4;
	if (DisplayOscillator(c, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hidden Hyperchaos and Electronic Circuit Application in a 5D Self-Exciting Homopolar Disc Dynamo
	Zhouchao Wei, Irene Moroz, J.C. Sprott, Akif Akgul and Wei Zhang 2016
***************************************************************************/

int	DoHiddenHyperchaoElectronicCircuit(void)

    {
    double	i, c1[5], cn[5], m, g, k2, r, k1;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v

    m = param[0];
    g = param[1];
    k2 = param[2];
    r = param[3];
    k1 = param[4];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = r * (c1[1] - c1[0]) + c1[3];
	cn[1] = -(1.0 + m) * c1[1] + c1[0] * c1[2] - c1[4];
	cn[2] = g * (1.0 + m * c1[0] * c1[0] - (1.0 + m) * c1[0] * c1[1]);
	cn[3] = 2.0 * (1.0 + m) * c1[3] + c1[0] * c1[2] - k1 * c1[0];
	cn[4] = -m * c1[4] + k2 * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	High dimensional, 4 Positive Lyapunov Exponents and Attractors with 4 Scroll During a New Hyperchaotic Complex Nonlinear Model
	Emad E. Mahmoud, Kholod M. Abualnaja and Ohood A. Althagafi June 2018
	https://aip.scitation.org/doi/full/10.1063/1.5030120
***************************************************************************/

int	DoHighDimensional4PositiveLyapunovExponents(void)

    {
    double	i, c1[9], cn[9], a, b, c, k1, k2;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w
    c1[6] = param[16];	// p
    c1[7] = param[17];	// q
    c1[8] = param[18];	// r

    a = param[0];
    b = param[1];
    c = param[2];
    k1 = param[3];
    k2 = param[4];
    totpasses = 10;

    InitOscillator(c1, 9);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[0] + a * c1[2] + c1[5];
	cn[1] = -a * c1[1] + a * c1[3] + c1[6];
	cn[2] = b * c1[0] - c1[2] - c1[0] * c1[4] - c1[7];
	cn[3] = b * c1[1] - c1[3] - c1[1] * c1[4] - c1[8];
	cn[4] = -c * c1[4] + c1[0] * c1[2] + c1[1] * c1[3];
	cn[6] = -c1[1] * c1[4] + k1 * c1[6];
	cn[7] = k2 * c1[2];
	cn[8] = k2 * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 9, 1) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	High-Dimensional Hyperchaos Images
	DUFFING + LORENZ + SPROTT J CHAOS = 10D Chaos 
	New Way to Generate High-Dimensional Hyperchaos Jianming Liu SEPTEMBER 2013
***************************************************************************/

int	DoHighDimensional(void)

    {
    double	i, c1[10], cn[10], a, b, c, d, e, f, g, h, j, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w
    c1[6] = param[16];	// p
    c1[7] = param[17];	// q
    c1[8] = param[18];	// r
    c1[9] = param[19];	// s

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];
    h = param[7];
    j = param[8];
    k = param[9];
    totpasses = 10;

    InitOscillator(c1, 10);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + d * c1[2] * c1[9] - c1[5];
	cn[1] = c * c1[0] - c1[0] * c1[2] - c1[1];
	cn[2] = c1[0] * c1[1] - b * c1[2];
	cn[3] = c1[4];
	cn[4] = -e * c1[4] - c1[3] * c1[3] * c1[3] + f * cos(c1[5]);
	cn[5] = g * c1[0];
	cn[6] = h * c1[8];
	cn[7] = -j * c1[7] + c1[8] + k * c1[6] * c1[8];
	cn[8] = -c1[6] + c1[7] + c1[7] * c1[7];
	cn[9] = -c1[6] * c1[8] - c1[9] + c1[6];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 10, 1) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	High Throughput Pseudorandom Number Generator Based on Variable Argument Unified Hyperchaos
	Kaiyu Wang, Qingxin Yan, Shihua Yu, Xianwei Qi, Yudi Zhou and Zhenan Tang 7 July 2014
***************************************************************************/

int	DoHighThroughputPseudorandomNumberGenerator(void)

    {
    double	i, c1[4], cn[4], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = (26.0 * a + 10.0) * (c1[1] - c1[0]);
	cn[1] = (28.0 - 44.0 * a) * c1[0] - c1[0] * c1[2] + (29.0 * a - 1.0) * c1[1] - c1[3];
	cn[2] = c1[0] * c1[1] - (8.0 + a) * c1[2] / 3.0;
	cn[3] = 0.1 * (1.0 - a) * c1[1] * c1[2] + a * c1[0] + 0.2;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hindmarsh-Rose Chaotic Attractor images
***************************************************************************/

int	DoHindmarshRose(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e, s, l, x0;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    s = param[5];
    l = param[6];
    x0 = param[7];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - a * c1[0] * c1[0] * c1[0] + b * c1[0] * c1[0] - c1[2] + l;
	cn[1] = c - d * c1[0] * c1[0] - c1[1];
	cn[2] = e * (s * (c1[0] - x0) - c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hitzl-Zele Map-III
***************************************************************************/

int	DoHitzlZeleIII(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] - c1[1] * c1[2];
	cn[1] = -b * c1[1] + c1[0] * c1[2];
	cn[2] = -c * c1[2] + c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hitzl-Zele Map-Modified
***************************************************************************/

int	DoHitzlZeleMod(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 1.0 - c1[1] + c1[2] * c1[0] * c1[0];
	cn[1] = a * c1[0];
	cn[2] = b * c1[0] * c1[0] - c1[2] + 0.5;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Homoclinic Bifurcation and Chaos in a Noise-Induced Ö6 Potential
	Gen Ge,1 ZhiWen Zhu,2 and Jia Xu2 & Marcus Rezende 18 April 2013
***************************************************************************/

int	DoHomoclinicBifurcation(void)

    {
    double	i, c1[3], cn[3], w0, l, beta;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    cn[2] = c1[2];	// another Marcus wobbly

    w0 = param[0];
    l = param[1];
    beta = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = w0 * w0 * c1[0] + l * c1[0] * c1[0] - beta * pow(c1[0], 5.0);
	c1[2] = sin(c1[0]) - cos(c1[1]);				// Note!!! this 'z' is Marcus' idea
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hopf Bifurcation Analysis and Anticontrol of Hopf Circles of the Rössler-Like System
	Ranchao Wu and Xiang Li 20 June 2012
***************************************************************************/

int	DoHopfBifurcation(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[1] - c1[2];
	cn[1] = c1[0] + a * c1[2];
	cn[2] = b * c1[1] + c * c1[2] - c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hopf Bifurcation Analysis and Chaos Control of a Chaotic System without ilnikov Orbits
	Na Li, Wei Tan and Huitao Zhao 23 November 2015
	https://www.hindawi.com/journals/ddns/2015/912798/
***************************************************************************/

int	DoHopfBifurcationAnalysisChaosControl(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    cn[1] = c1[1];

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    k = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = b * c1[0] - c * c1[1] * c1[2] + k * (c1[1] - cn[1]);
	cn[2] = d + c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hopf Bifurcation, Cascade of Period-Doubling, Chaos and the Possibility of Cure in a 3D Cancer Model
	Marluci Cristina Galindo, Cristiane Nespoli, and MarceloMessias 13 October 2014
***************************************************************************/

int	DoHopfBifCascade(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e, f, g, h;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];
    h = param[7];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] * (1.0 - c1[0]) - a * c1[0] * c1[1] - b * c1[0] * c1[2];
	cn[1] = c * c1[1] * (1.0 - c1[1]) - d * c1[0] * c1[1];
	cn[2] = e * c1[0] * c1[2] / (c1[0] + f) - g * c1[0] * c1[2] - h * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hopf Bifurcation Analysis in a New Chaotic System with Chaos Entanglement Function
	Zhang Jiangang, Chu Yandong, Du Wenju, Chang Yingxiang, and An Xinlei 22 July 2014
***************************************************************************/

int	DoHopfBifurcationEntanglement(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] + b * c1[1];
	cn[1] = -b * c1[0] + a * c1[1] + d * sin(c1[2]);
	cn[2] = c * c1[2] + e * sin(c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Horseshoe Chaos in a Simple Memristive Circuit
	Lei Wang,1,2 XiaoSong Yang,1 WenJie Hu,1 and Quan Yuan 16 November 2014
***************************************************************************/

int	DoHorseshoeChaos(void)

    {
    double	i, c1[3], cn[3], alpha, beta;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alpha = param[0];
    beta = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[0] - beta * (c1[2] * c1[2] - 1.0) * c1[1];
	cn[2] = -c1[1] - alpha * c1[2] + c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	How a Broken Egg Attractor Has Influenced the Dynamics of My Life-3D
	Yoshisuke Uedaa 2012
***************************************************************************/

int	DoHowBrokenEggAttractor(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    cn[0] = c1[0];
    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 8.0 * c1[1] - c1[1] * c1[0] - cn[0];
	cn[1] = 0.2 * (1.0 - 8.0 * c1[0] * c1[0]) / c1[1] - c1[0] * c1[0] * c1[0] + 0.35 * tan(i);
	cn[2] = c1[1] - c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	How to Bridge Attractors and Repellors-II
	Chunbiao Li AND Julien Clinton Sprott June 15, 201?
	http://sprott.physics.wisc.edu/pubs/paper478.pdf'
***************************************************************************/

int	DoHowToBridgeAttractorsRepellorsII(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    a = param[0];
    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[1] * c1[2];
	cn[1] = (a * c1[0] + c1[1] + c1[2] * c1[2]) * c1[2];
	cn[2] = c1[0] - c1[0] * c1[0] * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 60.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hybrid - 6D
	Various authors and Marcus Idea 11/02/2019
	https://www.hindawi.com/journals/complexity/2018/6719341/   
	+ Marcus 
	+ https://www.researchgate.net/publication/321958295_A_new_three-dimensional_chaotic_system_with_a_hidden_attractor_circuit_design_and_application_in_wireless_mobile_robot
***************************************************************************/

int	DoHybrid6D(void)

    {
    double	i, c1[6], cn[6], a, b, c, l, v0, w0;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    l = param[3];
    totpasses = 10;

    InitOscillator(c1, 6);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] * (1 - c1[1]) + (c - a * c1[2]) * c1[0] * c1[0];
	cn[1] = (c1[0] - 1) * c1[1];
	cn[2] = (a * c1[0] * c1[0] - b) * c1[2];
	v0 = 0.5 * (c1[0] + c1[1]);
	w0 = (c1[0] - c1[1]) / l;
	cn[3] = v0 * cos(c1[5]);
	cn[4] = v0 * sin(c1[5]);
	cn[5] = w0;

	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 35.0) % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hybrid Dislocated Control for Memristor Chaotic Oscillator System
	Hybrid Dislocated Control and General Hybrid Projective Dislocated Synchronisation for Memristor
	Chaotic Oscillator System
	Junwei Sun, Chun Huang, and Guangzhao Cui 16 October 2014
***************************************************************************/

int	DoHybridDislocated(void)

    {
    double	i, c1[4], cn[4], a1, a2, a3, a4, a, b, fi;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a1 = param[0];
    a2 = param[1];
    a3 = param[2];
    a4 = param[3];
    a = param[4];
    b = param[5];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	fi = (fabs(c1[3]) < 1.0) ? a : b;
	cn[0] = a1 * (c1[2] - fi * c1[0]);
	cn[1] = a2 * c1[1] - a3 * c1[2];
	cn[2] = c1[1] - c1[0] - a4 * c1[2];
	cn[3] = c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hybrid System plus Chaotic attractor  
	OR HYBRID_HYBRID CHAOTIC ATTRACTOR IN A SIMPLE HYBRID SYSTEM
	XIAO-SONG YANG and QINGDU LI & Marcus Rezende February/01/2015
***************************************************************************/

int	DoHybridSystem(void)

    {
    double	i, c1[3], cn[3], delta[3], a, b, c, d, h, alpha, beta, k, l, xnew, ynew, znew, dx = 1.0;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    h = param[4];
    alpha = param[5];
    beta = param[6];
    k = param[7];
    l = param[8];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	xnew = a * c1[0] + b * c1[1];
	if ((c1[2] + k * c1[0]) <= -l)
	    {
	    ynew = c * c1[0] + d * c1[1];
	    znew = -h * c1[2] + alpha;
	    }
	else if (fabs(c1[2] + k * c1[0]) < l)
	    {
	    ynew = c * c1[0] + (d + beta) * c1[1];
	    znew = -h * c1[2];
	    }
	else
	    {
	    ynew = c * c1[0] + d * c1[1];
	    znew = -h * c1[2] - alpha;
	    }
	c1[0] += xnew*dt; c1[1] += ynew*dt; c1[2] += znew*dt;
	// catastrophe equations
	cn[0] = 3.0 * c1[0] * c1[0] + a + c * c1[1];
	cn[1] = 3.0 * c1[1] * c1[1] + b + c * c1[0];
	cn[2] = 3.0 * c1[2] * c1[2] + d + c * (sqrt(fabs(c1[0] + c1[1])) + (c1[0] + c1[1]) / 2.0) / 2.0;
	// mix-up the ORIGINAL ATTRACTOR with the CATASTROPHE ATTRACTOR - thanks Marcus
	delta[0] = sqrt(fabs(cn[0])) + c1[0]; 
	delta[1] = sqrt(fabs(cn[1])) + c1[1]; 
	delta[2] = sqrt(fabs(cn[2])) + c1[2];
	if (DisplayOscillator(delta, c1, dx, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Limited hyperbolic-3 Chaotic Attractor images
	Analysis and Adaptive Synchronisation of Two Novel Chaotic Systems with Hyperbolic Sinusoidal 
	and Cosinusoidal Nonlinearity and Unknown Parameters S. Vaidyanathan 'Accepted 25 September 2013
***************************************************************************/

int	DoHyperbolic(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[1] * c1[2];
	cn[1] = b * c1[0] - c * c1[0] * c1[2];
	cn[2] = -d * c1[2] + (exp(2 * c1[1] * c1[0]) + 1) / 2 / exp(c1[1] * c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hyperbolic Sinusoidal and Cosinusoidal Nonlinearity attractors
	Analysis and Adaptive Synchronisation of Two Novel Chaotic Systems with Hyperbolic Sinusoidal and Cosinusoidal Nonlinearity and Unknown Parameters
	S. Vaidyanathan 25 September 2013
***************************************************************************/

int	DoHyperbolicSin(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e = exp(1.0), g, k, sign;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    sign = (param[4] > 0) ? 1.0 : -1.0;
    if (sign < 0.0)
	dt /= 10.0;

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[1] * c1[2];
	cn[1] = b * c1[0] - c * c1[0] * c1[2];
	g = c1[0] * c1[1];
	k = (pow(e, g) - sign * pow(e, -g)) / 2.0;
	cn[2] = -d * c1[2] + k;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hyperchaos and Hyperchaos Control of the Sinusoidally Forced Simplified Lorenz System
	Keihui Sun · Xuan Liu · Congxu Zhu · J.C. Sprott 23 February 2012
***************************************************************************/

int	DoHyperChaosControl(void)

    {
    double	i, c1[4], cn[4], omega, c0;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    omega = param[0];
    c0 = param[1];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 10.0 * (c1[1] - c1[0]);
	cn[1] = (24.0 - 4.0 * c0 * sin(c1[3])) * c1[0] - c1[0] * c1[2] + c0 * sin(c1[3]) * c1[1];
	cn[2] = c1[0] * c1[1] - 8.0 / 3.0 * c1[2];
	cn[3] = omega * (c1[0] * c1[1] - c1[2] * c1[3]);	// the original was only 'omega' and Marcus put this product '(x*y-z*w)', making use of these trigonometric factors;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hyperchaos Evolved from the Liu Chaotic System
	Wang Fa-Quiang and Liu Chong-Xin 27 february 2006
	Received from one of the authors
***************************************************************************/

int	DoHyperchaosEvolvedLiuChaoticSystem(void)

    {
    double	t, c1[4], cn[4], a, b, c, d, h, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    h = param[4];
    k = param[5];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = b * c1[0] - k * c1[0] * c1[2] + c1[3];
	cn[2] = -c * c1[2] + h * c1[0] * c1[0];
	cn[3] = -d * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 25.0) % threshold), t, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	HyperChaos from an Augmented Lu System images
	BOCHENG BAO, JIANGPING XU, ZHONG LIU, ZHENGHUA MA AUGUST, 6,2010
***************************************************************************/

int	DoHyperChaosLu(void)

    {
    double	i, c1[4], cn[4], a, b, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w
    cn[3] = c1[3];

    a = param[0];
    b = param[1];
    k = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * b / (a + b) * c1[0] - c1[1] * c1[2];
	cn[1] = a * c1[1] + c1[0] * c1[2] - c1[3];
	cn[2] = b * c1[2] + c1[0] * c1[1];
	c1[3] = k * (c1[1] - c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hyperchaos in a Conservative System with Nonhyperbolic Fixed Points
	Aiguo Wu, Shijian Cang, Ruiye Zhang, Zenghui Wang and Zengqiang Chen 22 April 2018
	https://www.hindawi.com/journals/complexity/2018/9430637/
***************************************************************************/

int	DoHyperchaosConservativeSystem(void)

    {
    double	i, c1[5], cn[5], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[1] + c1[4] * c1[4];
	cn[1] = -a * c1[0];
	cn[2] = c1[0] * c1[3];
	cn[3] = b * c1[4] - c1[0] * c1[2];
	cn[4] = -b * c1[3] - c1[0] * c1[4];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hyperchaos Numerical Simulation and Control in a 4D Hyperchaotic System
	Junhai Ma and Yujing Yang 19 August 2013
***************************************************************************/

int	DoHyperChaosNumerical(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[0] - c1[1]) - c1[1] * c1[2] + c1[3];
	cn[1] = -b * c1[1] + c1[0] * c1[2];
	cn[2] = -c * c1[2] + d * c1[0] + c1[0] * c1[1] - c1[3];
	cn[3] = -e * (c1[0] + c1[1]) + c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 1.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	HyperChaotic Attractor images
***************************************************************************/

int	DoHyperChaotic(void)

    {
    double	i, c1[4], cn[4], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] - c1[1];
	cn[1] = c1[0] - c1[1] * c1[2] * c1[2];
	cn[2] = c1[1] - c1[2] - b * c1[3];
	cn[3] = c1[2] + c * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hyperchaotic Attractor in a Novel Hyperjerk System with Two Nonlinearities
	Peter Daltzis, Sundarapandian Vaidyanathan, Viet–Thanh Pham, Christos Volos, Ektoras Nistazakis and George Tombras 18 May 2017
	https://www.researchgate.net/publication/318134396_Hyperchaotic_Attractor_in_a_Novel_Hyperjerk_System_with_Two_Nonlinearities
***************************************************************************/

int	DoHyperchaoticAttractorNovelHyperjerkSystemI(void)

    {
    double	i, c1[4], cn[4], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = c1[3];
	cn[3] = -c1[0] - c1[1] - a * c1[2] - b * fabs(c1[0]) - c * c1[0] * c1[0] * c1[0] * c1[0] * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hyperchaotic Attractor in a Novel Hyperjerk System with Two Nonlinearities
	Peter Daltzis, Sundarapandian Vaidyanathan, Viet-Thanh Pham, Christos Volos, Ektoras Nistazakis and George Tombras 18 May 2017
	https://www.researchgate.net/publication/318134396_Hyperchaotic_Attractor_in_a_Novel_Hyperjerk_System_with_Two_Nonlinearities
***************************************************************************/

int	DoHyperchaoticAttractorNovelHyperjerkSystemII(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    k = param[4];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2] + (c1[1] - a) * c1[0] + c1[3];
	cn[1] = 1.0 - b * c1[1] - c1[0] * c1[0];
	cn[2] = -c1[0] - c * c1[2];
	cn[3] = -d * c1[0] * c1[1] - k * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hyperchaotic Attractor with Multiple Positive Lyapunov Exponents
	HU Guo-Si 9 January 2009
***************************************************************************/

int	DoHyperChaoticAttractor(void)

    {
    double	i, c1[5], cn[5], u = 0.0;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// v
    c1[4] = param[14];	// w

    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 10.0 * (c1[1] - c1[0]) + c1[4];
	cn[1] = 28.0 * c1[0] - c1[1] - c1[0] * c1[2] - c1[4];
	cn[2] = c1[0] * c1[1] - 8.0 / 3.0 * c1[2];
	cn[3] = -c1[0] * u + 2.0 * c1[3];
	cn[4] = 8.0 * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	HyperChaotic Attractor in 9 Dimensions images
	http://www.scholarpedia.org/article/Hyperchaos
	Christophe Letellier, Dr. Otto E. Rossler
***************************************************************************/

int	DoHyperChaotic9D(void)

    {
    double	i, c1[9], cn[9], a, b1, b2, b3, b4, b5, b6, r, s;

    c1[0] = param[10];	// x1
    c1[1] = param[11];	// x2
    c1[2] = param[12];	// x3
    c1[3] = param[13];	// x4
    c1[4] = param[14];	// x5
    c1[5] = param[15];	// x6
    c1[6] = param[16];	// x7
    c1[7] = param[17];	// x8
    c1[8] = param[18];	// x9

    a = param[0];
    r = param[1];
    s = param[2];
    b1 = 4.0 * (1.0 + a * a) / (1.0 + 2.0 * a * a);
    b2 = (1.0 + 2.0 * a * a) / 2.0 / (1.0 + a * a);
    b3 = 2.0 * (1.0 - a * a) / (1.0 + a * a);
    b4 = a * a / (1.0 + a * a);
    b5 = 8.0 * a * a / (1.0 + 2.0 * a * a);
    b6 = 4.0 / (1.0 + 2.0 * a * a);

    totpasses = 10;

    InitOscillator(c1, 9);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -s * b1 * c1[0] - c1[1] * c1[3] + b4 * c1[3] * c1[3] + b3 * c1[2] * c1[4] - s * b2 * c1[6];
	cn[1] = -s * c1[1] + c1[0] * c1[3] - c1[1] * c1[4] + c1[3] * c1[4] - s * c1[8] / 2.0;
	cn[2] = -s * b1 * c1[2] + c1[1] * c1[3] - b4 * c1[1] * c1[1] - b3 * c1[0] * c1[4] + s * b2 * c1[7];
	cn[3] = -s * c1[3] - c1[1] * c1[2] - c1[1] * c1[4] + c1[3] * c1[4] + s * c1[8] / 2.0;
	cn[4] = -s * b5 * c1[4] + c1[1] * c1[1] / 2 - c1[3] * c1[3] / 2.0;
	cn[5] = -b6 * c1[5] + c1[1] * c1[8] - c1[3] * c1[8];
	cn[6] = -b1 * c1[6] - r * c1[0] + 2 * c1[4] * c1[7] - c1[3] * c1[8];
	cn[7] = -b1 * c1[7] + r * c1[2] - 2.0 * c1[4] * c1[6] + c1[1] * c1[8];
	cn[8] = -c1[8] - r * c1[1] + r * c1[3] - 2.0 * c1[1] * c1[5] + 2.0 * c1[3] * c1[5] + c1[3] * c1[6] - c1[1] * c1[7];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 1.0) % threshold), i, 9, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hyperchaotic Behavior in Arbitrary-Dimensional Fractional-Order Quantum Cellular Neural Network Model
	LING LIU, CHONGXIN LIU and DELIANG LIANG July 11, 2012
***************************************************************************/

int	DoHyperchaoticBehavior(void)

    {
    double	i, c1[6], cn[6], b1, b2, b3, t1, t2, t3;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w

    b1 = param[0];
    b2 = param[1];
    b3 = param[2];
    t1 = param[3];
    t2 = param[4];
    t3 = param[5];

    totpasses = 10;

    InitOscillator(c1, 6);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -2.0 * t1 * sqrt(1.0 - c1[0] * c1[0]) * sin(c1[1]);
	cn[1] = -b1 * (c1[0] - c1[2]) + 2.0 * t1 * c1[0] / sqrt(1.0 - c1[0] * c1[0]) * cos(c1[1]);
	cn[2] = -2.0 * t2 * sqrt(1.0 - c1[2] * c1[2]) * sin(c1[3]);
	cn[3] = -b2 * (c1[2] - c1[0]) + 2.0 * t2 * c1[2] / sqrt(1.0 - c1[2] * c1[2]) * cos(c1[3]);
	cn[4] = -2.0 * t3 * sqrt(1.0 - c1[4] * c1[4]) * sin(c1[5]);
	cn[5] = -b3 * (c1[4] - c1[2] - c1[0]) + 2.0 * t3 * c1[4] / sqrt(1.0 - c1[4] * c1[4]) * cos(c1[5]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 36.0) % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hyperchaotic Chameleon: Fractional Order FPGA Implementation
	Karthikeyan Rajagopal, Anitha Karthikeyan, and Prakash Duraisamy Viet-Thanh Pham, 
	Sundarapandian Vaidyanathan, Christos K. Volos, Sajad Jafari and Xiong Wang 30 May 2017
***************************************************************************/

int	DoHyperchaoticChameleon(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, alpha, beta;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    alpha = param[4];
    beta = param[5];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 15.0 * (c1[1] - c1[0]) + 13.0 * c1[1] * c1[2];
	cn[1] = 18.0 * c1[0] - c1[0] * c1[2] - b * c1[0] * (alpha + beta * 12.0 * c1[3] * c1[3]) - a;
	cn[2] = c1[0] * c1[1] - c * c1[2];
	cn[3] = d * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hyperchaotic Attractor with Complex Patterns
	A New Hyperchaotic Attractor with Complex Patterns
	Safieddine Bouali 2015
***************************************************************************/

int	DoHyperChaoticComplex(void)

    {
    double	i, c1[4], cn[4];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] * (1.0 - c1[1]) + 2.0 * c1[2];
	cn[1] = (c1[0] * c1[0] - 1.0) * c1[1];
	cn[2] = 0.2 * (1.0 - c1[1]) * c1[3];
	cn[3] = c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 1.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	HyperChaotic Finance System
	Inverse optimal control of hyperchaotic finance system
	Changzhong Chen, Tao Fan, Bangrong Wang March 24 2014)
***************************************************************************/

int	DoHyperChaoticFinance(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2] + (c1[1] - a) * c1[0] + c1[3];
	cn[1] = 1.0 - b * c1[1] - c1[0] * c1[0];
	cn[2] = -c1[0] - c * c1[2];
	cn[3] = -d * c1[0] * c1[1] - e * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 1.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hyperchaotic Circuit Based on Memristor Feedback with Multistability and Symmetries
	Xiaoyuan Wang, Xiaotao Min, Pengfei Zhou and Dongsheng Yu 11 February 2020
	https://www.researchgate.net/publication/339208182
***************************************************************************/

int	DoHyperChaoticCircuitMemristorFeedback(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, alpha, beta, gw;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    alpha = param[4];
    beta = param[5];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	gw = alpha + beta * c1[3] * c1[3];
	cn[0] = a * (c1[1] - c1[0]) + b * c1[1] * gw;
	cn[1] = c * c1[0] - c1[0] * c1[2];
	cn[2] = c1[0] * c1[0] - d * c1[2];
	cn[3] = c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 1.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hyperchaotic Memcapacitor Oscillator with Infinite Equilibria and Coexisting Attractors
	Karthikeyan Rajagopal, Sajad Jafari, Anitha Karthikeyan, Ashokkumar Srinivasan and Biniyam Ayele 5 january 2018
	https://www.researchgate.net/publication/320866480_Hyperchaotic_Memcapacitor_Oscillator_with_Infinite_Equilibria_and_Coexisting_Attractors
***************************************************************************/

int	DoHyperchaoticMemcapacitorOscillator1(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e, f, m, n;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    m = param[6];
    n = param[7];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] + c1[2];
	cn[1] = c * c1[1] + d * c1[2] - a * c1[0] - b * c1[0] * c1[3] * c1[3];
	cn[2] = f * c1[1] + e * c1[2] - m * c1[0] - n * c1[0] * c1[3] * c1[3];
	cn[3] = c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 1.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hyperchaotic Memcapacitor Oscillator with Infinite Equilibria and Coexisting Attractors
	Karthikeyan Rajagopal, Sajad Jafari, Anitha Karthikeyan, Ashokkumar Srinivasan and Biniyam Ayele 5 january 2018
	https://www.researchgate.net/publication/320866480_Hyperchaotic_Memcapacitor_Oscillator_with_Infinite_Equilibria_and_Coexisting_Attractors
***************************************************************************/

int	DoHyperchaoticMemcapacitorOscillator2(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e, f, m, n, k = 1, ee = exp(1.0);

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    m = param[6];
    n = param[7];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	k = -k;
	cn[0] = c1[1] + c1[2];
	cn[1] = c * c1[1] + d * c1[2] - a * c1[0] - b * c1[0] * pow(fabs(c1[3]), PI + ee);
	cn[2] = f * c1[1] + e * c1[2] - m * c1[0] - n * c1[0] * pow(fabs(c1[3]), PI + ee);
	cn[3] = c1[0] * k;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 16.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	HyperChaotic Finance System
	Inverse optimal control of hyperchaotic finance system
	Changzhong Chen, Tao Fan, Bangrong Wang March 24 2014)
***************************************************************************/

int	DoHyperChaoticOscillatorGyrators(void)

    {
    double	i, c1[4], cn[4], a, c, e, m, f, h;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    c = param[1];
    e = param[2];
    m = param[3];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	f = (c1[0] - c1[2] - 1.0);
	h = (double)(f > 0);

	cn[0] = a * c1[0] - c1[1] - c * (c1[0] - c1[2] - 1.0) * h;
	cn[1] = c1[0];
	cn[2] = (-c1[3] + c * (c1[0] - c1[2] - 1.0) * h) / e;
	cn[3] = c1[2] / m;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 1.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hyperchaotic Sakarya Attractor
	http://www.3d-meier.de/tut19/Seite19.html & MARCUS APRIL 2015
***************************************************************************/

int	DoHyperChaoticSakarya(void)

    {
    double	i, c1[6], cn[6], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// x1
    c1[4] = param[14];	// y1
    c1[5] = param[15];	// z1

    a = param[0];
    b = param[1];

    totpasses = 10;

    InitOscillator(c1, 6);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[0] + c1[1] + c1[1] * c1[2];
	cn[3] = (-c1[0] + c1[1] * c1[2] - c1[3]) / dt;
	cn[1] = -c1[0] - c1[1] + a * c1[0] * c1[2];
	cn[4] = (-c1[0] - c1[1] + a * c1[0] * c1[2] - c1[4]) / dt;
	cn[2] = c1[2] - b * c1[0] * c1[1];
	cn[5] = (c1[2] - b * c1[0] * c1[1] - c1[5]) / dt;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hyperchaotic Yan-Chen projective-3 images
	Function Projective Synchronisation of Two Identical New Hyperchaotic Systems
***************************************************************************/

int	DoHyperchaoticYanChen(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = (c - a) * c1[0] - c1[0] * c1[2] + c * c1[1];
	cn[2] = c1[0] * c1[1] - b * c1[2] - c1[1] * c1[2] - c1[3];
	cn[3] = -d * c1[3] + c1[1] * c1[2] - c1[0] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 2) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hyperchaotic Yujun System images
	SLIDING CONTROLLER DESIGN FOR THE GLOBAL CHAOS Synchronisation OF 
	IDENTICAL HYPERCHAOTIC YUJUN SYSTEMS
	Sundarapandian Vaidyanathan : August 2012
***************************************************************************/

int	DoHyperchaoticYujun(void)

    {
    double	i, c1[4], cn[4], a, b, c, r;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    r = param[3];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[1] * c1[2];
	cn[1] = c * c1[0] - c1[1] + c1[3] - c1[0] * c1[2];
	cn[2] = -b * c1[2] + c1[0] * c1[1];
	cn[3] = r * c1[3] - c1[0] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 8.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hyperchaotic Zhou System
	Chaos Control and Synchronisation of a Hyperchaotic Zhou System by Integral Sliding Mode control
	Yashar Toopchi  and Jidong Wang 12 December 2014
***************************************************************************/

int	DoHyperchaoticZhou(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[3];
	cn[1] = c1[0] * c1[1] - c1[0] * c1[2];
	cn[2] = -b * c1[2] + c1[0] * c1[1];
	cn[3] = d * c1[0] + c1[1] * c1[2] * 0.5;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 48.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hypogenetic Chaotic Jerk Flows - Type HJ7
	Chunbiao Li, Julien Clinton Sprott and Hongyan Xing 27 January 2016
	Received from Chunbiao Li through https://www.researchgate.net/requests/r68327448Research Gate
***************************************************************************/

int	DoHypogeneticChaoticJerkFlowsTypeHJ7(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = fabs(c1[1]) / c1[1];
	cn[1] = c1[2];
	cn[2] = -c1[2] + a * c1[1] * c1[1] - c1[2] * c1[2] - b * fabs(c1[0]) + c;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 48.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hyper Jerk Chaotic System images
	Transformation of 4-D dynamical systems to hyperjerk form
	Zeraoulia Elhadj and J. C. Sprott, Jose Luis Lopez-Bonilla May 7, 2012
***************************************************************************/

int	DoHyperJerk(void)

    {
    double	i, c1[4], cn[4];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = c1[3];
	cn[3] = -pow(c1[0], 4) * c1[3] - 3.6 * c1[2] - c1[1] - c1[0] ;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 8.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hyper-Rossler Attractor X-Y Axis Images
***************************************************************************/

int	DoHyperRossler(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[1] - c1[2];
	cn[1] = c1[0] + a * c1[1] + c1[3];
	cn[2] = b + c1[0] * c1[2];
	cn[3] = -c * c1[2] + d * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Hypothetical Galaxy Potentials Images
	Periodic solutions of a galactic potential
	Jaume Llibre, Daniel Pasca, Claudià Valls 2014
***************************************************************************/

int	DoHypotheticalGalaxies(void)

    {
    double	i, c1[6], cn[6], a, b, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];   // px
    c1[2] = param[12];   // y
    c1[3] = param[13];   // py
    c1[4] = param[14];   // z
    c1[5] = param[15];   // pz
    a = param[0];
    b = param[1];
    e = param[2];

    totpasses = 10;

    InitOscillator(c1, 6);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[0] + e * (4.0 * a * c1[0] * c1[0] * c1[0] + 2.0 * b * (2.0 * c1[0] * c1[2] * c1[2] + 2.0 * c1[0] * c1[4] * c1[4]));
	cn[2] = c1[3];
	cn[3] = -c1[2] + e * (4.0 * a * c1[2] * c1[2] * c1[2] + 2.0 * b * (2.0 * c1[0] * c1[0] * c1[2] + 2.0 * c1[2] * c1[4] * c1[4]));
	cn[4] = c1[5];
	cn[5] = -c1[4] + e * (4.0 * a * c1[4] * c1[4] * c1[4] + 2.0 * b * (2.0 * c1[0] * c1[0] * c1[4] + 2.0 * c1[2] * c1[2] * c1[4]));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Identification of Unknown Parameters and Orders via Cuckoo Search Oriented Statistically by
	Differential Evolution for Noncommensurate Fractional-Order Chaotic Systems 
	Fei Gao, Xue-Jing Lee, Heng-qing Tong, Feng-xia Fei, and Hua-ling Zhao
***************************************************************************/

int	DoIdentification(void)

    {
    double	i, c1[4], cn[4], a, b, c, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    g = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] - c1[1] * c1[2] + c1[3];
	cn[1] = g - b * c1[1] + c1[0] * c1[2];
	cn[2] = c1[0] * c1[1] - c * c1[2] + c1[0] * c1[3];
	cn[3] = -c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Ikeda Chaotic Attractor Images
***************************************************************************/

int	DoIkedaAttractor(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i += dt/25)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a + b * (c1[0] * cos(c1[2]) - c1[1] * sin(c1[2]));
	cn[1] = b * (c1[0] * sin(c1[2]) + c1[1] * cos(c1[2]));
	cn[2] = c - d / (1 + c1[0] * c1[0] + c1[1] * c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / dt) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Ilogistic Attractor
	Marcus Rezende 2015, may, 14
***************************************************************************/

int	DoIlogisticAttractor(void)

    {
    double	i, c1[3], cn[3], a, b, r;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    r = param[0];
    a = param[1];
    b = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = r * c1[0] * (1.0 - c1[0] * c1[1]);
	cn[1] = (r * c1[0] * (1.0 - c1[0] * c1[1]) - c1[1]) / dt;
	cn[2] = sqrt(sqr(sin(a * c1[0])) + sqr(cos(b * c1[1])));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Image Encryption Algorithm Based on a Novel Improper Fractional-Order Attractor and a Wavelet Function Map
	Jian-feng Zhao, Shu-ying Wang, Li-tao Zhang, Xiao-yan Wang and Marcus Rezende 22 March 2017 and 12/04/2017
***************************************************************************/

int	DoImageEncryptionAlgorithm(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	c1[0] = -c1[0];
	cn[0] = c1[0] * c1[2] + b * sin(c1[0] + c1[1] + c1[2]);
	cn[1] = a * c1[2] - b * c1[1];
	cn[2] = 1.0 - c * c1[0] * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Image Encryption Algorithm Based on Hyper-chaos
	Tiegang Gao and  Zengqiang Chen 26 July 2007
***************************************************************************/

int	DoImageEncryptionHyperChaos(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    k = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[3];				// added this `w` just to implement some 'juice' in the normal Chen oscillator
	cn[1] = -c1[0] * c1[2] + d * c1[0] + c * c1[1] + c1[3];		// also changed ' - w ' to ' + w '
	cn[2] = c1[0] * c1[1] - b * c1[2];
	cn[3] = c1[0] + k;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Image Encryption via Base-n PRNGs and Parallel Base-n S-boxes
	Mohamed Gabr, Rimon Elias, Khalid Hosny and Wassim Alexan, April 12th, 2023
	https://assets.researchsquare.com/files/rs-2802227/v1_covered.pdf?c=1681276655....DOI: https://doi.org/10.21203/rs.3.rs-2802227/v1
	mohamed.gabr@ieee.org; rimon.elias@guc.edu.eg;hosny@yahoo.com; wassim.alexan@ieee.org
***************************************************************************/

int	DoImageEncryptionBase_nPRNGs(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e, f, g, start;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];
    start = param[7];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] + b * (c1[1] - c1[0]) * c1[3] * c1[3];
	cn[1] = -c1[2] - c * c1[1] - d * (c1[1] - c1[0]) * c1[3] * c1[3];
	cn[2] = c1[1];
	cn[3] = e * c1[3] + f * (c1[1] - c1[0]) - g * c1[3] * (c1[1] - c1[0]);
	if (i > start)
	    if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
		break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Implementation for Synchronisation of Chen and Liu-Yang Chaotic Systems using SMC and Active Control Schemes
	Piyush Pratap Singh, Jay Prakash Singh and B. K. Roy January 2017
	https://www.researchgate.net/publication/313397840  and received from the authors
***************************************************************************/

int	DoImplementationSynchronisationChenLiuYangChaoticSystems(void)

    {
    double	i, c1[3], cn[3], a, b, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    d = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = d * c1[0] - c1[0] * c1[2];
	cn[2] = -b * c1[2] + c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Implementation of FPGA-Based Real Time Novel Chaotic Oscillator
	Ismail Koyuncu, Ahmet Turan Ozcerit and Ihsan Pehlivan 9 February 2014
	Received from the author Ismail Koyuncu
***************************************************************************/

int	DoImplementationFPGABasedRealTimeNovelChaoticOscillator(void)

    {
    double	i, c1[3], cn[3], alpha;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alpha = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] * (1.0 - c1[2]);
	cn[1] = c1[1] * (1.0 + c1[2]) - alpha * c1[0];
	cn[2] = alpha - c1[0] * c1[1] - c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	An Improved Memristive Diode Bridge-Based Band Pass Filter Chaotic Circuit
	Quan Xu, Qinling Zhang, Ning Wang, Huagan Wu and Bocheng Bao 17 October 2017
***************************************************************************/

int	DoImprovedMemristiveDiodeBridge(void)

    {
    double	i, c1[3], cn[3], a, c, k, f, ch, th;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    c = param[1];
    k = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	f = (c1[1] - c1[0]);
	ch = exp(f) + exp(-f);
	th = (exp(f) - exp(-f)) / ch;
	cn[0] = (c + c1[2]) * th;
	cn[1] = k * c1[1] - (k + 1) * c1[0] - (c + c1[2]) * th;
	cn[2] = a * log(fabs(c * ch)) - a * log(fabs(c + c1[2]));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Improved Seven-Dimensional (i7D) Hyperchaotic Map-Based Image Encryption technique
	Manjit Kaur, Dilbag Singh and Vijay Kumar March 2022
	https://www.researchgate.net/publication/358784833
***************************************************************************/

int	DoImproved7DHyperchaoticMapBasedImageEncryptiontechnique(void)

    {
    double	i, c1[7], cn[7], k, m, l, n, s, w, t1, t2, h, u;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// t
    c1[4] = param[14];	// u
    c1[5] = param[15];	// v
    c1[6] = param[16];	// w

    k = param[0];
    m = param[1];
    l = param[2];
    n = param[3];
    s = param[4];
    w = param[5];
    t1 = param[6];
    t2 = param[7];
    h = param[8];
    u = param[9];
    totpasses = 10;

    InitOscillator(c1, 7);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = k * (c1[1] - c1[0]) + c1[3] + m * c1[5];
	cn[1] = l * c1[0] - c1[1] - c1[0] * c1[2] + c1[4];
	cn[2] = -n * c1[2] + c1[0] * c1[1];
	cn[3] = s * c1[3] - c1[0] * c1[2];
	cn[4] = -w * c1[1] + c1[5];
	cn[5] = t1 * c1[0] + t2 * c1[1];
	cn[6] = h * c1[6] + u * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 7, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Improving the Complexity of the Lorenz Dynamics
	Maria Pilar Mareca and Borja Bordel 10 January 2017
***************************************************************************/

int	DoImprovingLorenzDynamics(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = d * (c1[1] - c1[0]) + 2.0 * c1[3];
	cn[1] = 5.0 * c1[0] + c * c1[1] - 4.0 * c1[0] * c1[2];
	cn[2] = c1[0] * c1[1] - 3.0 * c1[2];
	cn[3] = -b * c1[3] - a * (c1[0] - c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Impulsive Control and Synchronisation of a New 5D Hyperchaotic System
	K. Kemih, MH. Bouraout, M.  Messadi and M. Ghanes April, 26-29, 2012
***************************************************************************/

int	DoImpulsiveControl(void)

    {
    double	i, c1[5], cn[5], a1, a2, a3, a4, a5;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// v
    c1[4] = param[14];	// w

    a1 = param[0];
    a2 = param[1];
    a3 = param[2];
    a4 = param[3];
    a5 = param[4];
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a1 * (c1[1] - c1[0]) + c1[1] * c1[2] * c1[3] * c1[4];
	cn[1] = a2 * (c1[0] + c1[1]) - c1[0] * c1[2] * c1[3] * c1[4];
	cn[2] = -c1[2] + 0.1 * c1[0] * c1[0];
	cn[3] = -a3 * c1[3] + c1[0] * c1[1] * c1[2] * c1[4];
	cn[4] = -a4 * (c1[4] + c1[3]) + a5 * c1[0] + c1[0] * c1[1] * c1[2] * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Impulsive Control for T-S Fuzzy Model Based Chaotic Systems Consisting of Van der Pol Oscillators Coupled to Linear Oscillators
	Qi-Shui Zhong, Jing-Fu Bao, and Zhu-Sheng Kang DECEMBER 2007
	http://www.ccs.asia.edu.tw/ezfiles/2/1002/img/446/0704-16.pdf
***************************************************************************/

int	DoImpulsiveControlTSFuzzyModel(void)

    {
    double	i, c1[4], cn[4], e1, e2, lambda, a, omega;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    e1 = param[0];
    e2 = param[1];
    lambda = param[2];
    a = param[3];
    omega = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = e1 * (1.0 - c1[0] * c1[0]) * c1[1] - c1[0] + a * (e2 * c1[3] + omega/* * omega*/ * c1[2] - lambda * c1[0]);
	cn[2] = c1[3];
	cn[3] = -e2 * c1[3] - omega/* * omega*/ * c1[2] + lambda * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Impulsive Synchronisation for a New Chaotic Oscillator Images
	SINUHE BENITEZ, LEONARDO ACHO March 17, 2006
***************************************************************************/

int	DoImpulsiveSyncI(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[1] + b * c1[2];
	cn[1] = c * c1[0] + d * c1[1] + e * c1[2];
	cn[2] = -c1[2] - c1[0] - c1[1] * (c1[0] * c1[0] - 1.0);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Impulsive Synchronisation for a New Chaotic Oscillator Images
	SINUHE BENITEZ, LEONARDO ACHO March 17, 2006
***************************************************************************/

int	DoImpulsiveSyncII(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[1] + b * c1[2];
	cn[1] = c * c1[0] + c + d * c1[1] * c1[1] + e * c1[2];
	cn[2] = -c1[2] - c1[0] - c1[1] * (c1[0] * c1[0] - 1.0);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Inductor-Free Multi-Stable Chua’s Circuit Constructed by Improved PI-Type Memristor Emulator and Active Sallen–Key High-Pass Filter
	Jiaoyan Luo, Han Bao, Mo Chen, Quan Xu and Bocheng Bao 14 October 2019
	Received through Research Gate
***************************************************************************/

int	DoInductorFreeMultiStableChuasCircuit(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, m, k, g, w01;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    m = param[4];
    k = param[5];
    g = param[6];
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	w01 = c * g * fabs(c1[0] - m * c1[1]) - c;
	cn[0] = -a * c1[1];
	cn[1] = -b * (c1[1] - c1[2]) - w01 * c1[1];
	cn[2] = c1[1] + (d * k - d - 1) * c1[2] + d * k * c1[3];
	cn[3] = -d * (c1[2] + c1[3]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Induced Synchronization of a Bistable Oscillator with Chaotic Dynamics
	6d -Features of Induced Synchronization of a Bistable Oscillator with Chaotic Dynamics
	Er. V. Kal’yanov June 14, 2011
***************************************************************************/

int	DoInducedSynchronization(void)

    {
    double	i, c1[6], cn[6], a, d, b, r, g, w0, a0, h1, h2;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w

    a = param[0];
    d = param[1];
    b = param[2];
    r = param[3];
    g = param[4];
    w0 = param[5];
    a0 = param[6];
    totpasses = 10;

    InitOscillator(c1, 6);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	h1 = -1.25 * c1[0] + 0.1 * c1[0] * c1[0] * c1[0];
	cn[0] = c1[1] - c1[0] - h1 + b * cos(w0 * i);
	cn[1] = 1.0 / a * (c1[0] - c1[1] + c1[2]);
	cn[2] = -d * (c1[1] + r * c1[2]);
	h2 = -1.25 * c1[3] + 0.1 * c1[3] * c1[3] * c1[3];
	cn[3] = c1[4] - c1[3] - h2 + g * (c1[0] - c1[3]);
	cn[4] = a0 / a * (c1[3] - c1[4] + c1[5]);
	cn[5] = -d * (c1[4] + r * c1[5]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Infinite Multistability in a Self-Reproducing Chaotic System
	Chunbiao Li, Julien Clinton Sprott, Wen Hu and Yujie Xu June 30, 2017
	http://sprott.physics.wisc.edu/pubs/paper467.pdf
***************************************************************************/

int	DoInfiniteMultistability(void)

    {
    double	i, c1[3], cn[3], a, b, azao, bezao;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    azao = param[2];
    bezao = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[2] + c1[1] * c1[1] - 1;
	cn[1] = b * c1[1] * c1[2];
	cn[2] = -azao * sin(bezao * c1[0]) - c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Infinite-Scroll Attractor Generated by the Complex Pendulum Model
	Sachin Bhalekar Shahed Vahedi, Mohd Salmi Md Noorani 2013
***************************************************************************/

int	DoInfiniteScroll(void)

    {
    double	i, c1[4], cn[4], a, ch, sh, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    e = exp(1.0);
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	ch = (pow(e, c1[2]) + pow(e, (-c1[2]))) / 2.0;
	cn[1] = -a * sin(c1[0]) * ch;
	cn[2] = c1[3];
	sh = (pow(e, c1[2]) - pow(e, (-c1[2]))) / 2.0;
	cn[3] = -a * sh * cos(c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Infinitely Many Coexisting Conservative Flows in a 4D Conservative System Inspired by LC Circuit
	Ning Wang, Guoshan Zhang and Han Bao 1 January 2020
	Sent directly by Ning Wang -  article in https://www.researchgate.net/requests/r67959251
***************************************************************************/

int	DoInfinitelyManyCoexistingConservativeFlows(void)

    {
    double	i, c1[4], cn[4], a, b, c, h1;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
//    k = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	h1 = 0.5 * (fabs(c1[0] + 1) / (c1[0] + 1) - fabs(c1[0] - 1) / (c1[0] - 1));
	cn[0] = c1[3] - c1[2];
	cn[1] = a * c1[3];
	cn[2] = b * c1[0];
	cn[3] = c * (h1 - c1[0] - c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Infinitesimal Chaotic Spheres Images
***************************************************************************/

int	DoInfinitesimalChaoticSpheres(void)

    {
    double	i, c[3], cn[3], a1, a2, a3, b, c1, c2, c3, c4, d, e = exp(1.0);

    c[0] = param[10];	// x
    c[1] = param[11];	// y
    c[2] = param[12];	// z

    a1 = param[0];
    a2 = param[1];
    a3 = param[2];
    b = param[3];
    c1 = param[4];
    c2 = param[5];
    c3 = param[6];
    c4 = param[7];
    d = param[8];
    totpasses = 10;

    InitOscillator(c, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i += 4.0)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a1 * c[0] - a2 * c[1] + a3 * c[2] + 2.0 * (1.0 - pow(e, (-200.0 * sin(c[1]))) / (1.0 + pow(e, (-200.0 * sin(c[1])))));
	cn[1] = -d * c[0] * c[2] + b;
	cn[2] = c1 * c[0] * c[1] + c2 * c[1] * c[2] + c3 * c[2] + c4;
	if (DisplayOscillator(c, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	The Influence of Delay Factors on the Genesis of Deterministic Chaos in Non-Ideal Pendulum Systems
	Aleksandr Yu. Shvets and Alexander Makaseyev January 2017
	http://www.cmsim.eu/papers_pdf/january_2017_papers/Jan_3_2017_CMSIM_shvets_makaseyev_49-56.pdf
***************************************************************************/

int	DoInfluenceDelayFactorsDeterministicChaos(void)

    {
    double	i, c1[3], cn[3], c, d, e, f, gamma, delta;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    c = param[0];
    d = param[1];
    e = param[2];
    f = param[3];
    gamma = param[4];
    delta = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 1.0 / (1.0 + c * delta) * (c * c1[0] - c1[1] * (c1[2] - gamma * (d * c1[1] + e * c1[2] + f)) - 1.0 / 8.0 * (c1[0] * c1[0] * c1[1] + c1[1] * c1[1] * c1[1]));
	cn[1] = 1.0 / (1.0 + c * delta) * (c * c1[1] + c1[0] * c1[2] - c1[0] * gamma * (d * c1[1] + e * c1[2] + f) + 1.0 / 8.0 * (c1[0] * c1[0] * c1[0] + c1[0] * c1[1] * c1[1]) + 1.0);
	cn[2] = (1.0 - c * gamma) * d * c1[1] - d * gamma / 8.0 * (c1[0] * c1[0] * c1[0] + c1[0] * c1[1] * c1[1] + 8.0 * c1[0] * c1[2] + 8.0) + e * c1[2] + f;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Initial Condition-Dependent Dynamics and Transient Period in Memristor-Based Hypogenetic Jerk System
	Han Bao, Ning Wang, Bocheng Bao, Mo Chen, Peipei Jin and Guangyi Wang 3 October 2017
	https://www.researchgate.net/publication/320184894_Initial_condition-dependent_dynamics_and_transient_period_in_memristor-based_hypogenetic_jerk_system_with_four_line_equilibria
***************************************************************************/

int	DoInitialConditionDependentDynamics(void)

    {
    double	i, c1[4], cn[4], a, b, c, alpha, beta, fw;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    alpha = param[3];
    beta = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	fw = alpha - beta * fabs(c1[3]);
	cn[0] = fabs(c1[1]) - b;
	cn[1] = fw * c1[2];
	cn[2] = fabs(c1[0]) - c1[1] - a * c1[2] - c;
	cn[3] = c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Initial Offset Boosting Coexisting Attractors in Memristive Multi-Double-Scroll Hopfield Neural Network.
	Sent to ManpWIN by Sen Zhang through  https://www.researchgate.net/publication/345706452_Initial_offset_boosting_coexisting_attractors_in_memristive_multi-double-scroll_Hopfield_neural_network [accessed Nov 17 2020].
	Sen Zhang, Jiahao Zheng, Xiaoping Wang, Zhigang Zeng and Shaobo He october 2020
***************************************************************************/

int	DoInitialOffsetBoostingCoexistingAttractors(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    k = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	double	x1, x2, x3, x4, t1, t2, t3, hw, uw;
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	x1 = c1[0]; x2 = c1[1]; x3 = c1[2]; x4 = c1[3];
	t1 = tanh(x1); t2 = tanh(x2); t3 = tanh(x3);

//	hw = x4 - fabs(x4 - 1) / (x4 - 1) - fabs(x4 + 1) / (x4 + 1) - fabs(x3 - 3) / (x4 - 3) - fabs(x4 + 3) / (x4 - 3);
	hw = 0.0;
	uw = a + b * hw;

	cn[0] = -x1 + 2.2 * t1 - 1.2 * t2 + .5 * t3;
	cn[1] = -x2 + 2 * t1 + k * uw * t2 + 1.15 * t3;
	cn[2] = -x3 - 5 * t1 - t3 + t2 - t1;
	cn[3] = c * t2 - d * hw - x3 + x1 - x2;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Integer and Fractional General System and Its Application to Control Chaos and Synchronization
	Mihaela Neamuu, Anamaria Liuoiu, and Petru C. Strain 1 April 2015
***************************************************************************/

int	DoIntegerFractional(void)

    {
    double	i, c1[3], cn[3], a, b1, b2, c, d, l, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b1 = param[1];
    b2 = param[2];
    c = param[3];
    d = param[4];
    l = param[5];
    k = param[6];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i += 4.0)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[2];
	cn[1] = b1 * c1[0] - b2 * c1[0] * c1[2] - c1[1];
	cn[2] = -c * c1[2] + d * c1[0] * c1[1] + l * pow(c1[0], 5) + k * pow(c1[1], 13);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 2) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Invariant Sets of a 4 Dimensional System
	LOCALIZATION OF COMPACT INVARIANT SETS OF A 4D SYSTEM AND ITS APPLICATION IN CHAOS
	Zhinan Wu, Fuchen Zhang and Xiaowu Li april 2012
***************************************************************************/

int	DoInvariantSets4D(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i += 4.0)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c * c1[3];
	cn[1] = d * c1[0] - c1[0] * c1[2] - c1[1];
	cn[2] = c1[0] * c1[1] - b * c1[2];
	cn[3] = -c1[0] - a * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	"Invented" Based on Muthuswamy-Chua Attractor
	TOPOLOGICAL ANALYSIS OF CHAOTIC SOLUTION OF A THREE-ELEMENT MEMRISTIVE CIRCUIT
	JEAN-MARC GINOUX, CHRISTOPHE LETELLIER, LEON O. CHUA November, 23, 2014
***************************************************************************/

int	DoInventedMuthuswamy(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - c1[0] + c1[2];
	cn[1] = -c1[0] / 3.0 + c1[1] / 2.0 - c1[1] * pow(fabs(c1[2]), 2.5) / 4.0;
	cn[2] = c1[1] - a * c1[2] + c1[1] * c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Invention - Opened
	Marcus Rezende 04/02/2019
	No references
***************************************************************************/

int	DoInventionOpened(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];

    InitOscillator(c1, 2);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] + a * cos(c1[1]) * sin(c1[1]) - b * sin(c1[1]) * cos(c1[0]);
	cn[1] = c1[0] + c * sin(c1[0]) * cos(c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 2, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Invisible Grazings and Dangerous Bifurcations in Impacting Systems--The Problem of Narrow-Band Chaos
	Soumitro Banerjee, James Ing, Ekaterina Pavlovskaia, Marian Wiercigroch and Ramesh K. Reddy 17 March 2009
	https://d1wqtxts1xzle7.cloudfront.net/40108043
***************************************************************************/

int	DoInvisibleGrazings(void)

    {
    double	i, c1[3], cn[3], qsi, b, e, w, a, h;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    qsi = param[0];
    b = param[1];
    e = param[2];
    w = param[3];
    a = param[4];

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	h = -sin(sin(c1[0] - e));					// the paper does not give the 'h' function and I assumed it to be a SINE function
	cn[0] = c1[1];
	cn[1] = a * w * w * sin(w * i) - 2 * qsi * c1[1] - c1[0] - b * (c1[0] - e) * h;
	cn[2] = sin(w * i) + cos (w * i);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Irregular Attractors 
	VADIM S. ANISHCHENKO and GALINA I. STRELKOVA  20 September 1997
	https://www.hindawi.com/journals/ddns/1998/252749/abs/
***************************************************************************/

int	DoIrregularAttractors(void)

    {
    double	i, c1[3], cn[3], g, l, m;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    m = param[0];
    g = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = m * c1[0] + c1[1] - c1[0] * c1[2];
	cn[1] = -c1[0];
	l = (c1[0] > 0) ? 1.0 : 0.0;
	cn[2] = -g * c1[2] + g * l * c1[0] * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Irregular Chaotic Attractor Images
	VADIM S. ANISHCHENKO and GALINA I. STRELKOVA  20 September 1997
***************************************************************************/

int	DoIrregularChaoticAttractor(void)

    {
    double	i, c1[3], cn[3], a, g, l, m;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    m = param[1];
    g = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = m * c1[0] + c1[1] - c1[0] * c1[2];
	cn[1] = -3 * c1[0];
	l = (c1[0] > 0) ? 1.0 : 0.0;
	cn[2] = -g * c1[2] + g * l * c1[0] * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Jerk System with Self-Exciting and Hidden Flows and the Effect of Time Delays on Existence of Multi-Stability I
	Karthikeyan Rajagopal, Sajad Jafari, Akif Akgul and Anitha Karthikeyan 27 March 2018
	https://www.researchgate.net/publication/324258334_Modified_jerk_system_with_self-exciting_and_hidden_flows_and_the_effect_of_time_delays_on_existence_of_multi-stability
***************************************************************************/

int	DoJerkSystemSelfExcitingHiddenFlowsI(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = -a * c1[1] + b * c1[2] + c * c1[0] * c1[0] + d * c1[0] * c1[2] + e;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Jerk System with Self-Exciting and Hidden Flows and the Effect of Time Delays on Existence of Multi-Stability II
	Karthikeyan Rajagopal, Sajad Jafari, Akif Akgul and Anitha Karthikeyan 27 March 2018
	https://www.researchgate.net/publication/324258334_Modified_jerk_system_with_self-exciting_and_hidden_flows_and_the_effect_of_time_delays_on_existence_of_multi-stability
***************************************************************************/

int	DoJerkSystemSelfExcitingHiddenFlowsII(void)

    {
    double	i, c1[3], cn[3], a, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    c = param[1];
    d = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[1];
	cn[1] = c * c1[0] + c1[2];
	cn[2] = a * c1[1] * c1[1] + c1[0] * c1[2] - d;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Jha Hyper-Chaotic Attractor in 4 Dimensions Images
***************************************************************************/

int	DoJha4D(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[3];
	cn[1] = -c1[0] * c1[2] + b * c1[0] - c1[1];
	cn[2] = c1[0] * c1[1] - c * c1[2];
	cn[3] = -c1[0] * c1[2] + d * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Joana Marcus Chaotic Attractor Images
***************************************************************************/

int	DoJoanaMarcus(void)

    {
    double	i, c1[3], cn[3], b, r, s, x0, j, k;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z

    b = param[0];
    r = param[1];
    s = param[2];
    x0 = param[3];
    j = param[4];
    k = param[5];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = b * c1[0] * c1[0] - c1[0] * c1[0] * c1[0] + c1[1] - c1[2] + j;
	cn[1] = k - 5.0 * c1[0] * c1[0] - c1[1];
	cn[2] = r * (s * (c1[0] + x0) - c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Joanna 2 Neurons Chaotic Attractor Images
	Fitzhugh-Nagumo-2 NEURONIOS
	dinamica de redes de osciladores de fitzhugh-nagumo
	Juliana vicente dos santos - tese 2013
***************************************************************************/

int	DoJoanna2Neurons(void)

    {
    double	i, c1[4], cn[4], a, b, c, g;

    c1[0] = param[10];	    // x1
    c1[1] = param[11];	    // x2
    c1[2] = param[12];	    // x3
    c1[3] = param[13];	    // x4

    a = param[0];
    b = param[1];
    c = param[2];
    g = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c * (c1[1] + c1[0] - 1.0 / 3.0 * c1[0] * c1[0] * c1[0]) + g * (c1[0] - c1[2]);
	cn[1] = -1.0 / c * (c1[0] - a + b * c1[1]);
	cn[2] = c * (c1[3] + c1[2] - 1.0 / 3.0 * c1[2] * c1[2] * c1[2]);
	cn[3] = -1.0 / c * (c1[2] - a + b * c1[3]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Joanna 3 Neurons Chaotic Attractor Images
	Fitzhugh-nagumo - 3 neuronios
	Dinamica de redes de osciladores de fitzhugh-nagumo
	Juliana vicente dos santos - tese 2013
***************************************************************************/

int	DoJoanna3Neurons(void)

    {
    double	i, c1[6], cn[6], a, b, c, g;

    c1[0] = param[10];	    // x1
    c1[1] = param[11];	    // x2
    c1[2] = param[12];	    // x3
    c1[3] = param[13];	    // x4
    c1[4] = param[14];	    // x5
    c1[5] = param[15];	    // x6

    a = param[0];
    b = param[1];
    c = param[2];
    g = param[3];
    totpasses = 10;

    InitOscillator(c1, 6);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c * (c1[1] + c1[0] - 1.0 / 3.0 * c1[0] * c1[0] * c1[0]) + g * (c1[0] - c1[2]);
	cn[1] = -1.0 / c * (c1[0] - a + b * c1[1]);
	cn[2] = c * (c1[3] + c1[2] - 1.0 / 3.0 * c1[2] * c1[2] * c1[2]) + g * (c1[2] - c1[4]);
	cn[3] = -1.0 / c * (c1[2] - a + b * c1[3]);
	cn[4] = c * (c1[5] + c1[4] - 1.0 / 3.0 * c1[4] * c1[4] * c1[4]) + g * (c1[4] - c1[0]);
	cn[5] = -1.0 / c * (c1[4] - a + b * c1[5]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Josephson Junction System Images
	Control and Synchronisation of Chaos in	RCL-Shunted Josephson Junction with
	Noise Disturbance Using Only One Controller Term
	Di-Yi Chen, Wei-Li Zhao, Xiao-Yi Ma and Run-Fan Zhang 26 May 2012
***************************************************************************/

int	DoJosephsonJunction(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = a * (d - c * c1[1] - sin(c1[0]) - c1[2]);
	cn[2] = b * (c1[1] - c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Juliana interweaving neurons in 8 Dimensions Images
***************************************************************************/

int	DoJuliana8D(void)

    {
    double	i, c1[8], cn[8], a, b, c, gamma;

    c1[0] = param[10];	// x1
    c1[1] = param[11];	// y1
    c1[2] = param[12];	// x2
    c1[3] = param[13];	// y2
    c1[4] = param[14];	// x3
    c1[5] = param[15];	// y3
    c1[6] = param[16];	// x4
    c1[7] = param[17];	// y4

    a = param[0];
    b = param[1];
    c = param[2];
    gamma = param[3];

    totpasses = 10;

    InitOscillator(c1, 8);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c * (c1[1] + c1[0] - (c1[0] * c1[0] * c1[0]) / 3.0) + gamma * (c1[0] - c1[2]) + gamma * (c1[0] - c1[4]);
	cn[1] = -1 / c * (c1[0] - a + b * c1[1]);
	cn[2] = c * (c1[3] + c1[2] - (c1[2] * c1[2] * c1[2]) / 3.0) + gamma * (c1[2] - c1[4]) + gamma * (c1[2] - c1[6]);
	cn[3] = -1 / c * (c1[2] - a + b * c1[3]);
	cn[4] = c * (c1[5] + c1[4] - (c1[4] + c1[4] + c1[4]) / 3.0) + gamma * (c1[4] - c1[6]);
	cn[5] = -1 / c * (c1[4] - a + b * c1[5]);
	cn[6] = c * (c1[7] + c1[6] - (c1[6] + c1[6] + c1[6]) / 3.0) + gamma * (c1[6] - c1[0]);
	cn[7] = -1 / c * (c1[6] - a + b * c1[7]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 8, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Knot-Holder Chaotic Oscillator Images
***************************************************************************/

int	DoKnotHolder(void)

    {
    double	i, c1[3], cn[3], b, h;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    b = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	h = 0.28 * c1[0] - 0.21 * (fabs(c1[0] + 1) - fabs(c1[0] - 1));
	cn[0] = 7.0 * (c1[1] - h);
	cn[1] = c1[0] - c1[1] + c1[2];
	cn[2] = -b * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Lab experiment: Frequency Response of Chaotic Oscillators
	Alicia Pano Azucena,  Jesus Manuel Munoz-Pachec 2010 September
	https://www.keysight.com/upload/cmc_upload/All/exp103.pdf
***************************************************************************/

int	DoLabexperiment(void)

    {
    double	t, c1[3], cn[3], a, b, c, d, f, k, ha, p, q, alpha, i;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    k = param[4];
    ha = param[5];
    p = param[6];
    q = param[7];
    alpha = param[8];
    i = param[9];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	if (c1[0] > q * ha + alpha)
	    f = (2.0 * q + 1.0) * k;
	if ((fabs(c1[0] - i * ha) <= alpha && -p <= i && i <= q)) 
	    f = k / alpha * (c1[0] - i * ha) + 2.0 * i * k;
	if (i * ha + alpha < c1[0] && c1[0] < (i + 1.0) * ha - alpha && -p <= i && i <= q - 1.0) 
	    f = (2.0 * i + 1.0) * k;
	if (c1[0] < -p * ha - alpha) 
	    f = -(2.0 * p + 1.0) * k;
	cn[2] = -a * c1[0] - b * c1[1] - c * c1[2] + d * f;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)t % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Labyrinth Chaos
	J. C. Sprott 2011
	Elegant chaos book
***************************************************************************/

int	DoLabyrinthChaos(void)

    {
    double	t, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	cn[0] = sin(c1[1]);
	cn[1] = sin(c1[2]);
	cn[2] = sin(c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 20.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Laces and Turns Chaotic Oscillator Images
***************************************************************************/

int	DoLacesAndTurns(void)

    {
    double	i, c1[4], cn[4], a, b1, b2, b3, b4, b5, b6, b;

    c1[0] = param[10];	// p1
    c1[1] = param[11];	// q1
    c1[2] = param[12];	// p2
    c1[3] = param[13];	// q2

    a = param[0];
    b = param[1];
    b1 = param[2];
    b2 = param[3];
    b3 = param[4];
    b4 = param[5];
    b5 = param[6];
    b6 = param[7];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[0] - i * c1[1] + b3 * c1[1] + b * (c1[1] * c1[2] - c1[0] * c1[3]);
	cn[1] = -a * c1[1] + i * c1[0] + b3 * c1[0] + b * (c1[0] * c1[2] + c1[1] * c1[3]);
	cn[2] = -a * c1[2] - b2 * c1[3] - 2.0 * b4 * c1[0] * c1[1];
	cn[3] = -a * c1[3] + b2 * c1[2] + b4 * (c1[0] * c1[0] - c1[1] * c1[1]) + b5;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 1) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Lambda-Phi Generalised Synchronisation: Application to Fractional Hyperchaotic Systems with Arbitrary Dimensions and Orders
	Adel Ouannas, Xiong Wang, Viet-Thanh Pham and Toufik Ziar 24 Jul 2020.
	https://www.researchgate.net/publication/343181536
***************************************************************************/

int	DoLambdaPhiGeneralisedSynchronisation(void)

    {
    double	i, c1[4], cn[4], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[0] + c1[1] * c1[2] + a * c1[0] * c1[2] * c1[3];
	cn[2] = 1 - c1[1] * c1[1];
	cn[3] = c1[2] + b * c1[0] * c1[2] + c * c1[0] * c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 50.0) % threshold), i, 4, 1) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Laser Oscillator Connected to Catastrophe's Oscillator
	Laser driven by a light beam  injecting on Catastrophe's equations
	A SEMI-CONDUCTOR LASER DRIVEN BY A LIGHT BEAM Yan-Ping Wu and Guo-Dong Wang
	Sebastian Wieczorek, Bernd Kraupskopf & Daan Lenstra 1999
***************************************************************************/

int	DoLaserCatastrophe(void)

    {
    double	i, c1[3], cn[3], delta[3], a, b, c, d, xnew, ynew, znew, w = 0.0, dx = 1.0;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	// Lorenz Butterfly
	xnew = c1[0] * c1[2] / 2.0 + (w - c * c1[2] / 2.0) * c1[1] + a;
	ynew = -(b - c * c1[2] / 2.0) * c1[0] + c1[1] * c1[2] / 2;
	znew = 2.0 * d * c1[2] - (1.0 + 2.0 * b * c1[2]) * (c1[0] * c1[0] + c1[1] * c1[1] - 1.0);
	c1[0] += xnew*dt; c1[1] += ynew*dt; c1[2] += znew*dt;
	// catastrophe equations
	cn[0] = 3.0 * c1[0] * c1[0] + a + c * c1[1];
	cn[1] = 3.0 * c1[1] * c1[1] + b + c * c1[0];
	cn[2] = 3.0 * c1[2] * c1[2] + d + c * (sqrt(fabs(c1[0] + c1[1])) + (c1[0] + c1[1]) / 2.0) / 2.0;
	// mix-up the ORIGINAL ATTRACTOR with the CATASTROPHE ATTRACTOR - thanks Marcus
	delta[0] = sqrt(fabs(cn[0])) + c1[0]; 
	delta[1] = sqrt(fabs(cn[1])) + c1[1]; 
	delta[2] = sqrt(fabs(cn[2])) + c1[2];
	if (DisplayOscillator(delta, c1, dx, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Leipnik Hyper-Chaotic Attractor in 4 Dimensions Images
***************************************************************************/

int	DoLeipnik4D(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[0] + c1[1] + 10.0 * c1[1] * c1[2] + c1[3];
	cn[1] = -c1[0] - 0.4 * c1[1] + 5.0 * c1[0] * c1[2];
	cn[2] = b * c1[2] - 5.0 * c1[0] * c1[1];
	cn[3] = -c * c1[0] * c1[2] + d * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Leonov-Kuznetsov Chaotic Attractor in 4 Dimensions Images
***************************************************************************/

int	DoLeonovKuznetsov4D(void)

    {
    double	i, c1[4], cn[4], f, sw;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	sw = c1[3] / fabs(c1[3]);
	if (c1[3] <= 0.2)
	    f = 5.0 * c1[3]; 
	else
	    f = sw + (0.04 * (c1[3] - sw * 0.2));

	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[3];
	cn[2] = c1[0] - 2.0 * c1[3] - f;
	cn[3] = c1[0] + c1[2] - c1[3] - f;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Lévy Flight survival procedure of animals Images
***************************************************************************/

#define	    MAXSTEPS	5000

int	DoLeviFlight(void)
    {
    static  double	f[MAXSTEPS], theta[MAXSTEPS];
    double	i, c1[3], cn[3], alpha, k;
    int		colour, j, d = 1;
    static  int u, v, uOld, vOld;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    srand((unsigned)time(NULL));					// randomise things

    if (iterations >= MAXSTEPS)
	iterations = MAXSTEPS - 1;
    alpha = param[0];
    colour = (int)param[1];
    k = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	j = (int)i;
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	if (OscAnimProc == NORMAL)
	    {
	    theta[j] = (double)rand() * PI * 2.0 /(RAND_MAX);
	    f[j] = exp(log((double)rand()/(RAND_MAX)) * (-1.0 / alpha));
	    }
	cn[0] = c1[0] + f[j] * cos(theta[j]);
	cn[1] = c1[1] + f[j] * sin(theta[j]);
// orig	c1[2] = 10.0 * sqrt(sqr(sin(c1[0])) + sqr(cos(c1[1])));
//	cn[2] = c1[2] + f[j] * (cos(theta[j]) + sin(theta[j]));
	if ((d = -d) > 0) 
	    cn[2] = c1[2] + f[j] * k * sin(theta[j]);
	else 
	    cn[2] = c1[2] + f[j] * k * cos(theta[j]);
	if (DisplayOscillator(c1, cn, 1.0, (colour == 0) ? ((int) (i * 5.0)) % threshold : colour, i, 3, 0) < 0)
	    break;
	c1[0] = cn[0];
	c1[1] = cn[1];
	c1[2] = cn[2];
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Lévy Zig Zag survival procedure of animals Images
	This 'new' Levy stands for the terrestrial animals in contrast with the 3D animals, 
	because they left footprints on the ground.
***************************************************************************/

int	DoLeviZigZag(void)
    {
    double	i, x[2], y[2], x0, y0, x1, y1, dx, dy, alpha, k, s, f, h, m, t, theta, p, q;
    int		colour;
    static  int u, v, uOld, vOld;

    x[0] = param[10];	// x0
    x[1] = param[11];	// x1
    y[0] = param[12];	// y0
    y[1] = param[13];	// y1

    srand((unsigned)time(NULL));					// randomise things

    alpha = param[0];
    s = param[1];
    m = param[2];
    t = param[3];
    k = param[4];
    colour = (int)param[5];
    totpasses = 10;

    for (i = 2; i < s; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	theta = (double)rand() * PI * 2.0 /(RAND_MAX);
	f = exp(log((double)rand()/(RAND_MAX)) * (-1.0 / alpha));
	x[1] = x[0] + f * cos(theta);
	y[1] = y[1] + f * sin(theta);
	x0 = (double) xdots / 2.0 + x[0] * m; 
	x1 = (double) xdots / 2.0 + x[1] * m;
	y0 = (double) ydots / 2.0 + y[0] * m; 
	y1 = (double) ydots / 2.0 + y[1] * m;
	dx = fabs(x1 - x0);
	dy = fabs(y1 - y0);
	h = (dx == 0.0) ? 0.0 : log(dy / dx);

	if (dx > dy)
	    {
	    for (p = x0; p <= x1; p += (x1 - x0) / dx)
		{
		t = t * k;
		q = (p - x0) / (x1 - x0) * (y1 - y0) + y0;
		Plot.PlotPoint((WORD)p, (WORD)(q + t * ScreenRatio - h), (colour == 0) ? ((int) (i * 5.0)) % threshold : colour);
		}
	    }
	else
	    {
	    for (q = y0; q <= y1; q += (y1 - y0) / dy)
		{
		t = t * k;
		p = (q - y0) / (y1 - y0) * (x1 - x0) + x0;
		Plot.PlotPoint((WORD)(p + t * ScreenRatio - h), (WORD)q, (colour == 0) ? ((int) (i * 5.0)) % threshold : colour);
		}
	    }
	x[0] = x[1];
	y[0] = y[1];
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Li - Symmetrical Toroidal Chaos Images
***************************************************************************/

int	DoLi(void)

    {
    double	i, c1[3], cn[3], a, c, d, e, f, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    c = param[1];
    d = param[2];
    e = param[3];
    f = param[4];
    k = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + d * c1[0] * c1[2];
	cn[1] = k * c1[0] + f * c1[1] - c1[0] * c1[2];
	cn[2] = c * c1[2] + c1[0] * c1[1] - e * c1[0] * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Linear and Non-linear Arabesque Images
	A STUDY OF CLOSED CHAINS OF NEGATIVE 2-ELEMENT CIRCUITS
	CHRIS ANTONOPOULOS, VASILEIOS BASIOS, JACQUES DEMONGEOT PASQUALE NARDONE, RENE THOMAS
	April 14, 2013
***************************************************************************/

int	DoLinearArabesque(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] * c1[1] * c1[1] - c1[2];
	cn[1] = c1[2] * c1[2] * c1[2] - c1[0];
	cn[2] = c1[0] * c1[0] * c1[0] - c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Liu Chen Attractor Images
***************************************************************************/

int	DoLiuChen(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e, f, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[1] + b * c1[0] + c * c1[1] * c1[2];
	cn[1] = d * c1[1] - c1[2] + e * c1[0] * c1[2];
	cn[2] = f * c1[2] + g * c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Lorenz Chaotic Attractor Images
***************************************************************************/

int	DoLorenz(void)

    {
    double	i, c1[3], cn[3], b, s, r;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    s = param[0];
    r = param[1];
    b = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = s * (c1[1] - c1[0]);
	cn[1] = (r * c1[0]) - c1[1] - (c1[0] * c1[2]);
	cn[2] = (c1[0] * c1[1]) - (b * c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Lorenz-84 Atmospheric Circulation Model
	Dynamical Analysis of the Lorenz-84 Atmospheric Circulation Model' March 31, 2013
***************************************************************************/

int	DoLorenz84Osc(void)

    {
    double	i, c1[3], cn[3], b, f, g, a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    b = param[0];
    f = param[1];
    g = param[2];
    a = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[1] * c1[1] - c1[2] * c1[2] - a * c1[0] + a * f;
	cn[1] = c1[0] * c1[1] - b * c1[0] * c1[2] - c1[1] + g;
	cn[2] = b * c1[0] * c1[1] + c1[0] * c1[2] - c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Lorenz Chaotic Attractor in 8 Dimensions Images
	Generalized Lorenz models and their routes to chaos.
	III. Energy-conserving horizontal and vertical mode truncations
	D. Roy  Zdzislaw Musielak 20O7, Montreal
***************************************************************************/

int	DoLorenz8D(void)

    {
    double	i, c[8], cn[8], a, b, c1, c2, c3, s, r;

    c[0] = param[10];	// x
    c[1] = param[11];	// y
    c[2] = param[12];	// z
    c[3] = param[13];	// x1
    c[4] = param[14];	// y1
    c[5] = param[15];	// z1
    c[6] = param[16];	// x2
    c[7] = param[17];	// y2

    a = 3.0 * sqrt(2.0);
    c1 = 3.0 / 4.0 * sqrt(2.0);
    c2 = (1.0 + 4.0 * a * a) / (1 + a * a);
    c3 = (4.0 + a * a) / (1 + a);

    r = param[0];
    s = param[1];
    b = param[2];
    totpasses = 10;

    InitOscillator(c, 8);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -s * c[0] + s * c[1] - c1 * c[3] * c[6];
	cn[1] = -c[0] * c[2] + r * c[0] - c[1] + c1 * (c[3] * c[7] + c[6] * c[4] + c[6] * c[4]);
	cn[2] = c[0] * c[1] - b * c[2] + 2.0 * c[3] * c[4];
	cn[3] = -c2 * s * c[3] + 2.0 * s / c2 * c[4] + c1 * c[0] * c[6];
	cn[4] = -2.0 * c[3] * c[2] + 2.0 * r * c[3] - c2 * c[4] - c1 * (c[6] * c[1] + c[3] * c[7]);
	cn[5] = 2.0 * c[6] * c[7] - 4.0 * b * c[5];
	cn[6] = -c3 * s * c[6] + s / c3 * c[7] - c1 * c[0] * c[3];
	cn[7] = -c3 * c[7] + 2.0 * r * c[6] - c1 * (c[0] * c[4] + c[3] * c[1]) - 2.0 * c[6] * c[5];
	if (DisplayOscillator(c, cn, dt, ((DWORD)i % threshold), i, 8, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Lorenz Like Chaotic Attractor + Marcus Images
	A New Three-Scroll Unified Chaotic System Coined
	Lin Pan, Wuneng Zhou, Jian'an Fang , Dequan Li 10 March 2010
***************************************************************************/

int	DoLorenzLike(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e, f, gamma;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    gamma = param[6];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + d * c1[0] * c1[2];
	cn[1] = b * c1[0] - c1[0] * c1[2] + f * c1[1];
	cn[2] = -e * c1[0] * c1[0] + c1[0] * c1[1] + c * c1[2];
	cn[3] = gamma * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Lorenz Minus Catastrophe Equations
	Fractal forum from a distant past
***************************************************************************/

int	DoLorenzMinusCatastrophe(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, frac, h, xnew, ynew, znew;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    frac = param[4];
    h = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	// Lorenz Butterfly
	xnew = c1[0] + 10.0 * h * (c1[1] - c1[0]);
	ynew = c1[1] + h * (28 * c1[0] - c1[1] - c1[0] * c1[2]);
	znew = c1[2] + h * (c1[0] * c1[1] - c1[2] * frac);
	c1[0] = xnew; c1[1] = ynew; c1[2] = znew;
	// catastrophe equations
	cn[0] = 3.0 * c1[0] * c1[0] + a + c * c1[1];
	cn[1] = 3.0 * c1[1] * c1[1] + b + c * c1[0];
	cn[2] = 3.0 * c1[2] * c1[2] + d + c * (sqrt(fabs(c1[0] + c1[1])) + (c1[0] + c1[1]) / 2.0) / 2.0;
	// subtract Catastrophe from Lorenz to form Catastrophic Chaotic Attractor
//	cn[0] -= cn[0]; c1[1] -= cn[1]; c1[2] -= cn[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Lorenz-Mod1 Chaotic Attractor Images
***************************************************************************/

int	DoLorenzMod(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[0] + c1[1] * c1[1] - c1[2] * c1[2] + a * c;
	cn[1] = c1[0] * (c1[1] - b * c1[2]) + d;
	cn[2] = -c1[2] + c1[0] * (b * c1[1] + c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Lorenz-Stenflo Chaotic System Images
	4D Lorenz-different Guaranteed Cost Control Design of 4D Lorenz-Stenflo 
	Chaotic System via T-S Fuzzy Approach 
	Yi-You Hou, Meei-Ling Hung, and Jui-Sheng Lin g12 March 2012
***************************************************************************/

int	DoLorenzStenflo4D(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];    // x1
    c1[1] = param[11];    // x2
    c1[2] = param[12];    // x3
    c1[3] = param[13];    // x4

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + b * c1[3];
	cn[1] = c * c1[0] - c1[0] * c1[2] - c1[1];
	cn[2] = c1[0] * c1[1] - d * c1[2];
	cn[3] = -c1[0] - a * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Lorenz Unlike Chaotic Attractor Images
	Angelo A. Beltran Jr. 2014
***************************************************************************/

int	DoLorenzUnlike(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, m, n;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    m = param[4];
    n = param[5];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0] * c1[0] * c1[0]);
	cn[1] = c1[0] * (b * c1[0] * c1[0] * c1[0] - c * c1[2] * c1[2] * c1[2]) - d * c1[1];
	cn[2] = m * pow(c1[0] * c1[1], 3) - n * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Lotka-Volterra Chaotic System Images
***************************************************************************/

int	DoLotkaVolterra(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i += dt / 10.0)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] - c1[0] * c1[1] + c * c1[0] * c1[0] - a * c1[0] * c1[0] * c1[2];
	cn[1] = -c1[1] + c1[0] * c1[1];
	cn[2] = -b * c1[2] + a * c1[0] * c1[0] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / dt) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Loving Lorenz Attractor Images
***************************************************************************/


int	DoLovingLorenz(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i += dt)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[0] - c1[1] * c1[1] + c1[2] * c1[2] + a * c;
	cn[1] = c1[0] * (c1[1] - b * c1[2]) - d;
	cn[2] = c1[2] + c1[0] * (b * c1[1] - c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / dt) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Lozi Map Equations Converted into a Chaotic Oscillator I
	A NEW CHAOTIC ATTRACTOR FROM 2D DISCRETE MAPPING VIA BORDER-COLLISION PERIOD-DOUBLING SCENARIO
	ZERAOULIA ELHADJ 12 April 2005
***************************************************************************/

int	DoLoziMapI(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 1.0 + a * (fabs(c1[0]) - c1[1] * c1[1]);
	cn[1] = b * c1[0];
	cn[2] = c1[0] * c1[1] + b * c1[2];				// Marcus made this one up
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Lozi Map Equations Converted into a Chaotic Oscillator II
	A NEW CHAOTIC ATTRACTOR FROM 2D DISCRETE MAPPING VIA BORDER-COLLISION PERIOD-DOUBLING SCENARIO
	ZERAOULIA ELHADJ 12 April 2005
***************************************************************************/

int	DoLoziMapII(void)

    {
    double	i, c1[3], cn[3], a, b, real, imag;

    c1[0] = cn[0] = param[10];	// x
    c1[1] = cn[1] = param[11];	// y
    c1[2] = cn[2] = 1.0;	// z

    a = param[0];
    b = param[1];
    real = param[2];
    imag = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	c1[0] = cn[0];
	c1[1] = cn[1];
	cn[0] = 1.0 - a * fabs(c1[0]) + b * c1[1];
	cn[1] = b * c1[0];
	cn[2] = real * cos(c1[1]) + imag * sin(c1[0]);				// Marcus made this one up
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Low Power Pseudo-Random Number Generator Based on Lemniscate Chaotic Map
	Mohamed Saber and Marwa M. Eid Jun 28, 2020
	https://www.researchgate.net/publication/348938000
***************************************************************************/

int	DoLowPowerPseudoRandomNumberGenerator(void)

    {
    double	i, c1[3], cn[3], d1, d2, temp, TwoShiftedByR, real, imag, freq, root2 = sqrt(2.0);
    int		r;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    r = (int)param[0];
    real = param[1];
    imag = param[2];
    freq = param[3];
    TwoShiftedByR = (double)(2 << (r - 1));
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	temp = cos((c1[1]) * TwoShiftedByR);
	d1 = 2 - temp * temp;
	temp = sin(c1[0] * TwoShiftedByR);
	d2 = 3 - temp * temp;
	cn[0] = cos(c1[1] * TwoShiftedByR) / d1;
	cn[1] = root2 * sin(2 * c1[0] * TwoShiftedByR) / d2;
	cn[2] = real * cos(c1[1] / freq) + imag * sin(c1[0] / freq);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 6.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	LSD - Lines, Surfaces and Dots Images
***************************************************************************/


int	DoLSD(void)

    {
    double	i, c1[4], cn[4], a, b, a1, a2;

    c1[0] = param[10];	// u
    c1[1] = param[11];	// v
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	a1 = 5.0 * c1[0];
	a2 = 5.0 * sqrt(fabs(c1[1] - 0.0001));
	a = sqrt(fabs(a1 * a2));
	b = 3.0 * a / 5.0 - 25.0 / a - 0.1;
	c1[2] = a;
	c1[3] = b;
	cn[0] = a - c1[0] + 4.0 * c1[0] * c1[1] / (1.0 + c1[0] * c1[0]);
	cn[1] = b * (c1[0] - c1[0] * c1[1] / (1 + c1[0] * c1[0]));
	cn[2] = 0.0;
	cn[3] = 0.0;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 1) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Lu Hyper-Chaotic Attractor in 4 Dimensions Images
***************************************************************************/

int	DoLu4D(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[3];
	cn[1] = -c1[0] * c1[2] + c * c1[1];
	cn[2] = c1[0] * c1[1] - b * c1[2];
	cn[3] = d * c1[3] + c1[0] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Lu Like Chaotic Attractor + Marcus Images
	A New Three-Scroll Unified Chaotic System Coined
	Lin Pan, Wuneng Zhou, Jian'an Fang , Dequan Li 10 March 2010
***************************************************************************/

int	DoLuLike(void)

    {
    double	i, c1[4], cn[4], a, c, d, e, f, gamma;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    c = param[1];
    d = param[2];
    e = param[3];
    f = param[4];
    gamma = param[5];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + d * c1[0] * c1[2];
	cn[1] = -c1[0] * c1[2] + f * c1[1];
	cn[2] = -e * c1[0] * c1[0] + c1[0] * c1[1] + c * c1[2];
	cn[3] = gamma * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Machado, Savi, Pacheco Chaotic Attractor Images
	Nonlinear dynamics and chaos in coupled shape memory oscillators
***************************************************************************/

int	DoMachado(void)

    {
    double	i, c1[4], cn[4], w1, w2, q1, q2, q3, b1, b2, b3, d1, d2, e1, e2, e3, a21, a32, m, teta1, teta2, teta3;

    c1[0] = param[10];    // y0
    c1[1] = param[11];    // y1
    c1[2] = param[12];    // y2
    c1[3] = param[13];    // y3

    a21 = 1.0; a32 = 0.0;

    teta1 = param[0];
    teta2 = param[1];
    teta3 = param[2];
    m = param[3];
    d1 = param[4];
    d2 = param[5];
    w1 = w2 = param[6];
    q1 = q2 = q3 = param[7];
    b1 = b2 = b3 = param[8];
    e1 = e2 = e3 = param[9];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = d1 * sin(w1 * i) - (q1 + q2 * a21 * m) * c1[1] + q2 * a21 * m * c1[3] - ((teta1 - 1.0) + a21 * a21 * m * (teta2 - 1.0)) * c1[0] + a21 * a21 * m * (teta2 - 1.0) 
		* c1[2] + b1 * c1[0] * c1[0] * c1[0] - e1 * pow(c1[0], 5) - b2 * a21 * a21 * m * pow((c1[2] - c1[0]), 3) + e2 * a21 * a21 * m * pow((c1[2] - c1[0]), 5);
	cn[2] = c1[3];
	cn[3] = a21 * a21 * d2 * sin(w2 * i) + q2 * a21 * c1[1] - (q2 * a21 + q3 * a21 * a32) * c1[3] + a21 * a21 * (teta2 - 1) * c1[0] - (a21 * a21 * (teta2 - 1.0) 
		+ a21 * a21 * a32 * a32 * (teta3 - 1)) * c1[2] + b2 * a21 * a21 * pow(c1[2] - c1[0], 3) - e2 * a21 * a21 * pow((c1[2] - c1[0]), 5) 
		+ b3 * a21 * a21 * a32 * a32 * c1[2] * c1[2] * c1[2] - e3 * a21 * a21 * a32 * a32 * pow(c1[2], 5);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 4.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Magnet Synchronous Motor Systems Images
	Finite-Time Chaos Suppression of Permanent Magnet Synchronous Motor Systems
	Yi-You Hou 21 April 2014
***************************************************************************/

int	DoMagnet(void)

    {
    double	i, c1[3], cn[3], gamma, sigma;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    gamma = param[0];
    sigma = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[0] + c1[1] * c1[2];
	cn[1] = -c1[1] - c1[0] * c1[2] + gamma * c1[2]; 
	cn[2] = sigma * (c1[1] - c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 4.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Magnetic Field Induced Dynamical Chaos Images
	Somrita Ray, Alendu Baura, and Bidhan Chandra Bag 20 November 2013
***************************************************************************/

int	DoMagneticField(void)

    {
    double	i, c1[6], cn[6], a, b, w, omega;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// ux
    c1[3] = param[13];	// uy
    c1[4] = param[14];	// z
    c1[5] = param[15];	// uz

    a = param[0];
    b = param[1];
    w = param[2];
    omega = param[3];
    totpasses = 10;

    InitOscillator(c1, 6);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2];
	cn[1] = c1[3]; 
	cn[2] = -4.0 * a * c1[0] * c1[0] * c1[0] + (b + b) * c1[0] + omega * c1[3];
	cn[3] = -w * w * c1[1] - omega * c1[2];
	cn[4] = c1[5]; 
	cn[5] = -w * w * c1[4];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 24.0) % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Magnetic Stochasticity in Magnetically Confined Fusion Plasmas - Book
	Sadrilla Abdullaev May 2013
	e-book
***************************************************************************/

int	DoMagneticStochasticity(void)

    {
    double	i, c1[3], cn[3], a, b, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    b = param[0];
    a = param[1];
    k = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = b * b * c1[1];
	cn[1] = a * a * c1[0] * (1 - c1[0] * c1[0] / k / k); 
	cn[2] = a * sin(c1[0]) + b * cos(c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 24.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Marcus-1 Chaotic Oscillator Images
***************************************************************************/

int	DoMarcus01(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] -	c1[0] * c1[2] - c1[1] * c1[2] - c1[0];
	cn[1] = a * c1[0] * c1[2] + c1[1];
	cn[2] = c1[1] * c1[1] - b * c1[2] * c1[2] - c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 3.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Marcus-2 Chaotic Oscillator Images
***************************************************************************/

int	DoMarcus02(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] -	c1[0] * c1[2] - c1[1] * c1[2] - c1[0];
	cn[1] = a * c1[0] * c1[2] + c1[1] + c1[2];
	cn[2] = c1[1] * c1[1] - b * c1[2] * c1[2] - c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 3.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Marcus-3 Chaotic Oscillator Images
***************************************************************************/

/*
int	DoMarcus03(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] -	c1[0] * c1[2] - c1[1] * c1[2] - c1[0];
	cn[1] = a * c1[0] * c1[2] + c1[1] + c1[2];
	cn[2] = c1[1] * c1[1] - b * c1[2] * c1[2] - c1[2] + c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 3.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }
*/

/**************************************************************************
	Marcus-4 Chaotic Oscillator Images
***************************************************************************/

int	DoMarcus04(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] -	c1[0] * c1[2] - c1[1] * c1[2] + c1[0] - c1[1];
	cn[1] = a * c1[0] * c1[2] + c1[1] + c1[2];
	cn[2] = c1[1] * c1[1] - b * c1[2] * c1[2] - c1[2] + c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 3.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Marcus-5 Chaotic Oscillator 
	Marcus Rezende 07 March 2018
***************************************************************************/

int	DoMarcus05(void)

    {
    double	i, c1[3], cn[3], b;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z

    b = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - c1[0] - c1[2];
	cn[1] = c1[2] - c1[0] - c1[0] + c1[1];
	cn[2] = c1[0] * c1[0] * c1[0] - c1[0] - c1[1] - b * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 3.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Marcus-6 Chaotic Oscillator Images
***************************************************************************/

int	DoMarcus06(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] -	c1[0] * c1[2] - c1[1] * c1[2] + c1[0] - c1[1];
	cn[1] = a * c1[0] * c1[1] * c1[2] + c1[1] + c1[2];
	cn[2] = c1[1] * c1[1] - b * c1[2] * c1[2] - c1[2] + c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 3.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Marcus-8 Chaotic Oscillator Images
***************************************************************************/

int	DoMarcus08(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] -	c1[0] * c1[2] - c1[1] * c1[2] + c1[0] - c1[1];
	cn[1] = a * c1[0] * c1[2] + c1[1] - c1[2];
	cn[2] = c1[1] * c1[1] * c1[1] - b * c1[2] * c1[2] - c1[2] - c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 3.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Marcus-10/11 Chaotic Oscillator Images
***************************************************************************/

int	DoMarcus11(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];
    c1[1] = param[11];
    c1[2] = param[12];

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] -	c1[0] * c1[2] - c1[1] * c1[2];
	cn[1] = a * c1[0] * c1[2] + c1[1] + c1[2];
	cn[2] = c1[1] * c1[1] * c1[1] * c1[1] - b * c1[2] * c1[2] - c1[2] + c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
Marcus Bi Map
***************************************************************************/

int	DoMarcusBiMap(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];
    c1[1] = param[11];
    c1[2] = param[12];

    cn[0] = c1[0];
    totpasses = 10;

    InitOscillator(c1, 1);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 2 * cos(cn[0]) - 9 * fabs(c1[0]) / c1[0] + sin(c1[0]);
	//	cn[1] = a * c1[0] * c1[2] + c1[1] + c1[2];
	//	cn[2] = c1[1] * c1[1] * c1[1] * c1[1] - b * c1[2] * c1[2] - c1[2] + c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 1, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Martin III Images
	CHAOTIC FEATURE OF MARTIN PROCESS IMPOSED ON THE COSINE FUNCTION
	CHUANHOU GAO, ZHIMIN ZHOU, JIUSUN ZENG, JIMING CHEN
***************************************************************************/

int	DoMartin(void)

    {
    double	i, c1[3], cn[3], a, b, c;
    bool	isSin;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    isSin = (param[4] == 0.0);
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = sin(c1[1] - fabs(c1[0]) / c1[0] * sqrt(fabs(b * c1[0] - c)));
	cn[1] = (isSin ? sin(a - c1[0]) : cos(a - c1[0]));
	cn[2] = (sqr(0.01 * sin(c1[0])) + sqr(0.01 * cos(c1[1])));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	MASTER-SLAVE Synchronisation Images
	Designing Couplings for Synchronisation 
	Ioan Grosu and Servilia Oancea
***************************************************************************/

int	DoMasterSlave(void)

    {
    double	i, c1[6], cn[6];

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z
    c1[3] = param[13];    // q
    c1[4] = param[14];    // w
    c1[5] = param[15];    // r

    totpasses = 10;

    InitOscillator(c1, 6);							// pass in number of dimensions
    for (i = 0; i < iterations; i += dt)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = -0.6 * c1[2] - c1[1] + 0.58 * (c1[0] * c1[0] - 1.0);

	cn[3] = c1[4];
	cn[4] = c1[5];
	cn[5] = -0.5 * c1[5] - c1[4] + 0.58 * (c1[3] * c1[3] - 1.0) + (-0.5 - 1.16 * c1[0]) * (c1[3] - c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Matlab Code for Lyapunov Exponents of Fractional-Order Systems
	Marius-F. Danca and Nikolay Kuznetsov March 28, 2018
	https://www.researchgate.net/publication/324218837_Matlab_Code_for_Lyapunov_Exponents_of_Fractional-Order_Systems
***************************************************************************/

int	DoMatlabCodeForLyapunovExponents(void)

    {
    double	i, c1[3], cn[3], p;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z

    p = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] * (c1[2] - 1 + c1[0] * c1[0]) + 0.1 * c1[0];
	cn[1] = c1[0] * (3 * c1[2] + 1 - c1[0] * c1[0]) + 0.1 * c1[1];
	cn[2] = -2 * c1[2] * (p + c1[0] * c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Mechanics Analysis and Hardware Implementation of a New 3D Chaotic System
	Hongyan JiaZhiqiang Guo, Shanfeng Wang and Zengqiang Chen
	Sent to me by the third author and also found in 
	https://www.researchgate.net/publication/329601324_Mechanics_Analysis_and_Hardware_Implementation_of_a_New_3D_Chaotic_System
***************************************************************************/

int	DoMechanicsAnalysisHardwareImplementation(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, k, l, m, h;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    k = param[4];
    m = param[5];
    h = param[6];
    l = sqrt((m + h * h * b) / d);
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = h * b / l * c1[1] * c1[2] - a * c1[0];
	cn[1] = -l * d / h * c1[0] * c1[2] + c * c1[1];
	cn[2] = m / h / l * c1[0] * c1[1] - k * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Medical Image Encryption Algorithm based on Latin Square and Memristive Chaotic System
	Xiuli Chai, Jitong Zhang, Zhihua Gan and Yushu Zhang 17 October 2019
	Send directly by  Xiuli Chai through https://www.researchgate.net/publication/336623929_Medical_image_encryption_algorithm_based_on_Latin_square_and_memristive_chaotic_system
***************************************************************************/

int	DoMedicalImageEncryptionAlgorithm(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e, f24 = 0.0;			// another coding error in the source

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z
    c1[3] = param[13];    // w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] + b * c1[1] + c1[1] * c1[2];
	cn[1] = -c1[0] * c1[2] + c1[1] * c1[2] + c * f24;
	cn[2] = -c1[2] - d * c1[0] * c1[1] + e;
	cn[3] = c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Megastable System with 2-D Strip of Hidden Attractors and Analytical Solutions
	I. M. Burkin, O. I. Kuznetsova, 2021
	https://www.researchgate.net/profile/A-Belov-Kanel/publication/357340988_Dynamic_processes_in_the_economics_of_multilateral_network_platforms/links/61c99d85b6b5667157ab4bc1/Dynamic-processes-in-the-economics-of-multilateral-network-platforms.pdf#page=361
***************************************************************************/

int	DoMegastableSystemWith2DStrip(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = tan(c1[1]);
	cn[1] = -c1[0] - atan(fabs(50 * c1[2]) - 10) * tan(c1[1]);
	cn[2] = (pow(tan(c1[1]), 4) - a / (1 + pow(c1[0], 8))) * fabs(c1[2]) / c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Megastability: Coexistence of a Countable Infinity of Nested Attractors in a Periodically-Forced Oscillator with Spatially-Periodic Damping
	Julien C. Sprott1, Sajad Jafari, Abdul Jalil M. Khalaf and Tomasz Kapitaniak 21 June 2017
	http://sprott.physics.wisc.edu/pubs/paper482.pdf
***************************************************************************/

int	DoMegastabilityCoexistenceCountableInfinityM(bool Marcus)

    {
    double	i, c1[3], cn[3], real, imag;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z

    real = param[0];
    imag = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    if (Marcus)
	{
	for (i = 0; i < iterations; i++)
	    {
	    if (user_data(GlobalHwnd) == -1)					// user pressed a key?
		return -1;
	    curpass = (int)(i * totpasses / iterations);
	    cn[0] = c1[1] / cos(c1[1]);
	    cn[1] = -(0.333 * 0.333) * c1[0] + c1[1] * cos(c1[0]) - cos(0.723 * i * c1[1]);
	    cn[2] = imag * sin(c1[0]) + real * cos(c1[1]);
	    if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
		break;
	    }
	}
    else
	{
	for (i = 0; i < iterations; i += dt)
	    {
	    if (user_data(GlobalHwnd) == -1)					// user pressed a key?
		return -1;
	    curpass = (int)(i * totpasses / iterations);
	    cn[0] = c1[1];
	    cn[1] = -(0.333 * 0.333) * c1[0] + c1[1] * cos(c1[0]) + sin(0.73 * i);
	    cn[2] = imag * sin(c1[0]) + real * cos(c1[1]);
	    if (DisplayOscillator(c1, cn, dt, ((DWORD)((Marcus) ? i / 200.0 : i) % threshold), i, 3, 0) < 0)
		break;
	    }
	}
    PlotExtras();
    return 0;
    }

// Marcus did one of his fiddles on an existing oscillator

int	DoMegastabilityCoexistenceCountableInfinity1(void)
    {
    return DoMegastabilityCoexistenceCountableInfinityM(false);
    }

int	DoMegastabilityCoexistenceCountableInfinity2(void)
    {
    return (DoMegastabilityCoexistenceCountableInfinityM(true));
    }

/**************************************************************************
	Megastability, Multistability in a Periodically Forced Conservative and Dissipative System with Signum Nonlinearity
	Pankaj Prakash, K. Rajagopal, J. P. Singh and B. K. Roy May 4, 2018
	Received from the first author and available at 
	https://www.researchgate.net/publication/325988229_Megastability_Multistability_in_a_Periodically_Forced_Conservative_and_Dissipative_System_with_Signum_Nonlinearity
***************************************************************************/

int	DoMegastabilityMultistability(void)

    {
    double	i, c1[3], cn[3], real, imag, a, b, w;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z

    real = param[0];
    imag = param[1];
    a = param[2];
    b = param[3];
    w = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -a * sin(c1[1] - c1[0]) + fabs(c1[1]) * sin(fabs(c1[0])) + fabs(c1[1]) * sin(fabs(c1[0])) + b * sin(w * i);
	cn[2] = imag * sin(c1[0]) + real * cos(c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Megastability in a Quasi-Periodically Forced System Exhibiting Multistability, Quasi-Periodic Behaviour, and its Analogue Circuit Simulation
	Pankaj Prakasha, K. Rajagopal, J.P. Singh and B.K. Roya 18 May 2018 - received from the author
***************************************************************************/

int	DoMegastabilityQuasiPeriodicallyForcedSystem(void)

    {
    double	i, c1[3], cn[3], a, b, real, imag;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = 1.0;	// z

    a = param[0];
    b = param[1];
    real = param[2];
    imag = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[0] + c1[1] * cos(c1[0]) + sin(a * i) + sin(b * i);
	cn[2] = imag * sin(c1[0]) + real * cos(c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Meminductive Wein-bridge chaotic oscillator
	Xu Bi-Rong Wang Guang-Yi   & Marcus Rezende 2017
***************************************************************************/

int	DoMeminductiveWeinbridge(void)

    {
    double	i, c1[4], cn[4], k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    k = param[0];

    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i += dt)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = k * (1.55 * c1[1] - c1[0]);
	cn[1] = k * c1[2] - k * (0.25 * c1[0] - 0.05 * c1[0] * c1[1] * c1[1]);
	cn[2] = k * (c1[2] - c1[3]) - k * (0.25 * c1[0] - 0.05 * c1[0] * c1[1] * c1[1]) - 0.5 * k * c1[2];
	cn[3] = k * (c1[2] - c1[3]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Memristive Chaotic Circuits Images
	BASED ON CELLULAR NONLINEAR NETWORKS
	ARTURO BUSCARINO, LUIGI FORTUNA and MATTIA FRASCA LUCIA VALENTINA GAMBUZZA and GREGORIO SCIUTO
	Simin Yu, Jinhu Lu, Guanrong Chen 22 March 2007
***************************************************************************/

int	DoMemristive(void)

    {
    double	i, c1[4], cn[4], alpha, beta, gamma, d, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    alpha = param[0];
    beta = param[1];
    gamma = param[2];
    d = param[3];
    c = param[4];

    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = alpha * (c1[1] - (fabs(c1[0]) > 1 ? d : c) * c1[0]);
	cn[1] = c1[2] - c1[0];
	cn[2] = -beta * c1[1] + gamma * c1[2];
	cn[3] = c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Memristive Hyperchaotic System without Equilibrium
	Viet-Thanh Pham, Christos Volos,  and Lucia Valentina Gambuzza 2014 Jul 15
***************************************************************************/

int	DoMemristiveHyperchaotic(void)

    {
    double	i, c1[4], cn[4], a, b, y0;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];

    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -10.0 * c1[0] - a * c1[1] - c1[1] * c1[2];
	y0 = (1.0 + 0.24 * c1[3] * c1[3] - 0.0016 * pow(c1[3], 4)) * c1[1];
	cn[1] = -6.0 * c1[0] + 1.2 * c1[0] * c1[2] + 0.1 * y0 - b;
	cn[2] = -c1[2] - 1.2 * c1[0] * c1[1];
	cn[3] = c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Memristor-Based Canonical Chua’s Circuit: Extreme Multistability in Voltage-Current Domain and Its Controllability in Flux-Charge Domain
	Han Bao, Tao Jiang, Kaibin Chu, Mo Chen, Quan Xu, and Bocheng Bao 25 March 2018
	https://www.hindawi.com/journals/complexity/2018/5935637/
***************************************************************************/

int	DoMemristorBasedCanonicalChuasCircuit(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];

    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[1];
	cn[1] = b * (1 - d * c1[0] * c1[0]) * c1[1] + b * c1[3];
	cn[2] = c1[2] - c1[3];
	cn[3] = c * (c1[2] - c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Memristor-Based Chaotic System with Upper-Lower Chaotic Attractors and Abundant Dynamical Behaviors
	Dengwei Yan, Musha Ji, Lidan Wang, Shukai Duan 2023
	https://www.researchgate.net/publication/350159547......DOI: 10.21203/rs.3.rs-314264/v1
***************************************************************************/

int	DoMemristorBasedChaoticSystem(void)

{
    double	i, c1[4], cn[4], a, b, c, d, g, k, r, ax2, fx2, roff, ron, m0, m2, uv, c3, c4, c5, c6;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    g = param[4];
    r = param[5];
    roff = param[6];
    ron = param[7];
    m0 = param[8];
    uv = param[9];


    k = (ron - roff - uv * ron) / (d * d);
    m2 = m0 * m0;
    c3 = (roff - m2) / 2 / k;
    c4 = (ron - m2) / 2 / k;
    c5 = (roff * roff - m2) / 2 / k;
    c6 = (ron * ron - m2) / 2 / k;

    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
    {
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	ax2 = -fabs(c1[1]);
	if (ax2 < c5) 
	    fx2 = (c1[1] - c3) / roff;
	else if (c5 < ax2 && c5 < c6) 
	    fx2 = (sqrt(2 * k * c1[1] + m2) - m0) / k;
	else if (ax2 >= c5) 
	    fx2 = (c1[1] - c4) / ron;

	cn[0] = -a * c1[0] + b * c1[1] * c1[2];
	cn[1] = c1[1] + c1[0] * c1[2] - c * cube(c1[1]) + c1[3];
	cn[2] = d * c1[2] - c1[0] * c1[1];
	cn[3] = -g * c1[3] + r * fx2;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 4, 0) < 0)
	    break;
    }
    PlotExtras();
    return 0;
}

/**************************************************************************
	Memristor Oscillator Based on a Twin-T Network
	Li Zhi-Jun and Zeng Yi-Cheng 21 September 2012
	https://www.google.com.br/search?ei=08n6WqXgJoGTwgS7voeYCA&q=A+memristor+oscillator+based+on+a+twin-T+network.pdf
***************************************************************************/

int	DoMemristorOscillatorBasedOnTwinTNetwork(void)

    {
    double	i, c1[5], cn[5], alpha, k, r, a, b, omega;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w
    c1[4] = param[14];	// u

    alpha = param[0];
    k = param[1];
    r = param[2];
    a = param[3];
    b = param[4];

    totpasses = 10;

    InitOscillator(c1, 5);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	omega = (fabs(c1[4]) < 1.0) ? b : a;
	cn[0] = 3.0 * (k - 1.0) * c1[0] + (3.0 * k - 1.0) * c1[1] + c1[2];
	cn[1] = (k - 1.0) * (c1[0] + c1[1]) + c1[2];
	cn[2] = ((2.0 * k - 1.0 + r * k) * (c1[0] + c1[1]) + (2.0 + r) * c1[2] - r * c1[3]) / -2.0;
	cn[3] = alpha * (r * (k * (c1[0] + c1[1]) + c1[2] - c1[3]) - omega * c1[3]);
	cn[4] = c1[3];
//	c1[4] += cn[4] * dt;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	MEMS Resonator Images
	Nonlinear state estimation and control for chaos suppression in MEMS resonator
	Angelo Marcelo Tusseta, Atila Madureira Buenoa, Claudinor Bitencourt Nascimentoa,
	Mauricio dos Santos Kastera and Jose Manoel Balthazar 29 January 2013
***************************************************************************/

int	DoMEMSResonator(void)

    {
    double	i, c1[3], cn[3], alpha, sigma, gamma, w, mu;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alpha = param[0];
    gamma = param[1];
    sigma = param[2];
    w = param[3];
    mu = param[4];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -mu * c1[1] - c1[0] - alpha * c1[0] * c1[0] * c1[0] + gamma * (1.0 / sqr(1.0 - c1[0]) 
					- 1.0 / sqr(1.0 + c1[0])) + sigma / sqr(1.0 - c1[0]) + sin(w * i);
	cn[2] = c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Method for Improving the Imbedded Runge Kutta
	Sunyoung Bu, Wonkyu Chung, Philsu KimFehlberg 4(5) 2014
***************************************************************************/

int	DoImprovingRungeKutta(void)

    {
    double	i, c1[3], cn[3], i1, i2, i3, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    i1 = param[0];
    i2 = param[1];
    i3 = param[2];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	f = (i < 3 * PI && i > 4 * PI) ? 0.0 : 0.25 * sin(i) * sin(i);
	cn[0] = (i2 - i3) * c1[2] * c1[1] / i1;
	cn[1] = (i3 - i1) * c1[2] * c1[0] / i2;
	cn[2] = ((i1 - i2) * c1[0] * c1[1] + f) / i3;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Minimal Heteroclinic System Images
	A minimal system with a depth-two heteroclinic network
	Tsuyoshi Chawanyaa and Peter Ashwin 20 June 2010
***************************************************************************/

int	DoMinimalHeteroclinic(void)

    {
    double	i, c1[3], cn[3], a, b, w;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    w = param[2];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = (1.0 - c1[0] * c1[0]) * ((1.0 - c1[2]) * (c1[0] - w * c1[1] * c1[1] * c1[1]) + (1.0 + c1[2]) * 
					(-c1[0] - c1[0] * c1[0] * c1[0] + (2.0 + 2.0 * b) * c1[0] * c1[1] * c1[1]));
	cn[1] = (1.0 - c1[1] * c1[1]) * ((1.0 - c1[2]) * (-c1[1] + 2.0 * c1[0] * c1[0] * c1[1] + w * c1[0] * c1[0] * c1[0]) + (1.0 + c1[2]) * (-2.0 * c1[1]));
	cn[2] = (1.0 - c1[2] * c1[2]) * (1.0 + a * (1.0 + c1[2]) - 2.0 * (1.0 - c1[0] * c1[0]) * (1.0 - c1[1] * c1[1]));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Minimal System with a Depth-Two Heteroclinic Network-Changed
	Tsuyoshi Chawanya and Peter Ashwin & Marcus Rezende 29/01/2015
***************************************************************************/

int	DoMinimalHeteroclinicChanged(void)

    {
    double	i, c1[3], cn[3], l, r, s;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    l = param[0];
    r = param[1];
    s = param[2];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 3.0 * c1[0] * c1[0] - c1[0] * c1[0] * c1[0] - c1[1] - l + c1[2];
	cn[1] = 5.0 * c1[0] * c1[0] - l - c1[1];
	cn[2] = r * (s - (c1[0] - cn[0]) - c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Miranda-Stone 3 Multi-scroll Chaotic Oscillator Images
***************************************************************************/

int	DoMirandaStone(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 1.0/3.0 * (-(a + 1.0) * c1[0] + (a - c + c1[2]) * c1[1]) + 1.0/3.0 / sqrt(c1[0] * c1[0] + c1[1] * c1[1]) * ((1.0 - a)
											* (c1[0] * c1[0] - c1[1] * c1[1]) + 2.0 * (a + c - c1[2]) * c1[0] * c1[1]);
	cn[1] = 1.0/3.0 * ((c - a - c1[2]) * c1[0] - (a + 1) * c1[1]) + 1.0/3.0 / sqrt(c1[0] * c1[0] + c1[1] * c1[1]) * (2.0 * (a - 1.0)
											* c1[0] * c1[1] + (a + c - c1[2]) * (c1[0] * c1[0] - c1[1] * c1[1]));
	cn[2] = 1.0/2.0 * (3.0 * c1[0] * c1[0] * c1[1] - c1[1] * c1[1] * c1[1]) - b * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Miranda-Stone 4 Multi-scroll Chaotic Oscillator Images
	Proto-Lorenz-II
	The proto-Lorenz system
	Rick Miranda, Emily Stone 1993
***************************************************************************/

int	DoMirandaStone4(void)

    {
    double	i, c1[3], cn[3], r, sigma, b;

    c1[0] = param[10];    // s
    c1[1] = param[11];    // t
    c1[2] = param[12];    // z

    r = param[0];
    sigma = param[1];
    b = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = (-sigma * c1[0] * c1[0] * c1[0] + (2.0 * sigma + r - c1[2]) * c1[0] * c1[0] * c1[1] 
		+ (sigma - 2.0) * c1[0] * c1[1] * c1[1] - (r - c1[2]) * c1[1] * c1[1] * c1[1]) / 2.0 / (c1[0] * c1[0] + c1[1] * c1[1]);
	cn[1] = ((r - c1[2]) * c1[0] * c1[0] * c1[0] + (sigma - 2) * c1[0] * c1[0] * c1[1] 
		+ (-2.0 * sigma - r + c1[2]) * c1[0] * c1[1] * c1[1] - sigma * c1[1] * c1[1] * c1[1]) / 2 / (c1[0] * c1[0] + c1[1] * c1[1]);
	cn[2] = 2.0 * c1[0] * c1[0] * c1[0] * c1[1] - 2.0 * c1[0] * c1[1] * c1[1] * c1[1] - b * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Model Reference Control of Hyperchaotic Systems
	Pengfei Zhao, Cai Liu and Xuan Feng 35 November 2012
***************************************************************************/

int	DoModelReferenceControl(void)

    {
    double	i, c1[4], cn[4];

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z
    c1[3] = param[13];    // w

    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[1] - c1[2];
	cn[1] = c1[0] + c1[1] / 4.0 + c1[3];
	cn[2] = 20.0 * c1[0] + 10.0 * c1[1] - 50.0 * c1[2] + 100.0 * c1[3] + 3.0;
	cn[3] = -c1[2] * 0.0025 * c1[3];					// changed the sign of addition to multiplication and changed 2D spirals to 3D !!!
										// the original equation in the paper was:   wn = -z / 2 + .05 * w
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Modelling and Circuit Realisation of a New No-Equilibrium Chaotic System with Hidden Attractor and Coexisting Attractors
	Qiang Lai, Zhiqiang Wan and Paul Didier Kamdem Kuate July 2020
	Sent to ManpWIN by Paul Didier Kamdem Kuate through https://www.researchgate.net/requests/r84699874
***************************************************************************/

int	DoModellingCircuitRealisation(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, k;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z
    c1[3] = param[13];    // w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    k = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[3];
	cn[1] = b * c1[1] - c1[0] * c1[2] + k;
	cn[2] = -c * c1[2] + c1[0] * c1[1];
	cn[3] = d * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Modelling Chaos-Hyperchaos Transition In Coupled Rossler Systems
	S. Yanchuk and T. Kapitaniak April 8{11, 2001
***************************************************************************/

int	DoModellingChaosHyperchaosTransition(void)

    {
    double	i, c1[6], cn[6], a, b, c, d;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z
    c1[3] = param[13];    // u
    c1[4] = param[14];    // v
    c1[5] = param[15];    // w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 6);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[1] - c1[2];
	cn[1] = c1[0] + a * c1[1];
	cn[2] = b + c1[2] * (c1[0] - c) + d * (c1[5] - c1[2]);
	cn[3] = -c1[4] - c1[5];
	cn[4] = c1[3] + a * c1[4];
	cn[5] = b + c1[5] * (c1[3] - c) + d * (c1[5] - c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
    Modelling of Chaotic Processes with Caputo Fractional Order Derivative
    Kolade M. Owolabi, Jose Francisco Gomez-Aguilar, G. Fernández-Anaya, J. E. Lavin-Delgado and E. Hernandez-Castillo 14 September 2020
    Sent to ManpWIN by Jose Francisco Gomez-Aguilar through https://www.mdpi.com/1099-4300/22/9/1027/htm
***************************************************************************/

int	DoModellingChaoticProcessesCaputoFractionalOrderDerivative(void)

    {
    double	i, c1[3], cn[3], b1, b2, b3, b4, b5, b6, b7, b8, b9;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z

    b1 = param[0];
    b2 = param[1];
    b3 = param[2];
    b4 = param[3];
    b5 = param[4];
    b6 = param[5];
    b7 = param[6];
    b8 = param[7];
    b9 = param[8];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = b1 * c1[1] - b2 * c1[0] + b3 * c1[0] * c1[2];
	cn[1] = -b4 * c1[0] * c1[2] - b5 * c1[0] + b6 * c1[1] * c1[2];
	cn[2] = b8 - b9 * c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
    Modelling of a Chaotic System Motion in Video with Artificial Neural Networks
    Kolade M. Owolabi, Jose Francisco Gomez-Aguilar, G. Fernández-Anaya, J. E. Lavin-Delgado and E. Hernandez-Castillo 14 September 2020
    Sent to ManpWIN by Jose Francisco Gomez-Aguilar through https://www.mdpi.com/1099-4300/22/9/1027/htm
***************************************************************************/

int	DoModellingChaoticSystemMotionInVideo(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] - c1[1] * c1[2];
	cn[1] = -b * c1[1] + c1[0] * c1[2];
	cn[2] = c - c1[2] + c1[0] * c1[1] + d * c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Modern Firm: A Strange Chaotic Oscillator
	SAFIEDINE BOUALI 2011
***************************************************************************/

int	DoModernFirm(void)

    {
    double	i, c1[3], cn[3], v, m, n, rz, s;

    c1[0] = param[10];    // p
    c1[1] = param[11];    // r
    c1[2] = param[12];    // f

    v = param[0];
    m = param[1];
    n = param[2];
    rz = param[3];
    s = param[4];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = (c1[1] + c1[2]) / v;
	cn[1] = m * c1[0] + n * (1.0 - c1[0] * c1[0]) * c1[1]; 
	cn[2] = -rz * c1[0] - s * c1[1]; 
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Modern Firm: A Strange Chaotic Oscillator - Plus Catastrophe Equations
	SAFIEDINE BOUALI 2011
***************************************************************************/

int	DoModernFirmPlusCatastrophe(void)

    {
    double	i, temp[3], c1[3], cn[3], a, b, c, d, v, m, n, rz, s, xnew, ynew, znew, dx = 1.0;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    v = param[0];
    m = param[1];
    n = param[2];
    rz = param[3];
    s = param[4];
    a = param[5];
    b = param[6];
    c = param[7];
    d = param[8];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	// Oscillator
	xnew = (c1[1] + c1[2]) / v;
	ynew = m * c1[0] + n * (1.0 - c1[0] * c1[0]) * c1[1];
	znew = -rz * c1[0] - s * c1[1];
	c1[0] += xnew*dt; c1[1] += ynew*dt; c1[2] += znew*dt;
	// catastrophe equations
	cn[0] = 3.0 * c1[0] * c1[0] + a + c * c1[1];
	cn[1] = 3.0 * c1[1] * c1[1] + b + c * c1[0];
	cn[2] = 3.0 * c1[2] * c1[2] + d + c * (sqrt(fabs(c1[0] + c1[1])) + (c1[0] + c1[1]) / 2.0) / 2.0;
	// multiply Catastrophe with the oscillator to form Catastrophic Chaotic Attractor
	temp[0] = c1[0]; 
	temp[1] = c1[1]; 
	temp[2] = c1[2];
	if (DisplayOscillator(temp, cn, dx, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Modified Chaotic Chua Oscillator Images
	A Secure Communication System Based on a Modified Chaotic Chua Oscillator
	Mauricio Zapateiro De la Hoz, Leonardo Acho, and Yolanda Vidal 7-10 June 2014
***************************************************************************/

int	DoModifiedChua(void)

    {
    double	i, c1[3], cn[3], a, b, e, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    e = exp(1.0);
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	f = -sin(c1[0]) * pow(e, (-0.1 * fabs(c1[0])));
	cn[0] = a * (c1[1] - f);
	cn[1] = c1[0] - c1[1] + c1[2];
	cn[2] = -b * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Modified Hyperchaotic Yu Systems
	ACTIVE CONTROLLER DESIGN FOR THE HYBRID Synchronisation OF HYPERCHAOTIC ZHENG AND HYPERCHAOTIC YU SYSTEMS
	SUNDARAPANDIAN VAIDYANATHAN  & MARCUS REZENDE 2 APRIL 2013 / 30/04/2015
***************************************************************************/

int	DoModifiedHyperchaoticYu(void)

    {
    double	i, c1[4], cn[4], alpha, beta, gamma, delta, epsilon, e = exp(1.0);

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    alpha = param[0];
    beta = param[1];
    gamma = param[2];
    delta = param[3];
    epsilon = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = alpha * (c1[1] - c1[0]);
	cn[1] = beta * c1[0] - c1[0] * c1[2] + gamma * c1[1] + c1[3];
	cn[2] = -delta * c1[2] + pow(e,(c1[0] * c1[1] / c1[2]));		// DIVIDED BY 'Z' THE EXPONENTIAL
	cn[3] = -epsilon * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Modified Liu System with Fractional Order
	Alireza K. Golmankhaneh, Roohiyeh Arefi, and Dumitru Baleanu & Marcus Rezende 15 March 2013
***************************************************************************/

int	DoModifiedLiu(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e, f, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[0] - b * c1[1] * c1[1];
	cn[1] = c * c1[1] + d * c1[2] * c1[0] - e * c1[2] * c1[2];
	cn[2] = f * c1[2] + g * c1[0] * c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Modified Projective Synchronization of New Hyper-chaotic Systems
	Ayub Khan, Ram Pravesh Prasad September 03, 2013
***************************************************************************/

int	DoModifiedProjective(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, h;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    h = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[3];
	cn[1] = b * c1[0] + c * c1[1] - c1[0] * c1[2];
	cn[2] = c1[0] * c1[0] - h * c1[2] + c1[0] * c1[1];
	cn[3] = -d * c1[0] + c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Modified Tigan System
	Output Regulation of the Tigan System
	Dr. V. Sundarapandian  & Marcus Rezende 5 May 2011 / 02 April 2015
***************************************************************************/

int	DoModifiedTigan(void)

    {
    double	i, c1[3], cn[3], a, b, c, p;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    p = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) / c1[2];
	cn[1] = (c - a) * c1[0] - a * c1[0] * c1[2] + p * c1[2] / (c1[0] - c1[1]);
	cn[2] = -b * c1[2] + c1[0] * c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Modified Tinkerbell
***************************************************************************/

int	DoModifiedTinkerbell(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    cn[0] = cn[1] = 0.0;

    c1[0] = param[10];
    c1[1] = param[11];
    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	double oldx = c1[0];
	double oldy = c1[1];

	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	c1[0] = (c1[0] * c1[0]) - (cn[1] * cn[1]) + a * c1[0] + b * cn[1];
	c1[1] = 2.0 * cn[0] * c1[1] + c * cn[0] + d * c1[1];
	c1[2] = sqrt(sqr(sin(a*oldx)) + sqr(cos(c*oldy)));
	cn[0] = c1[0] - 0.015 * c1[0];					// subtraction eliminates spurious dots
	cn[1] = c1[1] - 0.015 * c1[1];
	cn[2] = c1[2] - 0.015 * c1[2];

	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Moore-Spiegel Chaotic Oscillator Images
***************************************************************************/

int	DoMooreSpiegel(void)

    {
    double	i, c1[3], cn[3], t, r;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    t = param[0];
    r = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = -c1[2] - (t - r + r * sqr(c1[0])) * c1[1] - t * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Morse Oscillator Images
	Controlling Chaos in Damped and Driven Morse Oscillator via Slave-Master Feedback
	S. Behniaa, A. Akhshanib, M. Panahib amd R. Asadi May 17, 2012)
***************************************************************************/

int	DoMorseOscillator(void)

    {
    double	i, c1[3], cn[3], beta, gamma, a, f, w, e = exp(1.0);

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    beta = param[0];
    gamma = param[1];
    a = param[2];
    f = param[3];
    w = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -beta * pow(e, -a * c1[0]) * (1.0 - pow(e, -a * c1[0])) - gamma * c1[1] + f * cos(w * i);
	cn[2] = (4.0 * gamma - gamma * pow(1.0 - gamma, 2)) / 0.1 / pow(1.0 - gamma, 2);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Motion of charged particles in magnetic fields Images
	Created by symmetric configurations of wires 
	Jacobo Aguirre, Alejandro Luque, Daniel Peralta-Salas 30th September 2009
***************************************************************************/

int	DoMotionMagField(void)

    {
    double	i, c1[3], cn1[3], ro, fi, z, ron, fin, zn, a, b, c, an, bn, cn;

    ro = param[0];
    fi = param[1];
    z = param[2];
    a = param[3];
    b = param[4];
    c = param[5];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	ron = a;
	fin = b;
	zn = c;
	an = ro * b * b - c / ro;
	bn = 1 / ro / ro * (-2 * ro * a * b);
	cn = a / ro;
	ro += ron * dt;
	fi += fin * dt;
	z += zn * dt;
	a += an * dt;
	b += bn * dt;
	c += cn * dt;

	c1[0] = ro * cos(fi);
	c1[1] = ro * sin(fi);
	c1[2] = z;
	cn1[0] = c1[0];
	cn1[1] = c1[1];
	cn1[2] = c1[2];
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)(i / 36.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multifolded Torus Images
	Multifolded torus chaotic attractors: design and implementation
	Simin Yu, Jinhu Lu, Guanrong Chen 22 March 2007
***************************************************************************/

int	DoMultifoldedTorus(void)

    {
    double	i, c1[3], cn1[3], alfa, beta, m0, m1, x1, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alfa = param[0];
    beta = param[1];
    m0 = param[2];
    m1 = param[3];
    x1 = param[4];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	g = m1 * (c1[1] - c1[0]) + (m0 - m1) / 2 * (fabs(c1[1] - c1[0] + x1) - fabs(c1[1] - c1[0] - x1));
	cn1[0] = -alfa * g;
	cn1[1] = -g - c1[2];
	cn1[2] = beta * c1[1];
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)(i / 36.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multi-Lorenz Images
	Grid multi-wing butterfly chaotic attractors generated from a new 
	3-D quadratic autonomous system
	Xiaowen Luo, Chunhua Wang, Zhao Wan February 2014
***************************************************************************/

int	DoMultiLorenz(void)

    {
    double	i, c1[3], cn1[3], aa1, aa2, aa3, aa4, a1, a2, a3, a4, v1, v2, v3, v4, a, b, c, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];

    aa1 = 1.1;
    aa2 = 2.1;
    aa3 = 3.1;
    aa4 = 4.1;
    a1 = 1.3;
    a2 = 2.3;
    a3 = 3.3;
    a4 = 4.3;

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn1[0] = a * (c1[1] - c1[0]);
	cn1[1] = b * c1[1] - c1[2] * c1[0];
	v1 = aa1 * (fabs(c1[1] + a1) / (c1[1] + a1) - fabs(c1[1] - a1) / (c1[1] - a1) - 2.0);
	v2 = aa2 * (fabs(c1[1] + a2) / (c1[1] + a2) - fabs(c1[1] - a2) / (c1[1] - a2) - 2.0);
	v3 = aa3 * (fabs(c1[1] + a3) / (c1[1] + a3) - fabs(c1[1] - a3) / (c1[1] - a3) - 2.0);
	v4 = aa4 * (fabs(c1[1] + a4) / (c1[1] + a4) - fabs(c1[1] - a4) / (c1[1] - a4) - 2.0);
	f = c1[1] * c1[1] + v1 + v2 + v3 + v4;
	cn1[2] = f - c;
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)(i / 1.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multimedia Security Application of a Ten-Term Chaotic System without Equilibrium
	Xiong Wang, Akif Akgu, Sezgin Kacar and Viet-Thanh Pham 15 November 2017
***************************************************************************/

int	DoMultimediaSecurityApplication(void)

    {
    double	i, c1[3], cn1[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn1[0] = a * c1[1];
	cn1[1] = -c1[0] + b * c1[1] + c * c1[2] + c1[0] * c1[2];
	cn1[2] = c1[0] - c1[2] - c1[0] * c1[1] + d * c1[0] * c1[2] + 1.0;
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)(i / 1.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multiple Attractors in a Non-Ideal Active Voltage-Controlled Memristor Based Chua's Circuit
	Quan Xu, Yi Lin, Bocheng Bao and Mo Chen 7 December 2015
	https://www.researchgate.net/profile/Xu_Quan3/publication/288931916_Multiple_attractors_in_a_non-ideal_active_voltage-controlled_memristor_based_Chua%27s_circuit/links/59f91025aca272607e2f682e/Multiple-attractors-in-a-non-ideal-active-voltage-controlled-memristor-based-Chuas-circuit.pdf
***************************************************************************/

int	DoMultipleAttractorsChua(void)

    {
    double	i, c1[4], cn[4], alpha, beta, gamma, epsilon, a, b, w0;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[12];	// z

    alpha = param[0];
    beta = param[1];
    gamma = param[2];
    epsilon = param[3];
    a = param[4];
    b = param[5];

    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	w0 = a - b * c1[3] * c1[3];
	cn[0] = alpha * (c1[1] - c1[0] + c1[0] * w0);
	cn[1] = c1[0] - c1[1] - c1[2];
	cn[2] = beta * c1[1];
	cn[3] = -gamma * c1[0] - epsilon * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 1.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multipulse Chaotic Dynamics for Nonautonomous Nonlinear Systems and Application to a FGM Plate
	Xiaowen Luo, Chunhua Wang, Zhao Wan February 2014
***************************************************************************/

int	DoMultipulseChaoticDynamics(void)

    {
    double	i, c1[4], cn[4], a1, a2, a3, a4, a5, a6, a7, b1, b2, b3, b4, b5, b6, b7;
    double	f1, f2, omega1, omega2, w1, w2;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    w1 = 0.6943; w2 = 0.4123;
    b4 = 0.5254; b5 = 0.4277; b6 = 0.8201; b7 = -0.1229; f1 = 16.0; f2 = 15.0; omega1 = 1.0; omega2 = 1.0;

    a1 = param[0];
    a2 = param[1];
    a3 = param[2];
    a4 = param[3];
    a5 = param[4];
    a6 = param[5];
    a7 = param[6];
    b1 = param[7];
    b2 = param[8];
    b3 = param[9];

    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -w1 * w1 * c1[0] - a1 * c1[1] - a3 * c1[0] * c1[0] - a4 * c1[2] * c1[2] 
		    - a5 * c1[0] * c1[2] * c1[2] - a6 * c1[0] * c1[0] * c1[0] - a7 * c1[0] * c1[2] * c1[2] 
		    - a2 * c1[0] * cos(omega2 * i) + f1 * cos(omega1 * i);
	cn[2] = c1[3];
	cn[3] = -w2 * w2 * c1[2] - b1 * c1[3] - b3 * c1[0] * c1[2] - b4 * c1[2] * c1[2] 
		    - b5 * c1[2] * c1[2] * c1[2] - b6 * c1[0] * c1[0] * c1[2] - b7 * c1[2] * c1[2] * c1[2] 
		    - b2 * c1[2] * cos(omega2 * i) + f2 * cos(omega1 * i);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 0.3) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Multi-Number Communication System Based on Hyperchaotic System of 6th-Order Cellular Neural Network
	Wang Xingyuan, Xu Bing, Zhang Huaguang 8 April 2009
***************************************************************************/

int	DoMultiNumberCommunication(void)

    {
    double	i, c1[6], cn1[6], a, b, c, d, e, f, g, p14;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];

    totpasses = 10;

    InitOscillator(c1, 6);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn1[0] = -c1[2] - c1[3];
	cn1[1] = 2.0 * c1[1] + c1[2];
	cn1[2] = 14.0 * c1[0] - 14.0 * c1[1];
	p14 = 0.5 * (fabs(c1[3] + 1.0) - fabs(c1[3] - 1.0));
	cn1[3] = 100.0 * c1[0] - 100.0 * c1[3] + 200.0 * p14;					// I supressed part of the equation of 'un' for lacking data
	cn1[4] = 18.0 * c1[1] + c1[0] - c1[4];
	cn1[5] = 4.0 * c1[4] - 4.0 * c1[5] + 100.0 * c1[1];
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)(i / 1.0) % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multiple Attractors and Generalized Synchronization in Delayed Mackey-Glass Systems
	Li Dong and Zheng Zhi-Gang 2 July 2008
***************************************************************************/

int	DoMultipleAttractorsDelayedMackeyGlassSystems(void)

    {
    double	i, c1[3], cn1[3], a, b, c;		// dimension 3 to allow for co-ordinate system change


    c1[0] = cn1[0] = param[10];	// x
    a = param[0];
    b = param[1];
    c = param[2];

    totpasses = 10;

    InitOscillator(c1, 1);							// pass in number of dimensions
    for (i = 0; i < iterations; i += dt)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn1[0] = a * cn1[0] / (1.0 + pow(cn1[0], b)) - c * c1[0];
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)(i / 1.0) % threshold), i, 1, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multiple Delay Rossler System - Bifurcation and Chaos Control
	Dibakar Ghosh, A. Roy Chowdhury and Papri Saha 22 May 2006
***************************************************************************/

int	DoMultipleDelayRosslerSystem(void)

    {
    double	i, c1[3], cn1[3], alpha1, alpha2, beta1, beta2, gamma, x0;		// dimension 3 to allow for co-ordinate system change

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alpha1 = param[0];
    alpha2 = param[1];
    beta1 = param[2];
    beta2 = param[3];
    gamma = param[4];

    x0 = cn1[0] = c1[0];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn1[0] = -c1[1] - c1[2] - alpha1 * cn1[0] - alpha2 * x0;
	cn1[1] = c1[0] + beta1 * c1[1];
	cn1[2] = beta2 + c1[2] * (c1[0] - gamma);
	x0 = cn1[0];
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)(i / 30.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multi-Scroll Chaotic Attractors in SC-CNN via Hyperbolic Tangent Function
	Enis Gunay and Kenan Altun 9 May 2018
	http://www.mdpi.com/2079-9292/7/5/67 and received from the authors.
***************************************************************************/

int	DoMultiScrollChaoticAttractors(void)

    {
    double	i, c1[3], cn1[3], s22, n, i3;
    
    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    s22 = param[0];
    n = param[1];
    i3 = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn1[0] = c1[1] + c1[2];
	cn1[1] = -c1[0] - c1[1] + s22 * c1[1];
	cn1[2] = -c1[2] - tanh(n * c1[1]) + i3 - tanh(n * c1[1]) - i3;
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)(i / 30.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multi-Scroll Chaotic Oscillator from the Chen System Images
	Grid multi-wing butterfly chaotic attractors generated from a new 
	3-D quadratic autonomous system
	Xiaowen Luo, Chunhua Wang, Zhao Wan February 2014
***************************************************************************/

int	DoMultiScrollChen(void)

    {
    double	i, c1[3], cn1[3], a, b, c, d1, d2, u;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d1 = param[3];
    d2 = param[4];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn1[0] = a * (c1[1] - c1[0]);
	u = d1 * c1[2] - d2 * sin(c1[2]);
	cn1[1] = (c - a) * c1[0] - c1[0] * u + c * c1[1];
	cn1[2] = c1[0] * c1[1] - b * c1[2];
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)(i / 1.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multistability Analysis, Coexisting Multiple Attractors, and FPGA Implementation of Yu–Wang Four-Wing Chaotic System
	Fei Yu, Li Liu, Hui Shen, Zinan Zhang, Yuanyuan Huang, Shuo Cai, Zelin Deng and Qiuzhen Wan 29 Aug 2020
	https://www.hindawi.com/journals/mpe/2020/7530976/#conclusion
***************************************************************************/

int	DoMultistabilityAnalysis(void)

    {
    double	i, c1[4], cn1[4], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn1[0] = -a * c1[0] + c1[1] * c1[2] + b * c1[3];
	cn1[1] = c * c1[1] - c1[0] * c1[2];
	cn1[2] = c1[0] * c1[1] - d * c1[2];
	cn1[3] = c1[0] * c1[2] - e * c1[3];
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)(i / 1.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multistability and Coexisting Attractors in a New Circulant Chaotic System
	Karthikeyan Rajagopal, Akif Akgul, Viet-Thanh Pham, Fawaz E. Alsaadi, Fuad E. Alsaadi and Sajad Jafari May 19, 2019
	Sent directly by Akif Akgul through https://www.researchgate.net/requests/r66676361
***************************************************************************/

int	DoMultistabilityCoexistingAttractors(void)

    {
    double	i, c1[4], cn1[4], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn1[0] = a * c1[0] + b * c1[1] - c1[1] * c1[1] * c1[1];
	cn1[1] = a * c1[1] + b * c1[2] - c1[2] * c1[2] * c1[2];
	cn1[2] = a * c1[2] + b * c1[3] - c1[3] * c1[3] * c1[3];
	cn1[3] = a * c1[3] + b * c1[0] - c1[0] * c1[0] * c1[0];
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)(i / 1.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multi-Switching Combination Synchronisation of Chaotic Systems
	U. E. Vincent, A. .O. Saseyi and P. V. E. McClintock March 26, 2015
	https://core.ac.uk/download/pdf/42414490.pdf
***************************************************************************/

int	DoMultiSwitchingCombinationSynchronisation(void)

    {
    double	i, c1[3], cn1[3], a2, b2;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a2 = param[0];
    b2 = param[1];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn1[0] = -a2 * c1[0] + c1[1] + 10 * c1[1] * c1[2];
	cn1[1] = -c1[0] - 0.4 * c1[1] + 5 * c1[0] * c1[2];
	cn1[2] = b2 * c1[2] - 5 * c1[0] * c1[1];
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multiscroll in coupled Lorenz oscillators Images
	6D - COUPLED LORENZ
	S.K.Dana, B.K. Singh, S.Chakraborty, J.Kurths, G.Osipov,
	R.C.Yadav, P.K.Roy, C. K.Hu > 2006
***************************************************************************/

int	DoMultiscrollLorenz(void)

    {
    double	i, c1[6], cn1[6], b, s, r1, r2, e;

    c1[0] = param[10];	// x1
    c1[1] = param[11];	// y1
    c1[2] = param[12];	// z1
    c1[3] = param[13];	// x2
    c1[4] = param[14];	// y2
    c1[5] = param[15];	// z2

    b = param[0];
    s = param[1];
    r1 = param[2];
    r2 = param[3];
    e = param[4];

    totpasses = 10;

    InitOscillator(c1, 6);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn1[0] = s * (c1[1] - c1[0]);
	cn1[1] = r1 * c1[0] - c1[1] - c1[0] * c1[2];
	cn1[2] = -b * c1[2] + c1[0] * c1[1];
	cn1[3] = s * (c1[4] - c1[3]) + e * (c1[0] - c1[3]);
	cn1[4] = r2 * c1[3] - c1[4] - c1[3] * c1[5];
	cn1[5] = -b * c1[5] + c1[3] * c1[4];
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)i % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multistability and Bifurcations in a 5D Segmented Disc Dynamo with a Curve of Equilibria
	Jianghong Bao and Yongjian Liu 14 August 2019
	https://advancesindifferenceequations.springeropen.com/articles/10.1186/s13662-019-2284-0
***************************************************************************/

int	DoMultistabilityBifurcations5D(void)

    {
    double	i, c1[5], cn1[5], m, r, g, k1, k2, k3, k4, k5, k6;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v

    m = param[0];
    r = param[1];
    g = param[2];
    k1 = param[3];
    k2 = param[4];
    k3 = param[5];
    k4 = param[6];
    k5 = param[7];
    k6 = param[8];

    totpasses = 10;

    InitOscillator(c1, 5);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn1[0] = r * (c1[1] - c1[0]);
	cn1[1] = c1[0] * c1[2] - (1 + m) * c1[1] + c1[4];
	cn1[2] = g * (m * c1[0] * c1[0] + 1 - (1 + m) * c1[0] * c1[1]) - k1 * c1[3] + k6 * c1[2];
	cn1[3] = k2 * c1[1] * c1[1] - k3 * c1[2];
	cn1[4] = k4 * c1[0] - c1[0] * c1[2] + k5 * c1[4];
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)i % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multistability Analysis, Coexisting Multiple Attractors, and FPGA Implementation of Yu–Wang Four-Wing Chaotic System
	Fei Yu, Li Liu, Hui Shen, Zinan Zhang, Yuanyuan Huang, Shuo Cai, Zelin Deng and Qiuzhen Wan
	Sent to ManoWIN by Shuo Cai through https://www.researchgate.net/publication/343972893_Multistability_Analysis_Coexisting_Multiple_Attractors_and_FPGA_Implementation_of_Yu-Wang_Four-Wing_Chaotic_System
	29 August 2020
***************************************************************************/

int	DoMultistabilityAnalysisCoexistingMultipleAttractors(void)

    {
    double	i, c1[4], cn1[4], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];

    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn1[0] = -a * c1[0] + c1[1] * c1[2] + b * c1[3];
	cn1[1] = c * c1[1] - c1[0] * c1[2];
	cn1[2] = c1[0] * c1[1] - d * c1[2];
	cn1[3] = c1[0] * c1[2] - e * c1[3];
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multistability and Variable Multi-Directional Hidden Attractors of a New 6D Dynamical System with No Equilibrium Points
	Mati ur Rahman - not only, for the moment being 2023
	Private pre-print consultation sent by the author
	Corresponding author matimaths374@gmail.com
***************************************************************************/

int	DoMultistabilityVariableMultiDirectionalHiddenAttractors(void)

    {
    double	i, c1[6], cn1[6], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];

    totpasses = 10;

    InitOscillator(c1, 6);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn1[0] = a * c1[0] * c1[2] + b * c1[4] * cosh(c1[5]);
	cn1[1] = c * c1[0] * c1[2];
	cn1[2] = -a * c1[0] * c1[3] - c * c1[0] * c1[1] + d * c1[3];
	cn1[3] = -d * c1[2];
	cn1[4] = -b * c1[0] - c1[3] * c1[3] * c1[3];
	cn1[5] = -c * c1[5] * c1[5] * c1[2];
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)(i / 15.0) % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multistability in a Butterfly Flow
	CHUNBIAO LI and J. C. SPROTT June 5, 2013
	Picked in Chunbiao li papers' list and http://sprott.physics.wisc.edu/pubs/paper408.pdfe
***************************************************************************/

int	DoMultistabilityButterflyFlow(void)

    {
    double	i, c1[3], cn1[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn1[0] = c1[1] + c1[1] * c1[2];
	cn1[1] = -c1[0] * c1[2] + c1[1] * c1[2];
	cn1[2] = -a * c1[2] - c1[0] * c1[1] + b;
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multistability in a Novel Chaotic System with Perpendicular Lines of Equilibrium: Analysis, Adaptive Synchronization and Circuit Design
	Aceng Sambas, Sundarapandian Vaidyanathan, Sen Zhang, Wawan Trisnadi Putra, Mustafa Mamat and Mohamad Afendee Mohamed 12 December 2019.
	https://www.researchgate.net/publication/337903962
***************************************************************************/

int	DoMultistabilityNovelChaoticSystem(void)

    {
    double	i, c1[3], cn1[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn1[0] = a * c1[1] * c1[2];
	cn1[1] = c1[0] * fabs(c1[2]) - c1[1] * fabs(c1[0]);
	cn1[2] = fabs(c1[0]) - b * c1[0] * c1[0];
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multistability in Horizontal Platform System with and Without Time Delays
	Karthikeyan Rajagopala, Prakash Duraisamyb, Riessom Weldegiorgisc and Anitha Karthikeyan 11 January 2018
***************************************************************************/

int	DoMultistability(void)

    {
    double	i, c1[3], cn1[3], a, b, l, h, w;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    l = param[2];
    h = param[3];
    w = param[4];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn1[0] = c1[1];
	cn1[1] = -a * c1[1] - b * sin(c1[0]) + l * cos(c1[0]) * sin(c1[0]) + h * cos(c1[2]);
	cn1[2] = w;								// + x - y * z;
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multi-Stability in Self-Reproducing Systems
	Chunbiao Li and Julien Clinton Sprott January 2022
	https://www.researchgate.net/requests/r102440830
***************************************************************************/

int	DoMultistabilitySelfReproducingSystems(void)

    {
    double	i, c1[3], cn1[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn1[0] = sin(a * c1[1]) - b * tan(c1[0]);
	cn1[1] = sin(a * c1[2]) - b * tan(c1[1]);
	cn1[2] = sin(a * c1[0]) - b * tan(c1[2]);
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multistability in Symmetric Chaotic Systems – with Symmetry
	Chunbiao Li, W. Hu, Julien Clinton Sprott and Xiong Wang Jul 2015
	https://www.researchgate.net/requests/r83325279
***************************************************************************/

int	DoMultistabilitySymmetricChaoticSystems(void)

    {
    double	i, c1[3], cn1[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	if (i < iterations / 2)
	    c1[2] = -c1[2];							// this is new and results in symmetric attractors
	cn1[0] = -c1[1] - c1[2] * c1[2];
	cn1[1] = c1[0] + a * c1[1];
	cn1[2] = b * fabs(c1[2]) / c1[2] + c1[2] * (c1[0] - c);
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multistage Spectral Relaxation Method for Solving the Hyperchaotic Complex Systems
	Hassan Saberi Nik and Paulo Rebelo 16 October 2014
	https://downloads.hindawi.com/journals/tswj/2014/943293.pdf
***************************************************************************/

int	DoMultistageSpectralRelaxationMethod(void)

    {
    double	i, c1[6], cn1[6], a1, a2, a3, a4;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w

    a1 = param[0];
    a2 = param[1];
    a3 = param[2];
    a4 = param[3];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn1[0] = a1 * (c1[2] - c1[0]);
	cn1[1] = a1 * (c1[3] - c1[1]) + c1[5];
	cn1[2] = a2 * c1[0] - c1[2] - c1[0] * c1[4];
	cn1[3] = a2 * c1[1] - c1[3] - c1[1] * c1[4] + c1[5];
	cn1[4] = c1[0] * c1[2] + c1[1] * c1[3] - a3 * c1[4];
	cn1[5] = c1[0] * c1[2] + c1[1] * c1[3] - a4 * c1[5];
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multiswitching Synchronisation of a Driven Hyperchaotic Circuit Using Active Backstepping
	A. Ayotunde Ajayi, S. Kayode Ojo, E. Uchechukwu Vincent and N. Abdullahi Njah 18 February 2014
	https://www.hindawi.com/journals/jndy/2014/918586/
***************************************************************************/

int	DoMultiswitchingSynchronisation(void)

    {
    double	i, c1[3], cn1[3], a, b, m, c, mu, a0, w;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    m = param[2];
    c = param[3];
    mu = param[4];
    a0 = param[5];
    w = param[6];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn1[0] = b * c1[1] - c * c1[0];
	cn1[1] = c1[2] - mu * c1[1] - c1[0] + a0 * sin(w * i);
	cn1[2] = -m * (c1[2] * c1[2] * c1[2] - a * c1[2] - c1[1]);								// + x - y * z;
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multivariate Multiscale Complexity Analysis of Self-Reproducing Chaotic Systems - 14
	Shaobo He, Chunbiao Li, Kehui Sun and Sajad Jafari 27 July 2018
	https://www.mdpi.com/1099-4300/20/8/556/htm
***************************************************************************/

int	DoMultivariateMultiscaleComplexityAnalysis14(void)

    {
    double	i, c1[3], cn1[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn1[0] = a * c1[2] + c1[1] * c1[1] - 1;
	cn1[1] = b * c1[1] * c1[2];
	cn1[2] = -c * sin(d * c1[0]) - c1[2];
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multivariate Multiscale Complexity Analysis of Self-Reproducing Chaotic Systems - 16
	Shaobo He, Chunbiao Li, Kehui Sun and Sajad Jafari 27 July 2018
	https://www.mdpi.com/1099-4300/20/8/556/htm
***************************************************************************/

int	DoMultivariateMultiscaleComplexityAnalysis16(void)

    {
    double	i, c1[3], cn1[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn1[0] = fabs(c1[1]) - 1;
	cn1[1] = c1[2];
	cn1[2] = c1[0] - b * c1[1] - a * c1[2];
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multivariate Multiscale Complexity Analysis of Self-Reproducing Chaotic Systems - 17
	Shaobo He, Chunbiao Li, Kehui Sun and Sajad Jafari 27 July 2018
	https://www.mdpi.com/1099-4300/20/8/556/htm
***************************************************************************/

int	DoMultivariateMultiscaleComplexityAnalysis17(void)

    {
    double	i, c1[3], cn1[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn1[0] = a * c1[2] + c1[1] * c1[1] - 1;
	cn1[1] = b * c1[1] * c1[2];
	cn1[2] = -c1[0] - c1[2];
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multi-Wing Chaotic Lorenz-like System I
	GENERATION OF MULTI-WING CHAOTIC ATTRACTORS FROM A LORENZ-LIKE SYSTEM
	QIANG LAI and ZHI-HONG GUAN, YONGHONG WU, FENG LIU, DING-XUE ZHANG March 31, 2013
***************************************************************************/

int	DoMultiWingI(void)

    {
    double	i, c1[3], cn1[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn1[0] = 5.0 * (c1[1] - c1[0]);
	cn1[1] = c1[0] * (fabs(c1[2]) - 15.0);
	cn1[2] = fabs(c1[2]) / c1[2] * (10.0 - c1[0] * c1[1]);
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Multi-Wing Chaotic Lorenz-like System II
	GENERATION OF MULTI-WING CHAOTIC ATTRACTORS FROM A LORENZ-LIKE SYSTEM
	QIANG LAI and ZHI-HONG GUAN, YONGHONG WU, FENG LIU, DING-XUE ZHANG March 31, 2013
***************************************************************************/

int	DoMultiWing(int variety)

    {
    double	i, c1[3], cn1[3], a, b, c, alpha, fz;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    alpha = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn1[0] = a * (c1[1] - c1[0]);
	if (variety == 2)
	    fz = alpha * fabs(c1[2]) / c1[2];
	else if (variety == 3)
	    fz = alpha * fabs(c1[2] + 5.0) / (c1[2] + 5.0) + 5.0 * fabs(c1[2] - 5.0) / (c1[2] - 5.0);
	else if (variety == 4)
	    fz = alpha * (fabs(c1[2] + 10.0) / (c1[2] + 10.0) + fabs(c1[2]) / c1[2] + fabs(c1[2] - 10.0) / (c1[2] - 10.0));
	else
	    fz = alpha * (fabs(c1[2] + 15.0) / (c1[2] + 15.0) + fabs(c1[2] + 5.0) / (c1[2] + 5.0) + fabs(c1[2] - 5.0) / (c1[2] - 5.0) + fabs(c1[2] - 15.0) / (c1[2] - 15.0));
	cn1[1] = b * c1[0] * (c1[2] - fz);
	cn1[2] = c - c1[0] * c1[1];
	if (DisplayOscillator(c1, cn1, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

int	DoMultiWingII(void)

    {
    return DoMultiWing(2);
    }

int	DoMultiWingIII(void)

    {
    return DoMultiWing(3);
    }

int	DoMultiWingIV(void)

    {
    return DoMultiWing(4);
    }

int	DoMultiWingV(void)

    {
    return DoMultiWing(5);
    }

/**************************************************************************
	Musical Chaotic Oscillator Images
	The analysis of complex behaviours of a novel three 
	dimensional autonomous system 
	Dong Gao-Gao, Zheng Song, Tian Li-Xin, Du Rui-Jin and Sun Mei 
	Received 25 January 2010
***************************************************************************/

int	DoMusical(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e, f, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] * c1[2] - b * c1[0] + c * c1[1] * c1[2];
	cn[1] = c1[2] + d * c1[1] - e * c1[0] * c1[2];
	cn[2] = f * c1[0] * c1[1] - g * c1[2] + c1[2] * (c1[0] - c);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 3.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Muthuswamy-Chua Attractor Images
	TOPOLOGICAL ANALYSIS OF CHAOTIC SOLUTION OF A THREE-ELEMENT MEMRISTIVE CIRCUIT
	JEAN-MARC GINOUX, CHRISTOPHE LETELLIER, LEON O. CHUA June 16, 2010
***************************************************************************/

int	DoMuthuswamy(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)					// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[0] / 3.0 + c1[1] / 2.0 - c1[1] * pow(fabs(c1[2]), 2.5) / 2.0;
	cn[2] = c1[1] - a * c1[2] - c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 3.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	New 7D-Hyperchaotic 4th Order System Hyperchaos Based Cryptography
	New Seven Dimensional Systems to Secure Communications-4 order system
	S.N. Lagmiri, M. Amgha, N. Sbitir March 2017
***************************************************************************/

int	DoNew7DHyperchaotic(void)

    {
    double	i, c1[7], cn[7], a, b, yc, d, e, f, yg, h;

    c1[0] = param[10];	// x1
    c1[1] = param[11];	// x2
    c1[2] = param[12];	// x3
    c1[3] = param[13];	// x4
    c1[4] = param[14];	// x5
    c1[5] = param[15];	// x6
    c1[6] = param[16];	// x7

    a = param[0];
    b = param[1];
    yc = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    yg = param[6];
    h = param[7];
    totpasses = 10;

    InitOscillator(c1, 7);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[0] - 20.0 * c1[4] - c1[2] * c1[4] * c1[5] * c1[6];
	cn[1] = yc * c1[1] - d * c1[5] + c1[0] * c1[3] * c1[4] * c1[6];
	cn[2] = -a * c1[2] + a * c1[4] - yg * c1[0] * c1[1] * c1[3] * c1[5];
	cn[3] = -a * c1[3] + yc * c1[0] + c1[0] * c1[1] * c1[2] * c1[4];
	cn[4] = -a * c1[4] + e * c1[6] + c1[0] * c1[1] * c1[2] * c1[3];
	cn[5] = -yc * c1[5] + yc * c1[4] + c1[1] * c1[2] * c1[3] * c1[4];
	cn[6] = -b * c1[6] + f * c1[1] - h * c1[0] * c1[3] * c1[4] * c1[5];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 7, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	New Chaos 1-Scroll Attractor Images
***************************************************************************/

int	DoNewChaos(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];
    c1[1] = param[11];
    c1[2] = param[12];

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -((a * b) / (a + b)) * c1[0] - c1[1] * c1[2] + c;
	cn[1] = a * c1[1] + c1[0] * c1[2];
	cn[2] = b * c1[2] + c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	New Chaos N-Scroll HyperChaotic Attractor Images
	Simin Yu, Jinhu Lu, Guanrong Chend
	Physics Letters A 364 (2007) 244?251
***************************************************************************/

int	DoNewChaosN(void)

    {
    double	i, c1[4], cn[4], m0, m1, alpha, beta, gamma, gammazero, gyx, X1;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    alpha = param[0];
    beta = param[1];
    gamma = param[2];
    gammazero = param[3];
    m0 = param[4];
    m1 = param[5];
    X1 = param[6];
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	gyx = m1 * (c1[1] - c1[0]) + 0.5 * (m0 - m1) * (fabs(c1[1] - c1[0] + X1) - fabs(c1[1] - c1[0] - X1));
	cn[0] = alpha * (gyx - c1[2]);
	cn[1] = beta * (-gyx - c1[3]);
	cn[2] = gammazero * (c1[0] + c1[2]);
	cn[3] = gamma * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	New Chaotic Attractor Images
	Dynamical Analysis and Electronic Implementation of A New Chaotic Attractor
	Ihsan Pehlivan, Yilmaz Uyaroglu, Ihsan Bayir, Serkan Akkaya, Nazim Imal 2011
***************************************************************************/

int	DoNewChaoticAttractor(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[1] * c1[2];
	cn[1] = -a * c1[0] - c1[1] + c1[1] * c1[2];
	cn[2] = b + c * c1[0] - d * c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	New Chaotic Attractors: Application of Fractal-Fractional Differentiation and Integration - I
	J.F. Gómez-Aguilar and Abdon Atangana 2 August 2019
	https://www.researchgate.net/requests/r83755744
***************************************************************************/

int	DoNewChaoticAttractorsFractionalDifferentiationIntegration(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] + b;
	cn[1] = -7 * c1[0] + 4 * c1[1] * c1[2];
	cn[2] = a - c1[0] * c1[0] - c1[1] * c1[1] + c * c1[0] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Chaotic Attractor with Quadratic Exponential Nonlinear Term from Chen's Attractor
	IFTIKHAR AHMED, CHUNLAI MU, AND FUCHEN ZHANG
***************************************************************************/

int	DoNewAttractor(void)

    {
    double	i, c1[3], cn[3], a, b, c, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    e = exp(1.0);
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = (c - a) * c1[0] + c * c1[1] - c1[0] * c1[2];
	cn[2] = pow(e, (c1[0] * c1[1])) - b * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	New Butterfly-Shaped Chaotic Attractor
	Dongwon Kim, Pyung Hun Chang 16 February 2013
***************************************************************************/

int	DoNewButterfly(void)

    {
    double	i, c1[3], cn[3], a, b, c, u;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    u = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + u * c1[2];
	cn[1] = c1[0] * c1[2] + b * c1[1] + u * c1[0];
	cn[2] = -c1[0] * c1[0] - c * c1[2] + u * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Chaotic Attractor With Quadratic Exponential Nonlinear Term From Chen's Attractor in 4 Dimensions
	IFTIKHAR AHMED, CHUNLAI MU, AND FUCHEN ZHANG & Marcus Rezende 2014
***************************************************************************/

int	DoNewChaoticAttractor4D(void)

    {
    double	i, c1[4], cn[4], a, b, c, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    e = exp(1.0);
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = (c - a) * c1[0] + c * c1[1] - c1[0] * c1[2];
	cn[2] = pow(e, (c1[0] * c1[1])) - b * c1[2];
	cn[3] = -c * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Chaotic Attractor With Quadratic Exponential Nonlinear Term From Chen's Attractor (Modified)
	IFTIKHAR AHMED, CHUNLAI MU, AND FUCHEN ZHANG &Marcus Rezende 2014 / 2015
*********************************************************** ****************/

int	DoNewChaoticAttractorMod(void)

    {
    double	i, c1[3], cn[3], a, b, c, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    e = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = (c - a) * c1[0] + c * c1[1] - c1[0] * c1[2];
	cn[2] = pow(e, (c1[0] * c1[1] - c1[2])) - b * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	New Chaotic System - Multiplied By Catastrophe Equations
	Shahed Vahedi, Mohd Salmi Md Noorani 28 April 2013
***************************************************************************/

int	DoNewChaoticCatastrophe(void)

    {
    double	i, temp[3], c1[3], cn[3], a, b, c, d, xnew, ynew, znew, dx = 0.0;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    d = 0.0;

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	// Oscillator
	xnew = a * c1[0] - c1[1] * c1[2];
	ynew = -b * c1[1] + c1[0] * c1[2];
	znew = -c * c1[2] + c1[0] * c1[1];
	c1[0] += xnew*dt; c1[1] += ynew*dt; c1[2] += znew*dt;
	// catastrophe equations
	cn[0] = 3.0 * c1[0] * c1[0] + a + c * c1[1];
	cn[1] = 3.0 * c1[1] * c1[1] + b + c * c1[0];
	cn[2] = 3.0 * c1[2] * c1[2] + d + c * (sqrt(fabs(c1[0] + c1[1])) + (c1[0] + c1[1]) / 2.0) / 2.0;
	// multiply Catastrophe with the oscillator to form Catastrophic Chaotic Attractor
	temp[0] = c1[0] * cn[0] / 1000.0; 
	temp[1] = c1[1] * cn[1] / 1000.0; 
	temp[2] = c1[2] * cn[2] / 1000.0;
	if (DisplayOscillator(temp, cn, dx, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	New Four-Wing Hyper-chaotic Attractor and Its Circuit Implementation
	Enzeng Dong, Zengqiang Chen, Zhuzhi Yuan October 2010
	https://www.researchgate.net/publication/238519733_A_New_Four-Wing_Hyper-chaotic_Attractor_and_Its_Circuit_Implementation
***************************************************************************/

int	DoNewFourWingHyperchaoticAttractor(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] - b * c1[1] * c1[2];
	cn[1] = -c * c1[1] + c1[0] * c1[2] - c1[3];
	cn[2] = c1[0] + c1[0] * c1[1] - d * c1[2];
	cn[3] = c1[1] - e * c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	New Chaotic Dynamical System Images
	Adaptive Feedback Control for Chaos Control and Synchronisation for 
	New Chaotic 'Dynamical System 
	M. M. El-Dessoky1, 2 and M. T. Yassen2 May 2012
***************************************************************************/

int	DoNewChaoticDynamicSystem(void)

    {
    double	i, c1[4], cn[4], a, b, c, gamma;

    c1[0] = param[10];	// y1
    c1[1] = param[11];	// y2
    c1[2] = param[12];	// y3
    c1[3] = param[13];	// k1

    a = param[0];
    b = param[1];
    c = param[2];
    gamma = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = b * c1[1] - c1[1] * c1[2] + c1[3] * c1[0];
	cn[1] = a * (c1[0] - c1[1]);
	cn[2] = c1[0] * c1[1] + c * c1[2];
	cn[3] = -gamma * c1[0] * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	New Chaotic Finance System - Its Analysis, Control, Synchronization and Circuit Design
	Babatunde A. Idowu, Sundarapandian Vaidyanathan, Aceng Sambas, Olasunkanmi I. Olusola and O. S. Onma 2018
	https://www.researchgate.net/requests/r41338629
***************************************************************************/

int	DoNewChaoticFinanceSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2] + (c1[1] - a) * c1[0];
	cn[1] = 1.0 - b * c1[1] - c1[0] * c1[0];
	cn[2] = -c1[0] - c * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	New Class of Chaotic Systems with Equilibrium Points like a three-leaved clover-I
	Saleh Mobayen, Christos K. Volos, Sezgin Kaçar and Unal Cavusoglu 1 November 2017
	https://www.researchgate.net/publication/321019563_New_class_of_chaotic_systems_with_equilibrium_points_like_a_three-leaved_clover
***************************************************************************/

int	DoNewClassChaoticSystemsEquilibriumPointsI(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[2];
	cn[1] = -c1[2] * (b * c1[1] + c1[2] * c1[2] + c1[1] * c1[2]);
	cn[2] = c1[0] * c1[0] * c1[0] * c1[0] + c * c1[0] * c1[0] * c1[1] * c1[1] + c1[1] * c1[1] * c1[1] * c1[1] - c1[0] * c1[0] * c1[0] + d * c1[0] * c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	New Class of Chaotic Systems with Equilibrium Points like a three-leaved clover-II
	Saleh Mobayen, Christos K. Volos, Sezgin Kaçar and Unal Cavusoglu 1 November 2017
	https://www.researchgate.net/publication/321019563_New_class_of_chaotic_systems_with_equilibrium_points_like_a_three-leaved_clover
***************************************************************************/

int	DoNewClassChaoticSystemsEquilibriumPointsII(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[2];
	cn[1] = -c1[2] * (b * c1[1] + c1[0] * c1[0] + c * c1[1] * c1[2]);
	cn[2] = c1[0] * c1[0] * c1[0] * c1[0] + d * c1[0] * c1[0] * c1[1] * c1[1] + c1[1] * c1[1] * c1[1] * c1[1] - c1[0] * c1[0] * c1[0] + e * c1[0] * c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	New Class of Chaotic Systems with Equilibrium Points like a three-leaved clover-III
	Saleh Mobayen, Christos K. Volos, Sezgin Kaçar and Unal Cavusoglu 1 November 2017
	https://www.researchgate.net/publication/321019563_New_class_of_chaotic_systems_with_equilibrium_points_like_a_three-leaved_clover
***************************************************************************/

int	DoNewClassChaoticSystemsEquilibriumPointsIII(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[2];
	cn[1] = -c1[2] * (b * c1[0] + c * c1[1] + d * c1[1] * c1[2]);
	cn[2] = c1[0] * c1[0] * c1[0] * c1[0] + e * c1[0] * c1[0] * c1[1] * c1[1] + c1[1] * c1[1] * c1[1] * c1[1] - c1[0] * c1[0] * c1[0] + f * c1[0] * c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	New Family of 4-D Hyperchaotic and Chaotic Systems with Quadric Surfaces of Equilibria- QS6 (Circular Hyperboloid of One Sheet)
	Jay Prakash Singh, Binoy Krishna Roy and Sajad Jafari 18 November 2017
	https://www.researchgate.net/publication/321155165_New_Family_of_4-D_Hyperchaotic_and_Chaotic_Systems_with_quadric_Surfaces_of_Equilibria
***************************************************************************/

int	DoNewFamily4DHyperchaoticChaoticSystems(void)

    {
    double	i, c1[4], cn[4], h, d, g, a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    h = param[0];
    d = param[1];
    g = param[2];
    a = param[3];
    b = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2];
	cn[1] = -c1[2] * (h * c1[1] + d * c1[0] * c1[0] + c1[0] * c1[2]);
	cn[2] = c1[0] * c1[0] / a / a + c1[1] * c1[1] / a / a + c1[3] * c1[3] / b / b - 1.0;
	cn[3] = -g * c1[2] * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	New Hyperchaotic Attractor with Complex Patterns
	Safieddine Bouali March 2015
***************************************************************************/

int	DoNewHyperchaoticComplexPatterns(void)

    {
    double	i, c1[4], cn[4], a, b, c, e;
    bool	trig;

    a = param[0];
    b = param[1];
    c = param[2];
    e = param[3];
    trig = (param[4] != 0.0);
    totpasses = 10;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	if (trig)							// Marcus introduced these trigonometric functions at the end of each line
	    {
	    cn[0] = c1[0] * (1.0 - c1[1]) + a * c1[2] + sin(c1[1]);
	    cn[1] = b * (c1[0] * c1[0] - 1.0) * c1[1] + cos(c1[2]);
	    cn[2] = c * (1.0 - c1[1]) * c1[3] - tan(c1[0]);
	    cn[3] = e * c1[2] - cos(c1[3]);
	    }
	else
	    {
	    cn[0] = c1[0] * (1.0 - c1[1]) + a * c1[2];
	    cn[1] = b * (c1[0] * c1[0] - 1.0) * c1[1];
	    cn[2] = c * (1.0 - c1[1]) * c1[3];
	    cn[3] = e * c1[2];
	    }
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	New Jerk chaotic Circuit Images
***************************************************************************/

int	DoNewJerk(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = -c1[2] - c1[0] - a * (exp(c1[1] / b) - 1);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	New Lorenz's Family Attractor Images
	Theoretic and Numerical Study of a New Chaotic System
	IFTIKHAR AHMED, CHUNLAI MU, AND FUCHEN ZHANG Congxu Zhu, Yuehua Liu, Ying Guo
	February 2010
***************************************************************************/

int	DoNewLorenz(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[0] - a * c1[1] + c1[1] * c1[2];
	cn[1] = b * c1[1] - c1[0] * c1[2];
	cn[2] = -c * c1[2] + c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	New Memristive Hyperchaotic System
	A Memristive Hyperchaotic System without Equilibrium
	Viet-Thanh Pham, Christos Volos, and Lucia Valentina Gambuzza & Marcus Rezende 15 July 2014
***************************************************************************/

int	DoNewMemristive(void)

    {
    double	i, c1[4], cn[4], a, b, k, mu;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    mu = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	c1[0] = (c1[0] < 0.5 && c1[0] >= 0.0) ? mu * c1[0] : ((c1[0] >= 0.5 && c1[0] <= 1.0) ? mu * (1.0 - c1[0]) : c1[0]);
	// Line above makes all the difference
	// It could be use to create 'anomalies' in other
	// Lorenz's like programs. It was provided from other
	// linear programs already have received (Tent, Logistic,etc)
	cn[0] = -10.0 * c1[0] - a * c1[1] - c1[1] * c1[2];
	k = (1.0 + 0.24 * c1[1] * c1[1] - 0.0016 * pow(c1[1], 4.0)) * c1[1];
	cn[1] = -6.0 * c1[0] + 1.2 * c1[0] * c1[2] + 0.1 * k - b;
	cn[2] = -c1[2] - 1.2 * c1[1] * c1[0];
	cn[3] = c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	New Quadratic 3D Attractor
	Analysis of a New Quadratic 3D Chaotic Attractordouble scroll-xxx
	Shahed Vahedi, Mohd Salmi Md Noorani 28 April 2013
***************************************************************************/

int	DoNewQuadratic(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[1] * c1[2];
	cn[1] = (c - a) * c1[0] + c * c1[1] - c1[0] * c1[2];
	cn[2] = c1[0] * c1[1] - b * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A New Simple Chaotic Lorenz-Type System and Its Digital Realization Using a TFT Touch-Screen Display Embedded System
	Rodrigo Méndez-Ramírez, Adrian Arellano-Delgado, César Cruz-Hernández and Rigoberto Martínez-Clark1 26 July 2017
***************************************************************************/

int	DoNewSimpleChaoticLorenzTypeSystem(void)

    {
    double	i, c1[3], cn[3], a, c, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    c = param[1];
    k = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -2.0 * c1[0] - 40.0 * c1[1] * c1[2];
	cn[1] = -c1[0] + 0.5 * c1[1];
	cn[2] = 0.2 - 20.0 * c1[1] * c1[1] - c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	New Three-Dimensional Chaotic System Without Equilibrium Points, 
	its Dynamical Analyses and Electronic Circuit Application
	Akif Akgul, Ihsan Pehlivan 2016
***************************************************************************/

int	DoNewThreeDimensionalChaotic(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[1] - c1[0] + c1[2] * c1[1];
	cn[1] = -b * c1[0] * c1[2] - c * c1[0] + c1[1] * c1[2] + d;
	cn[2] = e - f * c1[0] * c1[1] - c1[0] * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Newton-Leipnik Chaotic Attractor Images
***************************************************************************/

int	DoNewtonLeipnik(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[0] + c1[1] + 10.0 * c1[1] * c1[2];
	cn[1] = -c1[0] - 0.4 * c1[1] + 5.0 * c1[0] * c1[2];
	cn[2] = b * c1[2] - 5.0 * c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	New Way to Generate High-Dimensional Hyperchaos (10 Dimensions)
	Jianming Liu SEPTEMBER 2013
***************************************************************************/

int	DoHighDimensionalHyperchaos(void)

    {
    double	i, c1[10], cn[10], a, b, c, d, e, f, g, h, j, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w
    c1[6] = param[16];	// p
    c1[7] = param[17];	// q
    c1[8] = param[18];	// r
    c1[9] = param[19];	// s

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];
    h = param[7];
    j = param[8];
    k = param[9];
    totpasses = 10;

    InitOscillator(c1, 10);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + d * c1[2] * c1[9] - c1[5];
	cn[1] = c * c1[0] - c1[0] * c1[2] - c1[1];
	cn[2] = c1[0] * c1[1] - b * c1[2];
	cn[3] = c1[4];
	cn[4] = -e * c1[4] - c1[3] * c1[3] * c1[3] + f * cos(c1[5]);
	cn[5] = g * c1[0];
	cn[6] = h * c1[8];
	cn[7] = -j * c1[7] + c1[8] + k * c1[6] * c1[8];
	cn[8] = -c1[6] + c1[7] + c1[7] * c1[7];
	cn[9] = -c1[6] * c1[8] - c1[9] + c1[6];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 10, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	No Chattering and Adaptive Sliding Mode Control of a Fractional-Order Phase Converter with Disturbances and Parameter Uncertainties
	Karthikeyan Rajagopal , Riessom Weldegiorgis, Anitha Karthikeyan, Prakash Duraisamy and Goitom Tadesse 22 October 2018
	https://www.hindawi.com/journals/complexity/2018/5873230/
***************************************************************************/

int	DoNoChatteringAdaptiveSlidingModeControl(void)

    {
    double	i, c1[5], cn[5], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -a * c1[1] - b * c1[0] * c1[0] * c1[0] - c * c1[0] * c1[2] * c1[2];
	cn[2] = c1[3];
	cn[3] = -a * c1[4] - b * c1[0] * c1[0] * c1[2] - c * c1[2] * c1[2] * c1[2] + d * cos(c1[4]) + e;
	cn[4] = 1.0;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Nonautonomous Predator-Prey Model with Infertility Control in the Prey
	The Dynamics of a Nonautonomous Predator-Prey Model with Infertility Control in the Prey
***************************************************************************/

int	DoNonautonomousPredatorPrey(void)

    {
    double	i, c1[3], cn[3], b1, a11, mu, a12, d2, b2, a21, a22;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	b1 = 10.0 + sin(6.0 * i / PI);
	a11 = 0.09 + 0.001 * sin(6.0 * i / PI);
	mu = 9.0 * (0.35 + 0.1 * cos(i / 4.0) + 0.1 * sin(i / 4.0));
	a12 = 1.2 + cos(i / 6.0);
	d2 = 2.0 + .005 * sin(6.0 * i / PI);
	b2 = 1.5 + cos(i / 6.0);
	a21 = 0.7 + 0.3 * cos(6.0 * i / PI);
	a22 = 5.0 + 3.0 * sin(i / 6.0);
	cn[0] = c1[0] * (b1 - a11 * (c1[0] + c1[1]) - mu - a12 * c1[2]);
	cn[1] = mu * c1[0] - d2 * c1[1] - a11 * (c1[0] + c1[1]) * c1[1] - a12 * c1[1] * c1[2];
	cn[2] = c1[2] * (b2 + a21 * (c1[0] + c1[1]) - a22 * c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Nonautonomous Wien-Bridge Oscillator
	Investigation of Chaotic and Strange Nonchaotic Phenomena in Nonautonomous Wien-Bridge Oscillator with Diode Nonlinearity
	R. Rizwana and I. Raja Mohamed 19 December 2014
***************************************************************************/

int	DoNonautonomousWienBridge(void)

    {
    double	i, c1[3], cn[3], f1, f2, b, w1, w2, k, g, ColourFactor;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    f1 = param[0];
    f2 = param[1];
    b = param[2];
    w1 = param[3];
    w2 = param[4];
    k = param[5];
    ColourFactor = param[6];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	c1[2] = c1[0] - f1 * sin(w1 * i + f2 * sin(w2 * i));
	g = 0.5 * b * (fabs(c1[2] - 1.0) + c1[2] - 1.0);
	cn[0] = (k - 2.0) * c1[0] - c1[1] - g;
	cn[1] = (k - 1.0) * c1[0] - c1[1];
//	cn[2] = -b * c1[2] + sin(c1[0]);
	cn[2] = 1.0;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Non-Integrability of a System with the Dyson Potential
	Georgi Georgiev 1 Dec 2017
***************************************************************************/

int	DoNonIntegrabilityDysonPotential(void)

    {
    double	i, c1[4], cn[4];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 2.0 * c1[2] - c1[3];
	cn[1] = -c1[2] + 2.0 * c1[3];
	cn[2] = -8.0 / 3.0 * c1[0] - 4.0 / 3.0 * c1[1] - 8.0 / 9.0 * sqrt(fabs(3.0 * c1[0] * c1[1])) - 4.0 / 9.0 * sqrt(3.0 * c1[1] * c1[1]);
	cn[3] = -4.0 / 3.0 * c1[0] - 8.0 / 3.0 * c1[1] - 8.0 / 9.0 * sqrt(fabs(3.0 * c1[0] * c1[1])) - 4.0 / 9.0 * sqrt(c1[0] * c1[0] * 3.0);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	New Nonlinear Active Element Dedicated to Modeling Chaotic Dynamics with Complex Polynomial Vector Fields
	Jiri Petrzela and Roman Sotner 6 September 2019
	https://www.mdpi.com/1099-4300/21/9/871/htm
***************************************************************************/

int	DoNewNonlinearActiveElement(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[1] * c1[1] - b * c1[2];
	cn[1] = a * c1[2] * c1[2] - b * c1[0];
	cn[2] = a * c1[0] * c1[0] - b * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Nonlinear Analysis of a 4D Fractional Hyper-Chaotic System Based on Riemann–Liouville–Caputo Fractal–Fractional Derivative
	Yuhang Pan 18 October 2021
	https://link.springer.com/article/10.1007/s11071-021-06951...https://doi.org/10.1007/s11071-021-06951-w
	Contacting author: yuhangpande@163.com
***************************************************************************/

int	DoNonlinearAnalysis4DFractionalHyperChaoticSystem(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[1] * c1[2] * c1[3];
	cn[1] = b * (c1[1] + c1[0]) - c1[0] * c1[2] * c1[3];
	cn[2] = -c * c1[2] + c1[0] * c1[1] * c1[2];
	cn[3] = -d * c1[3] + c1[0] * c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Non-linear Arabesques I Images
	LINEAR AND NONLINEAR ARABESQUES:
	A STUDY OF CLOSED CHAINS OF NEGATIVE 2-ELEMENT CIRCUITS
	CHRIS ANTONOPOULOS, VASILEIOS BASIOS, JACQUES DEMONGEOT PASQUALE NARDONE, RENE THOMAS
	April 14, 2013
***************************************************************************/

int	DoNonLinearArabesquesI(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] * c1[1] * c1[1] - c1[2];
	cn[1] = c1[2] - c1[0];
	cn[2] = c1[0] - c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 250.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Non-linear Arabesques II Images
	LINEAR AND NONLINEAR ARABESQUES:
	A STUDY OF CLOSED CHAINS OF NEGATIVE 2-ELEMENT CIRCUITS
	CHRIS ANTONOPOULOS, VASILEIOS BASIOS, JACQUES DEMONGEOT PASQUALE NARDONE, RENE THOMAS
	April 14, 2013
***************************************************************************/

int	DoNonLinearArabesquesII(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] * c1[1] * c1[1] - c1[2];
	cn[1] = c1[2] * c1[2] * c1[2] - c1[0];
	cn[2] = c1[0] * c1[0] * c1[0] - c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 50.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Non-linear Arabesques III Images
	LINEAR AND NONLINEAR ARABESQUES:
	A STUDY OF CLOSED CHAINS OF NEGATIVE 2-ELEMENT CIRCUITS
	CHRIS ANTONOPOULOS, VASILEIOS BASIOS, JACQUES DEMONGEOT PASQUALE NARDONE, RENE THOMAS
	April 14, 2013
***************************************************************************/

int	DoNonLinearArabesquesIII(void)

    {
    double	i, c1[4], cn[4];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] * c1[1] * c1[1] - c1[3];
	cn[1] = c1[2] * c1[2] * c1[2] - c1[0];
	cn[2] = c1[3] * c1[3] * c1[3] - c1[1];
	cn[3] = c1[0] * c1[0] * c1[0] - c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 50.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Nonlinear Dynamical Model with Three Quadratic Nonlinear Terms and Hidden Chaos
	Sundarapandian Vaidyanathan, Esteban Tlelo-Cuautle, Aceng Sambas and Francesco Grasso 2019
	Received from  Esteban Tlelo-Cuautle
***************************************************************************/

int	DoNonlinearDynamicalModelThreeQuadraticNonlinearTerms(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = a * c1[0] * c1[2] + b * c1[1] * c1[1] - c * c1[1] - c1[1] * c1[2];
	cn[2] = c1[1] * c1[1] - 1;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 50.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Nonlinear Dynamics and Chaos in a Fractional-Order HIV Model
	Haiping Ye and Yongsheng Ding 2016
***************************************************************************/

int	DoNonLinearDynamicsFractionalOrderHIVModel(void)

    {
    double	i, c1[5], cn[5], lambda, a, b, c, delta, d, beta1, beta2;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v

    a = param[0];
    lambda = param[1];
    b = param[2];
    c = param[3];
    delta = param[4];
    d = param[5];
    beta1 = param[6];
    beta2 = param[7];

    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = lambda - d * c1[0] - beta1 * c1[0] * c1[1] - beta2 * c1[0] * c1[2];
	cn[1] = beta1 * c1[0] * c1[1] - a * c1[1] - b * c1[3] * c1[1] / (c1[0] + c1[1] + c1[2]);
	cn[2] = beta2 * c1[0] * c1[2] - a * c1[2] - b * c1[4] * c1[2] / (c1[0] + c1[1] + c1[2]);
	cn[3] = c * c1[3] * c1[1] / (c1[0] + c1[1] + c1[2]) - delta * c1[3];
	cn[4] = c * c1[4] * c1[2] / (c1[0] + c1[1] + c1[2]) - delta * c1[4];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 50.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Nonlinear dynamics of a SDOF oscillator with Bouc-Wen hysteresis Images
	Hong-guang Li *, Guang Meng 2007
***************************************************************************/

int	DoNonlinearDynamics(void)

    {
    double	i, c1[4], cn[4], a, b, g, n, w, p, alpha, beta;

    c1[0] = param[10];	// x1
    c1[1] = param[11];	// x2
    c1[2] = param[12];	// x3
    c1[3] = param[13];	// x4

    n = param[0];
    w = param[1];
    g = param[2];
    a = param[3];
    b = param[4];
    alpha = param[5];
    beta = param[6];
    p = param[7];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -2.0 * n * w * c1[1] - g * w * w * c1[0] - (1.0 - g) * w * w * c1[2] + b * sin(c1[2]);
	cn[2] = a * c1[1] - alpha * fabs(c1[1]) * c1[2] - beta * c1[1] * fabs(c1[2]);
	cn[3] = c1[1] - c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Nonlinear Gear Systems
	Bifurcation and Chaos Prediction in Nonlinear Gear Systems' der Pol-Duffing Oscillators
	Anooshirvan Farshidianfar and Amin Saghafi 28 May 2014
***************************************************************************/

int	DoNonlinearGear(void)

    {
    double	i, c1[4], cn[4], b, c;
    double	e = 0.0, delta = 0.0, beta = 0.0, mi = 0.0;	// oh Marcus, let's take a little more care

    c1[0] = param[10];	// x1
    c1[1] = param[11];	// x2
    c1[2] = param[12];	// x3
    c1[3] = param[13];	// x4

    b = param[0];
    c = param[1];
    e = param[2];
    delta = param[3];
    beta = param[4];
    mi = param[5];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = b * c1[0] - c1[0] - c * c1[0] * c1[0] * c1[0];
	cn[2] = c1[3];
	cn[3] = (e - c1[2] * c1[2]) * c1[3] - (1.0 + delta) * c1[2] - beta * c1[2] * c1[2] * c1[2] + mi * (c1[1] - c1[3]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 160.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Nonsmooth Bifurcations, Transient Hyperchaos and Hyperchaotic Beats in a Memristive Murali-Lakshmanan-Chua
	A. Ishaq Ahamedc and  M. Lakshmanany March 15, 2013
***************************************************************************/

int	DoNonsmoothBifurcations(void)

    {
    double	i, c1[4], cn[4], a1, a2, beta, omega, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a1 = param[0];
    a2 = param[1];
    beta = param[2];
    omega = param[3];
    f = param[4];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2] - ((fabs(c1[0]) > 1.0) ? a2 : a1) * c1[1];
	cn[2] = -beta * (c1[1] + c1[2]) + f * sin(omega * c1[3]);
	cn[3] = 1.0;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 160.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Nonstationary Chimeras in a Neuronal Network
	Zhouchao Wei, Fatemeh Parastesh, Hamed Azarnoush, Sajad Jafari, Dibakar Ghosh, Matjaz Perc and Mitja Slavinec 18 September 2018
	https://www.researchgate.net/publication/327731487
***************************************************************************/

int	DoNonstationaryChimeras(void)

    {
    double	i, c1[3], cn[3], im, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    im = param[0];
    f = param[1];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] + 3 * c1[0] * c1[0] - c1[0] * c1[0] * c1[0] - c1[2] + 3 - im * sin(2 * PI * f * i);
	cn[1] = 1 - 5 * c1[0] * c1[0] - c1[1];
	cn[2] = 0.0084 * (c1[0] + 1.6) - 0.0021 * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 160.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Nose-Hoover chaotic attractor Oscillator Images
***************************************************************************/

int	DoNoseHoover(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[0] + c1[1] * c1[2];
	cn[2] = a - (c1[1] * c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Nose-Hoover 4D Version
	William Graham Hoover,  Julien Clinton Sprott and Carol Griswold Hoover, June 10, 2019
	arXiv:1906.03107v1
***************************************************************************/

int	DoNoseHoover4D(void)

    {
    double	i, c1[4], cn[4];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[0] - c1[2] * c1[0] - c1[3] * c1[1] * c1[1] * c1[1];
	cn[2] = c1[1] * c1[1] - 1;
	cn[3] = c1[1] * c1[1] * c1[1] * c1[1] - 3 * c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Novel 3-Scroll Chua’s Attractor with One Saddle-Focus and Two Stable Node-Foci
	Kaibin Chu, Zhengwei Zhu, Hui Qian and Huagan Wu 31 January 2018
	https://www.hindawi.com/journals/mpe/2018/8917313/
***************************************************************************/

int	DoNovel3ScrollChuasAttractor(void)

    {
    double	i, c1[3], cn[3], alpha, beta, a, b, h, mu;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alpha = param[0];
    beta = param[1];
    a = param[2];
    b = param[3];
    mu = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	h = (b + 1.0) * c1[0] + 0.5 * (a - b) * (fabs(c1[0] + 1.0) - fabs(c1[0] - 1.0));
	if (fabs(c1[2]) <= mu) 
	    h = -h;
	cn[0] = alpha * (c1[1] - h);
	cn[1] = c1[0] - c1[1] + c1[2];
	cn[2] = -beta * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Novel 4-Dimensional Hyperchaotic Attractor with Typical Wings
	Safieddine Bouali 2 Jun 2015
***************************************************************************/

int	DoNovel4D(void)

    {
    double	i, c1[4], cn[4], alpha, beta, phi, s, psi;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    alpha = param[0];
    beta = param[1];
    phi = param[2];
    s = param[3];
    psi = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] * (c1[1] - 1.0) + alpha * c1[2];
	cn[1] = beta * (c1[0] * c1[0] - 1.0) * c1[1];
	cn[2] = phi * c1[0] + (c1[1] - 1.0) * c1[2] + s * c1[3];
	cn[3] = psi * c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 35.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Novel Chaotic System Oscillator Images
***************************************************************************/

int	DoNovel(void)

    {
    double	i, c1[3], cn[3], a, b, c, k, p;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    k = param[3];
    p = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	p = -k * c1[0];
	k *= c1[0] * c1[0];
	cn[0] = a * c1[0] - c1[1] * c1[2] + p;
	cn[1] = -b * c1[1] + c1[0] * c1[2];
	cn[2] = -c * c1[2] + c1[0] * c1[1] / 3.0;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Novel Chaotic System without Equilibrium: Dynamics, Synchronization, and Circuit Realization
	Ahmad Taher Azar, Christos Volos, Nikolaos A. Gerodimos, George S. Tombras, Viet-Thanh Pham, 
	Ahmed G. Radwan, Sundarapandian Vaidyanathan, Adel Ouannas and Jesus M. Munoz-Pacheco 2 February 2017
***************************************************************************/

int	DoNovelChaoticSystemWithoutEquilibrium(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = -a * fabs(c1[0]) - c1[1] + 3.0 * c1[1] * c1[1] - c1[0] * c1[2] - b;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Novel Control Method for Integer Orders Chaos Systems via Fractional-Order Derivative
	Ping Zhou and Fei Kuang 3 March 2011
***************************************************************************/

int	DoNovelControl(void)

    {
    double	i, c1[4], cn[4];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 35.0 * (c1[1] - c1[0]) + c1[3];
	cn[1] = 7.0 * c1[0] - c1[0] * c1[2] + 12.0 * c1[1];
	cn[2] = c1[0] * c1[1] - 3.0 * c1[2];
	cn[3] = c1[1] * c1[2] + 0.5 * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Novel Dynamical Behaviors in Fractional-Order Conservative Hyperchaotic System and DSP Implementation
	Xiangxin Leng, Baoxiang Du, Shuangquan Gu  and Shaobo He May 2022
	hhttps://www.researchgate.net/requests/r101429562
***************************************************************************/

int	DoNovelDynamicalBehaviors(void)

    {
    double	i, c1[5], cn[5], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[1] * (1 - c1[2] * c1[2]);
	cn[1] = b * c1[2] + c1[0] * c1[4] - a * c1[0] * (1 - c1[2] * c1[2]);
	cn[2] = -c * c1[1] - d * c1[3];
	cn[3] = d * c1[2];
	cn[4] = -e * c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel Four-Wing Hyper-Chaotic System and Its Circuit Implementation
	Xue Wei, Fang Yunfei and Li Qiang December 2012
***************************************************************************/

int	DoNovel4WingHyperChaotic(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -(a * b / (a + b)) * c1[0] - c1[1] * c1[2];
	cn[1] = a * c1[1] + c1[0] * c1[2] + c1[3];
	cn[2] = b * c1[2] + c1[0] * c1[1] + c * c1[0] + c1[0] * c1[3];
	cn[3] = d * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Novel Four-wing Strange Attractor Born in Bistability
	Chunbiao LI, Ihsan  PEHLIVAN, Julien Clinton SPROTT and Akif Akgu Jan 03, 2017
***************************************************************************/

int	DoNovelFourWing(void)

    {
    double	i, c1[3], cn[3], a, b, m;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    m = param[2];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] + c1[1] + c1[1] * c1[2];
	cn[1] = -c1[0] * c1[2] + c1[1] * c1[2];
	cn[2] = -c1[2] - m * c1[0] * c1[1] + b;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Novel Grayscale Image Encryption Based on 4D Fractional-Order Hyperchaotic System, 2D Henon Map and Knight Tour Algorithm
	Saeed Ullah, Xinge Liu, Adil Waheed, Shuailei Zhang and Shan Li 8 August 2024
	https://iopscience.iop.org/article/10.1088/1402-4896/ad6d0e/pdf.....DOI 10.1088/1402-4896/ad6d0e
	Corresponding author: liuxgjiayou@126.com
***************************************************************************/

int	DoNovelGrayscaleImageEncryption(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e, f, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] + c1[1] * c1[2];
	cn[1] = b - c * c1[0] * c1[2] - cube(c1[1]);
	cn[2] = d * c1[0] * c1[1] + e * c1[2] + f * c1[3];
	cn[3] = c1[0] - g * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Novel Hyperjerk 4D System
	S. Valdyananthan - Book 2016
***************************************************************************/

int	DoNovelHyperjerk(void)

    {
    double	i, c1[4], cn[4], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = c1[3];
	cn[3] = 1.0 - a * c1[0] - c1[1] * c1[1] - c1[2] * c1[2] - b * c1[2] - c * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Novel Multi-wing Fractional-order Chaotic System, its Synchronisation Control and Application in Secure Communication
	Manashita Borah and Binoy K. Roy 21 March 2017
	Recieved from Binoy Krishna Roy via ResearchGate
***************************************************************************/

int	DoNovelMultiwingFractionalorderChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c, sm, w1, w2, w3;
    static double s[3], r[3];						// static to prevent bug when building in debug mode
    int		j;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    r[0] = param[3];
    r[1] = param[4];
    r[2] = param[5];
    s[0] = param[6];
    s[1] = param[7];
    s[2] = param[8];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	sm = 0.0;
	for (j = 0; j < 3; j++)
	    {
	    w1 = fabs(c1[1] + s[j]) / (c1[1] + s[j]);
	    w2 = fabs(c1[1] - s[j]) / (c1[1] - s[j]);
	    w3 = r[j] * (w1 - w2 - 2.0);
	    sm += w3;
	    }

	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = b * c1[1] - c1[0] * c1[2];
	cn[2] = c1[1] * c1[1] + sm - c;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Novel Strange Attractor and its Dynamic Analysis
	WU ZHONGTANG, MENGJIAO WANG, JIN JIANXIU, FENG JIUCHAO MARCH, 2014
***************************************************************************/

int	DoNovelStrange(void)

    {
    double	i, c1[3], cn[3], a, b, c, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    e = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = b * (c1[0] + c1[1]) - c1[0] * c1[2] * c1[2];
	cn[2] = -e * c1[0] - c * c1[2] + c1[0] * c1[0] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Novel Strange Attractor Minus Catastrophe Equations
	WU ZHONGTANG, MENGJIAO WANG, JIN JIANXIU, FENG JIUCHAO MARCH, 2014
***************************************************************************/

int	DoNovelMinusCatastrophe(void)

    {
    double	i, temp[3], c1[3], cn[3], a, b, c, d, e, xnew, ynew, znew, dx = -1.0;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    d = 0.0;

    a = param[0];
    b = param[1];
    c = param[2];
    e = param[3];    
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	// Novel
	xnew = a * (c1[1] - c1[0]);
	ynew = b * (c1[0] + c1[1]) - c1[0] * c1[2] * c1[2];
	znew = -e * c1[0] - c * c1[2] + c1[0] * c1[0] * c1[2];
	c1[0] += xnew*dt; c1[1] += ynew*dt; c1[2] += znew*dt;
	// catastrophe equations
	cn[0] = 3.0 * c1[0] * c1[0] + a + c * c1[1];
	cn[1] = 3.0 * c1[1] * c1[1] + b + c * c1[0];
	cn[2] = 3.0 * c1[2] * c1[2] + d + c * (sqrt(fabs(c1[0] + c1[1])) + (c1[0] + c1[1]) / 2.0) / 2.0;
	// subtract Catastrophe from Lorenz to form Catastrophic Chaotic Attractor
	temp[0] = c1[0]; temp[1] = c1[1]; temp[2] = c1[2];
	if (DisplayOscillator(temp, cn, dx, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Novel Three Dimension Autonomous Chaotic System as input data to Catastrophe's equations 
	Fei Yu  - Chunhua Wang & Marcus Rezende 28/01/2015
***************************************************************************/

int	DoNovel3DCatastrophe(void)

    {
    double	i, temp[3], c1[3], cn[3], a, b, c, d, v, k, xnew, ynew, znew, dx = 1.0;
    bool	multiply;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];    
    v = param[4];    
    k = param[5];    
    multiply = (param[6] != 0.0);
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	// Novel
	xnew = a * (c1[1] - c1[0]);
	ynew = b * c1[0] - c * c1[0] * c1[2] + k * c1[1] + v;
	znew = exp(c1[0] * c1[1]) - d * c1[2];
	c1[0] += xnew*dt; c1[1] += ynew*dt; c1[2] += znew*dt;
	// catastrophe equations
	cn[0] = 3.0 * c1[0] * c1[0] + a + c * c1[1];
	cn[1] = 3.0 * c1[1] * c1[1] + b + c * c1[0];
	cn[2] = 3.0 * c1[2] * c1[2] + d + c * (sqrt(fabs(c1[0] + c1[1])) + (c1[0] + c1[1]) / 2.0) / 2.0;
	// multiply Catastrophe from Lorenz to form Catastrophic Chaotic Attractor
	if (multiply)
	    {
	    temp[0] = c1[0] * cn[0]; temp[1] = c1[1] * cn[1]; temp[2] = c1[2] * cn[2];
	    }
	else
	    {
	    temp[0] = c1[0]; temp[1] = c1[1]; temp[2] = c1[2];
	    }
	if (DisplayOscillator(temp, cn, dx, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Numerical Analysis of a Simplest Fractional-Order Hyperchaotic System
	Dong Peng, Kehui Sun, Shaobo He, Limin Zhang and Abdulaziz O.A.Alamodi August 2019.
	Send directly by Shaobo He- provisory issue or this article in IEEE access
***************************************************************************/

int	DoNumericalAnalysisSimplestFractionalOrderHyperchaoticSystem(void)

    {
    double	i, c1[4], cn[4], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - c1[0];
	cn[1] = -c1[2] * fabs(c1[0]) / c1[0] + c1[3];
	cn[2] = fabs(c1[0]) - a;
	cn[3] = -b * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Numerical and Experimental Confirmations of Quasi-Periodic Behavior and Chaotic Bursting in Third-Order Autonomous Memristive Oscillator - Main
	B.C. Bao, P.Y. Wu, H. Bao, Q. Xu and M. Chen 23 November 2017
	https://www.researchgate.net/publication/322180834_Numerical_and_experimental_confirmations_of_quasi-periodic_behavior_and_chaotic_bursting_in_third-order_autonomous_memristive_oscillator
***************************************************************************/

int	DoNumericalExperimentalConfirmations(void)

    {
    double	i, c1[3], cn[3], a, b, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    k = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * log(((b * cosh(c1[1])))) - a * log(fabs(c1[0] + b));
	cn[1] = (k - 2.0) * c1[1] - (1.0 - 1.0 / k) * c1[2] - (c1[0] + b) * tanh(c1[1]);
	cn[2] = k * c1[1] - c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Numerical Sensitivity Analysis and Hardware Verification of a Transiently-Chaotic Attractor
	Wafaa S. Sayed, Sara M. Mohamed, Ahmed S. Elwakil, Lobna A. Said and Ahmed G. Radwan April 18, 2022
	https://www.researchgate.net/requests/r102426647 .....DOI: 10.1142/S0218127422501036
***************************************************************************/

int	DoNumericalSensitivityAnalysis(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] * c1[1] - c1[2] * c1[2];
	cn[1] = c1[0] * c1[2] - a * c1[0] * c1[1];
	cn[2] = c1[0] - b * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Numerical Simulation of a Class of Hyperchaotic System Using Barycentric Lagrange Interpolation Collocation Method-experiment 2
	Xiaofei Zhou, Junmei Li, Yulan Wang and Wei Zhang February 2019
	https://www.hindawi.com/journals/complexity/2019/1739785/
***************************************************************************/

int	DoNumericalSimulation(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[1] * c1[2];
	cn[1] = c * c1[0] - c1[1] - c1[0] * c1[2] + c1[3];
	cn[2] = c1[0] * c1[1] - b * c1[2];
	cn[3] = -c1[0] * c1[2] + d * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }


/**************************************************************************
	Nutrient-Phyloplankton-Zooplankton Images
	Complex Dynamics in a Harvested
	Nutrient-Phytoplankton-Zooplankton Model with Seasonality
	Chao Liu1, and Peiyong Liu 30 March 2014
***************************************************************************/

int	DoNutrient(void)

    {
    double	i, c1[3], cn[3], r0, k, a, r1, r2, C1, b1, d1, c2, d2, b2, h, q, e, w, g;

    c1[0] = param[10];	// n
    c1[1] = param[11];	// p
    c1[2] = param[12];	// z

    r0 = param[0];
    k = param[1];
    a = param[2];
    r1 = param[3];
    r2 = param[4];
    C1 = param[5];
    b1 = param[6];
    d1 = param[7];
    c2 = param[8];
    d2 = param[9];

    b2 = 0.5;
    h = 0.07;
    q = 0.1;
    e = 0.15;
    w = 2.0;
    g = 0.8;
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = r0 * (1.0 + g * sin(w * i)) * c1[0] * (1.0 - c1[0] / k) - a * c1[0] * c1[1] / (b1 + c1[0]) + r1 * c1[1] + r2 * c1[2];
	cn[1] = C1 * a * c1[0] * c1[1] / (b1 + c1[0]) - h * c1[1] * c1[2] / (b2 + c1[1]) - d1 * c1[1] - q * e * c1[1];
	cn[2] = c2 * h * c1[1] * c1[2] / (b2 + c1[1]) - d2 * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Oanceo Chaotic Attractor Images
***************************************************************************/

int	DoOanceo(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[1] * c1[2] * c1[3];
	cn[1] = b * (c1[0] + c1[1]) - c1[0] * c1[2] * c1[3];
	cn[2] = -c * c1[2] + c1[3] * c1[0] * c1[1];
	cn[3] = -d * c1[3] + c1[2] * c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Observer-Based Synchronisation of Chaotic Systems Satisfying Incremental Quadratic Constraints and Its Application in Secure Communication -the Bloch system
	Younan Zhao, Wei Zhang, Housheng Su and Junqi Yang September 2018
	https://www.researchgate.net/publication/327897041_Observer-Based_Synchronization_of_Chaotic_Systems_Satisfying_Incremental_Quadratic_Constraints_and_Its_Application_in_Secure_Communication
***************************************************************************/

int	DoObserverBasedSynchronisationChaoticSystems(void)

    {
    double	i, c1[3], cn[3], delta, lambda, psi, tau1, tau2;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    delta = param[0];
    lambda = param[1];
    psi = param[2];
    tau1 = param[3];
    tau2 = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = delta * c1[1] + lambda * c1[2] * (c1[0] * sin(psi) - c1[1] * cos(psi)) - c1[0] / tau1;
	cn[1] = -delta * c1[0] - c1[2] + lambda * c1[2] * (c1[0] * cos(psi) + c1[1] * sin(psi)) - c1[1] / tau2;
	cn[2] = c1[1] - lambda * (c1[0] * c1[0] + c1[1] * c1[1]) * sin(psi) - (c1[2] - 1) / tau1;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Occasional Uncoupling Overcomes Measure Desynchronisation
	Anupam Ghosh, Tirth Shah and Sagar Chakraborty1 12 May 2018
	Send by the authors
***************************************************************************/

int	DoOccasionalUncoupling(void)

    {
    double	i, c1[4], cn[4], kqq;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    kqq = param[0];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2];
	cn[1] = c1[3];
	cn[2] = -c1[0] * c1[0] * c1[0] + 3 * kqq * (c1[1] - c1[0]);
	cn[3] = -c1[1] * c1[1] * c1[1] + 2 * kqq * (c1[0] - c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Offset Boosting for Breeding Conditional Symmetry - ACS4 model
	Chunbiao Li, Julien Clinton Sprott, Yongjian Liu, Zhenyu Gu and Jingwei Zhang July 5, 2018
	Author Julien Clinton Sprott sent you the full-text you requested  https://www.researchgate.net/requests/r67303612
***************************************************************************/

int	DoOffsetBoostingBreedingConditionalSymmetry(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[0] * c1[2];
	cn[2] = -a * c1[0] * c1[1] - b * c1[0] * c1[2] - c1[0] * c1[0] + c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Olsen Chaotic Attractor Images
	RESEARCH: Chaos in Oscillating Chemical Reactions ' DUJS Online-2008
***************************************************************************/

int	DoOlsen(void)

    {
    double	i, c1[4], cn[4], a0, k1, k2, k3, k4, k5, k6, k7, k8;

    c1[0] = param[10];	// a
    c1[1] = param[11];	// b
    c1[2] = param[12];	// x
    c1[3] = param[13];	// y

    k1 = param[0];
    k2 = param[1];
    k3 = param[2];
    k4 = param[3];
    k5 = param[4];
    k6 = param[5];
    k7 = param[6];
    k8 = param[7];
    a0 = param[8];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = k7 * (a0 - c1[0]) - k3 * c1[0] * c1[1] * c1[3];
	cn[1] = k8 - k1 * c1[1] * c1[2] - k3 * c1[0] * c1[1] * c1[3];
	cn[2] = k1 * c1[1] * c1[2] - 2.0 * k2 * c1[2] * c1[2] + 3.0 * k3 * c1[0] * c1[1] * c1[3] - k4 * c1[2] + k6;
	cn[3] = 2.0 * k2 * c1[2] * c1[2] - k5 * c1[3] - k3 * c1[0] * c1[1] * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	On Offset Boosting in Chaotic System – Equation 7
	Chunbiao Li, Yicheng Jiang and Xu Ma 2 August 2021.
	https://www.researchgate.net/publication/353649236
***************************************************************************/

int	DoOnOffsetBoostingChaoticSystem7(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 1 - a * (fabs(c1[1]) - c) * c1[2];
	cn[1] = fabs(c1[1]) / c1[1] * (c1[2] * c1[2] - c1[2]);
	cn[2] = c1[0] + d - b * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	One Scroll Chaotic Attractor
	A New Four-Scroll Chaotic Attractor Consisted of Two-Scroll Transient Chaotic and Two-Scroll Ultimate Chaotic
	Yuhua Xu Bing Li, Yuling Wang, Wuneng Zhou, and Jian-an Fang
***************************************************************************/

int	DoOneScroll(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e, f, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[1] + b * c1[0] + c * c1[1] * c1[2];
	cn[1] = d * c1[1] - c1[2] + e * c1[0] * c1[2];
	cn[2] = f * c1[2] + g * c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	One-Way Coupled Van der Pol System
	Sangeeta Ghosh, B. Talukdar and U. Das 9 Oct 2009
***************************************************************************/

int	DoOneWayCoupledVanderPolSystem(void)

    {
    double	i, c1[4], cn[4], mu;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    mu = param[0];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = mu * (1.0 - c1[0] * c1[0]) * c1[1] - c1[0];
	cn[2] = c1[3];
	cn[3] = -mu * (1.0 - c1[1] * c1[0]) * c1[3] - c1[2];		// changed (1 - y * y) for this onein order to get more inteseting images
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	One to Four-Wing Chaotic Attractors Coined from a Novel 3D Fractional-Order Chaotic System with Complex Dynamics
	Zhang Sena, Zeng Yichenga and Li Zhijunb 13 April 2018
	https://www.researchgate.net/publication/323658236_One_to_four-wing_chaotic_attractors_coined_from_a_novel_3D_fractional-order_chaotic_system_with_complex_dynamics
***************************************************************************/

int	DoOne2FourWingChaoticAttractors(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    k = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] - c1[1] * c1[2] + c1[1];
	cn[1] = -b * c1[1] + c * c1[0] * c1[2] - d * c1[2] * c1[2];
	cn[2] = c1[0] - k * c1[2] + c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	On (non)Elementary Singularities in Liénard Systems
	Brigita Fercec July 2017
***************************************************************************/

int	DoOnNonElementarySingularities(void)

    {
    double	i, c[3], cn[3], a1, a3, c1, c3, c5;

    c[0] = param[10];	// x
    c[1] = param[11];	// y
    c[2] = param[12];	// z

    a1 = param[0];
    a3 = param[1];
    c1 = param[2];
    c3 = param[3];
    c5 = param[4];
    totpasses = 10;

    InitOscillator(c, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c[1];
	cn[1] = -(2.0 * a1 * c[0] + 3.0 * a3 * c[0] * c[0]) * c[1] - (c1 * c[0] + c3 * c[0] * c[0] * c[0] + c5 * c[0] * c[0] * c[0] * c[0] * c[0]);
	if (DisplayOscillator(c, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	On a 3-D Generalised Hamiltonian Model with Conservative and Dissipative Chaotic Flows
	Shijian Cang, Aiguo Wu, Zenghui Wang and Zengqiang Chen 21 March 2017
	Received from  Shijian Cang  through Research Gate
***************************************************************************/

int	DoOnA3DGeneralisedHamiltoniansModel(void)

    {
    double	i, c1[3], cn[3], a, b, c, u;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    u = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c * c1[0] + a * c1[1];
	cn[1] = -a * c1[0] - c1[1] * c1[2];
	cn[2] = -b * c1[2] + c1[1] * c1[1] - u;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	One to Four-Wing Chaotic Attractors Coined from a Novel 3D Fractional-Order Chaotic System with Complex Dynamics
	Shaobo He, Santo Banerjee and Bo Yan August 2018
	https://www.researchgate.net/publication/326865134_Chaos_and_Symbol_Complexity_in_a_Conformable_Fractional-Order_Memcapacitor_System
***************************************************************************/

int	DoOne2FourWingChaoticAttractorsCoinedNovel3DFractionalOrderChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a1, b1, a2, b2, c, d, e, f1z, f2y;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a1 = param[0];
    b1 = param[1];
    a2 = param[2];
    b2 = param[3];
    c = param[4];
    d = param[5];
    e = param[6];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	f1z = a1 * c1[2] + b1 * c1[2] * c1[2] * c1[2];
	f2y = a2 * c1[1] + b2 * c1[1] * c1[1] * c1[1];

	cn[0] = c * f1z;
	cn[1] = (d - e) * f2y + e * f1z;
	cn[2] = e * (f2y - f1z) - c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	On Different Families of Hidden Chaotic Attractors in Fractional Order Dynamical Systems
	Samuel Giovanni Hernández-Orbe, Jesús Manuel Muñoz-Pacheco, Germán Ardúl Muñoz-Hernández, Ernesto Zambrano-Serrano  2018
	Received by Jesus Manuel Munoz-Pacheco
***************************************************************************/

int	DoOnDifferentFamiliesHiddenChaoticAttractors(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] * c1[2] + a;
	cn[1] = c1[0] * c1[0] - c1[1];
	cn[2] = 1 - 4 * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	On the Formation of Hidden Chaotic Attractors and Nested Invariant Tori in the Sprott A System
	Marcelo Messias and Alisson C. Reinol 21 December 2016
	https://www.researchgate.net/publication/311867821_On_the_formation_of_hidden_chaotic_attractors_and_nested_invariant_tori_in_the_Sprott_A_system
***************************************************************************/

int	DoOnFormationHiddenChaoticAttractors(void)

    {
    double	i, c1[3], cn[3], a, b, c, r = 0.0;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 1; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	c = r * r - c1[0] * c1[0] - c1[1] * c1[1] - c1[1] * c1[1] * c1[1] * c1[1];
	b = 2.0 * c1[1] * c1[1];
	r = (-b + sqrt(fabs(b * b - 4.0 * a * c))) / 2.0;		// this 'r' is under a looping and not pre-defined
	cn[0] = c1[1];
	cn[1] = -c1[0] - c1[1] * c1[2];
	cn[2] = c1[1] * c1[1] - r;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	On the Transition to Hyperchaos and the Structure of Hyperchaotic Attractors
	K.P. Harikrishnan, R. Misra, and G. Ambika 23 September 2013
***************************************************************************/

int	DoOnTransition2Hyperchaos(void)

    {
    double	i, c1[3], cn[3], beta, gamma, scale;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    beta = param[0];
    gamma = param[1];
    scale = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = beta * c1[1] / (1.0 + pow(c1[1], 10)) - gamma * c1[0];
	cn[1] = (beta * c1[1] / (1.0 + pow(c1[1], 10)) - gamma * c1[0] - c1[1]) / dt;
	cn[2] = scale * (sqrt(sqr(sin(c1[0])) + sqr(cos(c1[1]))));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Optimal Linear Control Technical Applied in the Chaos Stabilisation in the Mathieu-Van Der Pol Autonomous Oscillator
	Fabio Roberto Chavarette1, Nelson Jose Peruzzi,Mara Lucia Martins Lopes and Antonio Marcos Cossi 2012
***************************************************************************/

int	DoOptimalLinearControl(void)

    {
    double	i, c1[4], cn[4], a, b, c, d = 0.0, e, f, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    e = param[3];
    g = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	f = -sin(c1[0]) * pow(e, (-0.1 * fabs(c1[0])));
	cn[0] = c1[1];
	cn[1] = -(a + b * c1[2]) * c1[0] - (a + b * c1[2]) * pow(c1[0], 3.0) - c * c1[1] + d * c1[2];
	cn[2] = c1[3];
	cn[3] = -e * c1[2] + f * (1.0 - c1[2] * c1[2]) * c1[3] + g * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Optimal Synchronisation of Circulant and Non-Circulant Oscillators I
	Shirin Panahi, Fahimeh Nazarimehr, Sajad Jafari, Julien C. Sprott, Matjaz Perc and Robert Repnik 22 November 2020
	http://www.matjazperc.com/publications/ApplMathComput_394_125830.pdf
***************************************************************************/

int	DoOptimalSynchronisationOscillatorsI(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 1 - c1[0] - c1[1] - a * fabs(c1[1]);
	cn[1] = 1 - c1[1] - c1[2] - a * fabs(c1[2]);
	cn[2] = 1 - c1[2] - c1[0] - a * fabs(c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Optimal Synchronisation of Circulant and Non-Circulant Oscillators II
	Shirin Panahi, Fahimeh Nazarimehr, Sajad Jafari, Julien C. Sprott, Matjaz Perc and Robert Repnik 22 November 2020
	http://www.matjazperc.com/publications/ApplMathComput_394_125830.pdf
***************************************************************************/

int	DoOptimalSynchronisationOscillatorsII(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = cube(c1[1]) - c1[2];
	cn[1] = cube(c1[2]) - c1[0];
	cn[2] = cube(c1[0]) - c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Orchestra Chaotic Attractor Images
	The analysis of complex behaviours of a novel three dimensional autonomous system 
	Dong Gao-Gao, Zheng Song, Tian Li-Xin, Du Rui-Jin and Sun Mei Received 25 January 2010 
***************************************************************************/

int	DoOrchestra(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e, f, g, h;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];
    h = param[7];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] * c1[2] - b * c1[0] + c * c1[1] * c1[2];
	cn[1] = c1[2] + d * c1[1] - e * c1[0] * c1[2];
	cn[2] = f * c1[0] * c1[1] - g * c1[2] - h * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Order-of-Chaos Attractor in 4 Dimensions Images
	On the Quantitative Aspects of the Asymmetry 
	Coefficients as Indicators of Order and Chaos 'Dumitru D. Deleanu
	11 - 14 June 2013 Istanbul, Turkey
***************************************************************************/

int	DoOrderChaos4D(void)

    {
    double	i, c1[4], cn[4];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2];
	cn[1] = c1[3];
	cn[2] = -c1[0] - 2.0 * c1[0] * c1[1];
	cn[3] = -c1[1] - c1[0] * c1[0] + c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Oregonator CNN  Near Chaos
	RESEARCH: Chaos in Oscillating Chemical Reactions DUJS Online-2008
***************************************************************************/

int	DoOregonator(void)

    {
    double	i, c1[3], cn[3], k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    k = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = (k - 1.0) / 2.0 * c1[0] - (2.0 + 2.0 * k) / (1.0 - k) * c1[1] - c1[0] * c1[1];
	cn[1] = -(3.0 + k) / 2.0 * c1[0] - 4.0 / (1.0 - k) * c1[1] + 2.0 * c1[2] - c1[0] * c1[1];
	cn[2] = c1[0] - c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Oyster Oscillator
	Chengjie - Chen, Jingqi Chen, Han Bao, M. Chen and Bocheng Bao 14 January 2019
	https://www.researchgate.net/publication/330368824
***************************************************************************/

int	DoOysterOscillator(void)

    {
    double	i, c1[3], cn[3], w;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    w = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = tanh(c1[1]);
	cn[1] = -w * w * c1[0] + cos(c1[0] * tanh(c1[1])) + sin(c1[0] * tanh(10 * c1[0]));
	cn[2] = sqrt(sqr(sin(c1[0])) + sqr(cos(c1[1])));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Pang Hyper-Chaotic Attractor in 4 Dimensions Images
***************************************************************************/

int	DoPang4D(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = c * c1[1] - c1[0] * c1[2] + c1[3];
	cn[2] = c1[0] * c1[1] - b * c1[2];
	cn[3] = -d * (c1[0] + c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Parallelising Boundary Surface Computation of Chua's Circuit
	Zsolt Racz and Milan Guzan April 2017
	https://www.researchgate.net/publication/317296506
***************************************************************************/

int	DoParallelisingBoundarySurfaceComputationChuasCircuit(void)

    {
    double	i, c1[3], cn[3], c, c2, r, l, bp, b0, ro, m0, m1, m2, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    c = param[0];
    c2 = param[1];
    r = param[2];
    l = param[3];
    bp = param[4];
    b0 = param[5];
    ro = param[6];
    m0 = param[7];
    m1 = param[8];
    m2 = param[9];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	g = m2 * c1[0] + 0.5 * (m1 - m0) * (fabs(c1[0] - bp) - fabs(c1[0] + bp)) + 0.5 * (m2 - m1) * (fabs(c1[0] - b0) - fabs(c1[0] + b0));
	cn[0] = (1 / r * (c1[1] - c1[0]) - g) / c;
	cn[1] = (1 / r * (c1[0] - c1[1]) + c1[2]) / c2;
	cn[2] = (-c1[1] - ro * c1[2]) / l;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Parameter Identification of Fractional-Order Discrete Chaotic Systems - Cat Map
	Yuexi Peng, Kehui Sun, Shaobo He and Dong Peng 1 January 2019
	Received from author
***************************************************************************/

int	DoParameterIdentificationFractionalOrderDiscreteChaoticSystems(void)

    {
    double	i, c1[3], cn[3], n, a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    n = param[0];
    a = param[1];
    b = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = fmod((c1[0] + a * c1[1]), n) - c1[0];
	cn[1] = fmod((b * c1[0] + (a * b + 1) * c1[1]), n) - c1[1];
	cn[2] = 30 * sin(c1[0]) + 30 * cos(c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Parameter-Independent Dynamical Behaviours in Memristor-Based Wien-Bridge Oscillator
	Ning Wang, Bocheng Bao, Tao Jiang, Mo Chen, and Quan Xu 26 December 2017
***************************************************************************/

int	DoParameterIndependentDynamicalBehaviors(void)

    {
    double	i, c1[4], cn[4], a, b, p, q, k, omega;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    p = param[2];
    q = param[3];
    k = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	omega = -p + q * fabs(c1[3]);
	cn[0] = -a * (c1[0] - c1[1]) - a * omega * c1[0];
	cn[1] = c1[0] + ((k - 1.0) * b - 1.0) * c1[1] - b * c1[2];
	cn[2] = b * (k * c1[1] - c1[2]);
	cn[3] = -a * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Peculiarities of Transition to Chaos in Nonideal Hydrodynamics Systems
	A. Yu. Shvets1 and V. A. Sirenko2 Accepted: 31 March 2012 ---2012 CMSIM
***************************************************************************/

int	DoPeculiarities(void)

    {
    double	i, c1[6], cn[6], pix = PI / 180.0;

    c1[0] = param[10];	// x1
    c1[1] = param[11];	// x2
    c1[2] = param[12];	// x3
    c1[3] = param[13];	// y1
    c1[4] = param[14];	// y2
    c1[5] = param[15];	// y3

    totpasses = 10;

    InitOscillator(c1, 6);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 10.0 * (-c1[0] + c1[1]);
	cn[1] = -c1[1] + 28.0 * c1[0] - c1[0] * c1[2];
	cn[2] = -8.0 / 3.0 * c1[2] + c1[0] * c1[1];
	cn[3] = -2.0 * c1[3] - c1[5] + 0.003 * c1[4] * c1[4] + c1[1] - 0.5 * cos(c1[1] * pix);
	cn[4] = -c1[3] - 2.0 * c1[4] + 5.0 * c1[0] + 0.01 * c1[0] * c1[0] * c1[0];
	cn[5] = c1[3] - c1[4] - 3.0 * c1[5] + 2.0 * tan((c1[0] + c1[4]) * pix / 2.0);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Pendulum (Non-ideal) Chaotic Oscillator Images
	Non-ideal Pendulum-3
	Delay Factors and Chaotization of Non-ideal Pendulum Systems ' Aleksandr Yu. Shvets and Alexander Makaseyev
	12 ? 15 June 2012, Athens Greece
***************************************************************************/

int	DoPendulum(void)

    {
    double	i, c1[3], cn[3], c, d, e, f, gamma, delta;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    c = param[0];
    d = param[1];
    e = param[2];
    f = param[3];
    gamma = param[4];
    delta = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 1.0 / (1.0 + c * delta) * (c * c1[0] - c1[1] * (c1[2] - gamma * (d * c1[1] + e * c1[2] + f)) - 1.0 / 8.0 
										    * (c1[0] * c1[0] * c1[1] + c1[1] * c1[1] * c1[1]));
	cn[1] = 1.0 / (1.0 + c * delta) * (c * c1[1] + c1[0] * c1[2] - c1[0] * gamma * (d * c1[1] + e * c1[2] + f) 
										    + 1.0 / 8.0 * (c1[0] * c1[0] * c1[0] + c1[0] * c1[1] * c1[1]) + 1.0);
	cn[2] = (1.0 - c * gamma) * d * c1[1] - d * gamma / 8.0 * (c1[0] * c1[0] * c1[0] + c1[0] * c1[1] * c1[1] + 8.0 * c1[0] * c1[2] + 8.0) + e * c1[2] + f;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Pendulum-Delayed Chaotic Oscillator Images
	Delay Factors and Chaotization of Non-ideal Pendulum Systems 
	Aleksandr Yu. Shvets and Alexander Makaseyev + MARCUS
***************************************************************************/

int	DoPendulumDelayed(void)

    {
    double	i, c1[3], cn[3], c, d, e, f, g, delta, gamma;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    c = param[0];
    e = param[1];
    f = param[2];
    d = param[3];
    g = param[4];
    gamma = param[5];
    delta = param[6];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c * c1[0] * (i - delta) - c1[1] * c1[2] * (i - gamma) - 1.0 / 8.0 * (c1[0] * c1[0] * c1[1] + c1[1] * c1[1] * c1[1]);
	cn[1] = c * c1[1] * (i - delta) + c1[0] * c1[2] * (i - gamma) + 1.0 / 8.0 * (c1[0] * c1[0] * c1[0] + c1[0] * c1[1] * c1[1]) + g;
	cn[2] = d * c1[1] * (i - gamma) + e * c1[2] + f;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Pendulum Diverse 4D Chaotic Oscillator Images
	'http://www.bentamari.com/attractors.html
***************************************************************************/

int	DoPendulumDiverse4D(void)

    {
    double	i, c1[4], cn[4], t1, t2, l1, l2;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    t1 = param[0];
    t2 = param[1];
    l1 = param[2];
    l2 = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = l1 * sin(t1 * i);
	cn[1] = -l1 * cos(t1 * i);
	cn[2] = l1 * sin(t1 * i) + l2 * sin(t2 * i);
	cn[3] = -l1 * cos(t1 * i) - l2 * cos(t2 * i);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i * 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Pendulum-Modified Chaotic Oscillator Images
	Construction of Dynamical Systems from Output 
	Regular and Chaotic Signals 
	Evgeniy D. Pechuk, Tatyana S. Krasnopolskaya + MARCUS
***************************************************************************/

int	DoPendulumModified(void)

    {
    double	i, c1[3], cn[3], f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    f = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -0.1 * c1[0] - c1[1] * c1[2] - 1.0 / 8.0 * (c1[0] * c1[0] * c1[1] + c1[1] * c1[1] * c1[1]);
	cn[1] = -0.1 * c1[1] + c1[0] * c1[2] + 1.0 / 8.0 * (c1[0] * c1[0] * c1[0] + c1[0] * c1[1] * c1[1]) + 1.0;
	cn[2] = -0.5 * c1[1] - 0.61  * c1[2] + f;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Pendulum Systems with Limited Excitation Images
	Chaos in Pendulum Systems with Limited Excitation in the Presence of Delay
	A.Yu. Shvets and O.M. Makasyeyev 7-10/7/2014
***************************************************************************/

int	DoPendulumSystems(void)

    {
    double	i, c1[3], cn[3], c, d, e, f, g, delta;

    c1[0] = param[10];	// x1
    c1[1] = param[11];	// x2
    c1[2] = param[12];	// x3

    c = param[0];
    d = param[1];
    e = param[2];
    f = param[3];
    g = param[4];
    delta = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 1.0 / (1.0 + c * delta) * (c * c1[0] - c1[1] * (c1[2] - g * (d * c1[1] + e * c1[2] + f)) - 1.0 / 8.0 * (c1[0] * c1[0] * c1[1] + c1[2] * c1[2] * c1[2]));
	cn[1] = 1.0 / (1.0 + c * delta) * (c * c1[1] + c1[0] * c1[2] - c1[0] * g * (d * c1[1] + e * c1[2] + f) + 1.0 / 8.0 * (c1[0] * c1[0] * c1[0] + c1[0] * c1[1] * c1[1]) + 1.0);
	cn[2] = (1.0 - c * g) * d * c1[1] - d * g / 8.0 * (c1[0] * c1[0] * c1[0] + c1[0] * c1[1] * c1[1] + 8.0 * c1[0] * c1[2] + 8) + e * c1[2] + f;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Performance-Enhancing of RSA Public Key via Three-Dimensional Hyperchaotic System-added 2 COS functions
	Nawras A. Alwan, Ahmed Y. Yousif and Nadia M.G. Al-Saidi February 2021
	https://www.researchgate.net/publication/349157880
***************************************************************************/

int	DoPerformanceEnhancingRSAPublicKey(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = b * b - a * c1[1] * cos(c1[2]);
	cn[1] = c1[0] * (b) +c1[1];
	cn[2] = c1[1] + c * c1[0] * cos(c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Period-Doubling Route to Chaos, Bistability and Antimononicity in a Jerk Circuit with Quintic Nonlinearity
	Justin Roger Mboupda Pone, Victor Kamdoum Tamba, Guillaume Honore Kom and Alain Bertin Tiedeu 11 April 2018
	Received from  Alain Bertin Tiedeu through Research Gate
***************************************************************************/

int	DoPeriodDoublingRoute2Chaos(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = a * c1[2];
	cn[2] = -b * c1[2] - c1[1] + c1[0] * c1[0] * c1[0] * c1[0] * c1[0] - c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Periodic Offset Boosting for Attractor Self-Reproducing
	Chunbiao Li, Yicheng Jiang, Ran Wang and Zuohua Liu 08 November 2021
	Sent particularly to ManpWIN by the first author
***************************************************************************/

int	DoPeriodicOffsetBoostingAttractorSelfReproducing(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[1] * c1[1] - 1;
	cn[1] = a * b * c1[2];
	cn[2] = 1.1 * sin(5 * PI * c1[0] / 11 + 3 * PI / 22) - c1[1] - c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Periodic Solution of a Higher Dimensional Ecological System
	Yonghui Xia, Huicheng Wang, Kit Ian Kou and Zhaoping Hu August 2016
	http://jaac.ijournal.cn/ch/reader/create_pdf.aspx?file_no=JAAC-6-3-739&year_id=2016&quarter_id=3&falg=1
***************************************************************************/

int	DoPeriodicSolutionHigherDimensionalEcologicalSystem(void)

    {
    double	t, c1[4], cn[4];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	cn[0] = c1[0] * (6.0 - (3.7 + sin(t)) * c1[0] - (1.0 + 1.0 / 20.0 * cos(t)) * c1[1]) - (1.0 + cos(t)) * c1[2] * c1[0];
	cn[1] = c1[1] * (8.0 - (5.0 / 2.0 + sin(t)) * c1[1] - (5.0 / 2.0 + cos(t)) * c1[1]) - 1.0 / 4.0 * c1[3] * c1[1];
	cn[2] = -(2.0 + 1.0 / 2.0 * cos(t)) * c1[2] + (1.0 + 1.0 / 10.0 * sin(t)) * c1[0];
	cn[3] = -(2.0 + sin(t)) * c1[2] + 1.0 / 4.0 * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 20.0) % threshold), t, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Periodically Forced Chaotic System with Signum Nonlinearity
	Kehui Sun and J. C. Sprott August 3, 2009
	http://thor.physics.wisc.edu/pubs/paper332.pdf
***************************************************************************/

int	DoPeriodicallyForcedChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, f, w;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    f = param[2];
    w = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -a * c1[0] + c1[0] - b * fabs(c1[0]) / c1[0] + f * sin(c1[2]);
	cn[2] = w;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Periodically Switched Memristor Initial Boosting Behaviors in Memristive Hypogenetic Jerk System
	HUAGAN WU, YI YE, MO CHEN, QUAN XU AND BOCHENG BAO October 17, 2019
	Sent through Research gate by the author Bocheng Bao
***************************************************************************/

int	DoPeriodicallySwitchedMemristor(void)

    {
    double	i, c1[4], cn[4], k = 0.0, ww;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	ww = 1 - 0.5 * sin(c1[3]);
	cn[0] = fabs(c1[1]) - 1.3;
	cn[1] = ww * c1[2];
	cn[2] = fabs(c1[0] + k) - c1[1] - .6 * c1[2] - 2;
	cn[3] = c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Perpetual Points and Periodic Perpetual Loci in Maps-in Cylindrical Coordinates
	Dawid Dudkowski, Awadhesh Prasad and Tomasz Kapitaniak 15 Sep 2016
***************************************************************************/

int	DoPerpetualPointsPeriodicPerpetualLoci(void)

    {
    double	i, c1[3], cn[3], x, y, z, xn, yn, zn;

    c1[0] = x = param[10];	// x
    c1[1] = y = param[11];	// y
    c1[2] = z = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	xn = y;
	yn = z;
	zn = -y + 3.0 * y * y - x * x - x * z - 0.2;

	x = x + xn * dt; y = y + yn * dt; z = z + zn * dt;

	c1[0] = x * sin(y) * cos(z);					// REM these new variables are the conversion from cylindrical coordinates to cartesian coordinates
	c1[1] = x * sin(y) * sin(z);
	c1[2] = x * cos(y);	    
	cn[0] = xn * sin(yn) * cos(zn); 
	cn[1] = xn * sin(yn) * sin(zn); 
	cn[2] = xn * cos(yn);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Phase Coherence and Attractor Geometry of Hyperchaotic Electrochemical Oscillators
	Yong Zou, Reik V. Donner, Mahesh Wickramasinghe, Istvan Z. Kiss, Michael Small and Jurgen Kurths 24 August 2012
***************************************************************************/

int	DoPhaseCoherence(void)

    {
    double	t, c1[4], cn[4], r, c, a, b, q, g1, g2, alpha, v, n, m, p, i, e = exp(1.0);

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    r = param[0];
    c = param[1];
    a = param[2];
    b = param[3];
    q = param[4];
    g1 = param[5];
    g2 = param[6];
    alpha = param[7];
    v = param[8];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	p = pow(e, (c1[0] / 2.0)); 
	m = p * p;
	n = m * m;
	i = (c * p / (1.0 + c * m) + a * m) * (1.0 - c1[1]);
	cn[0] = (v - c1[0]) / r - i;
	cn[1] = (p / (1.0 + c * m) * (1.0 - c1[1]) - b * c * c1[2] * m) / g1;
	cn[2] = (n * (c1[1] - c1[2]) - q * c * c1[2] * m) / g2 / alpha;
	cn[3] = e * c1[2] - cos(c1[3]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 20.0) % threshold), t, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Pickover Chaotic Oscillator Images
	http://www.bentamari.com/attractors.html
***************************************************************************/

int	DoPickoverOsc(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = sin(a * c1[0]) - c1[2] * cos(b * c1[1]);
	cn[1] = c1[2] * sin(c * c1[0]) - cos(d * c1[1]);
	cn[2] = sin(c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Piecewise Linear Transformation Fractal Map Implemented as an Oscillator
	WIKIPEDIA: DYadic Transformation  2015
***************************************************************************/

int	DoPiecewiseLinear(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	c1[0] = 1.0 - 2.0 * fabs(c1[0] - 0.5);
	if (c1[0] < 0.5)
	    {
	    cn[0] = 2.0 * c1[0];
	    cn[1] = (2.0 * c1[0] - c1[1]) / dt; 
	    }
	else
	    {
	    cn[0] = 2.0 * (c1[0] - 0.5);
	    cn[1] = (2.0 * (c1[0] - 0.5) - c1[1]) / dt;
	    }
	cn[2] = sqrt(sqr(sin(a*c1[0])) + sqr(cos(b*c1[1])));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i * 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Piecewise Linear Hyperchaotic Circuit
	Chunbiao Li, Julien Clinton Sprott, Wesley Thio, and Huanqiang Zhu DECEMBER 2014
***************************************************************************/

int	DoPiecewiseLinearHyperchaotic(int kind)

    {
    double	i, c1[4], cn[4], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - c1[0];
	switch (kind)
	    {
	    case 0:
		cn[1] = -c1[2] * fabs(c1[0]) / c1[0] + c1[3]; 
		cn[2] = fabs(c1[0]) - a;
		break;
	    case 1:
		cn[1] = -c1[2] * fabs(c1[0]) / c1[0] + c1[3]; 
		cn[2] = fabs(c1[0]) - a;
		break;
	    default:
		cn[1] = -c1[2] * fabs(c1[0]) / c1[0] + c1[3]; 
		cn[2] = fabs(c1[0]) - a;
		break;
	    }
	cn[3] = -b * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

int	DoPiecewiseLinearHyperchaoticI(void)
    {
    return DoPiecewiseLinearHyperchaotic(0);
    }
int	DoPiecewiseLinearHyperchaoticII(void)
    {
    return DoPiecewiseLinearHyperchaotic(1);
    }

/**************************************************************************
	Pinning Hybrid Synchronization of Time-Delay Hyperchaotic Lu Systems via Single Linear Control
	Jiawei Zhou, Zuolei Wang and Xuerong Shi January 12, 2017
***************************************************************************/

int	DoPinningHybridSynchronization(void)

    {
    double	i, c1[4], cn[4], a, b, c, alpha1, alpha2, tau;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    alpha1 = param[3];
    alpha2 = param[4];
    tau = param[5];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = c * c1[1] - c1[0] * c1[2] + c1[3] * (i - tau); 
	cn[2] = c1[0] * c1[1] - b * c1[2];
	cn[3] = -alpha1 * c1[0] - alpha2 * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	PolyWings Hyper-Chaotic Attractor in 4 Dimensions Images
	Novel four-dimensional autonomous chaotic system generating 
	one-, two-, three- and four-wing attractors 
	Yu Fei, Wang Chun-Hua, Yin Jin-Wen, and Xu Hao received 17 June 2011
***************************************************************************/

int	DoPolyWings4D(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e;
    int		NumWings;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    d = param[1];
    e = param[2];
    NumWings = (int)param[3];

    totpasses = 10;

    switch (NumWings)
	{
	case 1:
	    b = 14.0;
	    c = 56.0;
	    break;
	case 2:
	    b = 14.0;
	    c = 55.0;
	    break;
	case 3:
	    b = 12.0;
	    c = 53.5;
	    break;
	default:
	    b = 10.0;
	    c = 50.0;
	    break;
	}

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] * c1[2] - a * c1[0];
	cn[1] = b * c1[1] - c1[0] * c1[2];
	cn[2] = c1[0] * c1[1] - c * c1[2] + d * c1[3];
	cn[3] = c1[0] * c1[2] - e * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Predator-Prey System with Impulsive Perturbations Images
	Chaos in a Predator-Prey System with Impulsive Perturbations 
	and Stage Structure for the Predator
	Bin Zhang, Shuai Shi, and Woye Liu
***************************************************************************/

int	DoPredatorPrey(void)

    {
    double	i, c1[3], cn[3], r, k, m, a, b, d, v1, v2;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    r = param[0];
    a = param[1];
    b = param[2];
    k = param[3];
    m = param[4];
    d = param[5];
    v1 = param[6];
    v2 = param[7];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] * (r - a * c1[0] - b * c1[2] / (1.0 + m * c1[0]));
	cn[1] = k * b * c1[0] * c1[2] / (1.0 + m * c1[0]) - (d + v1) * c1[1];
	cn[2] = d * c1[1] - v2 * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Predictability of Threshold Exceedances in Dynamical Systems
	Tamas Bodai 7 sept 2015
***************************************************************************/

int	DoPredictabilityThresholdExceedance(void)

    {
    double	i, c1[3], cn[3], f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    f = param[0];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[1] * c1[1] - c1[2] * c1[2] - c1[0] / 4.0 + f / 4.0;
	cn[1] = c1[0] * c1[1] - 4.0 * c1[0] * c1[2] - c1[1] + 1.0;
	cn[2] = c1[0] * c1[2] + 4.0 * c1[0] * c1[1] - c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Prey-Predator-Top Predator Model
	Deterministic Chaos Versus Stochastic Oscillation in a Prey-Predator-Top Predator Model
	Ranjit Kumar Upadhyaya, Malay Banerjeeb, Rana Parshadc and Sharada Nandan Rawa August 1, 2011
***************************************************************************/

int	DoPreyPredatorTop(void)

    {
    double	t, c1[3], cn[3], a1, b1, w, i, a, a2, w1, w2, c, w3;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a1 = param[0];
    b1 = param[1];
    w = param[2];
    i = param[3];
    a = param[4];
    a2 = param[5];
    w1 = param[6];
    w2 = param[7];
    c = param[8];
    w3 = param[9];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	cn[0] = c1[0] * (a1 - b1 * c1[0] - w * c1[1] / (c1[0] * c1[0] / i + c1[0] + a));
	cn[1] = c1[1] * (w1 * c1[0] / (c1[0] * c1[0] / i + c1[0] + a) - a2 - w2 * c1[2] / (c1[1] * c1[1] / i + c1[1] + a));
	cn[2] = c1[2] * (w3 * c1[1] / (c1[1] * c1[1] / i + c1[1] + a) - c);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 10.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Probabilistic Concepts in a Changing Climate: A Snapshot Attractor Picture I
	GABOR DROTOS,TAMAS BODAI, TAMAS TEL 29 October 2014
***************************************************************************/

int	DoProbabilisticConceptsI(void)

    {
    double	t, c1[3], cn[3], a, b, g, f, f0, w, azao;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    g = param[2];
    f0 = param[3];
    azao = param[4];
    w = 2.0 * PI / 73.0;

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	f = f0 + azao * sin(w * t);
	cn[0] = -c1[1] * c1[1] - c1[2] *  c1[2] - a * c1[0] + a * f;
	cn[1] = c1[0] * c1[1] - b * c1[0] * c1[2] - c1[1] + g;
	cn[2] = c1[0] * c1[2] + b * c1[0] * c1[1] - c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 10.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Probabilistic Concepts in a Changing Climate: A Snapshot Attractor Picture II
	Dr. V. Sundarapandian  & Marcus Rezende 5 May 2011 / 02 April 2015
***************************************************************************/

int	DoProbabilisticConceptsII(void)

    {
    double	t, c1[3], cn[3], a, b, g, f, tst;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    g = param[2];
    tst = param[3];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	f = (t < tst) ? 9.5 : 9.5 - 2.0 / tst * (t - tst);
	cn[0] = -c1[1] * c1[1] - c1[2] *  c1[2] - a * c1[0] + a * f;
	cn[1] = c1[0] * c1[1] - b * c1[0] * c1[2] - c1[1] + g;
	cn[2] = c1[0] * c1[2] + b * c1[0] * c1[1] - c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 10.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Prototypes of Attractors in Four Dimensions
	G. Baier, J. S. Thomsen 16, September, 1993
***************************************************************************/

int	DoPrototypesAttractors4D(void)

    {
    double	t, c[3], cn[3], k1, k2, c1, c2, b;

    c[0] = param[10];	// x
    c[1] = param[11];	// y
    c[2] = param[12];	// z

    k1 = param[0];
    k2 = param[1];
    b = param[2];
    c1 = param[3];
    c2 = param[4];

    totpasses = 10;

    InitOscillator(c, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	cn[0] = c[1];
	cn[1] = k1 * c[1] - c[0] * c[0] * c[0] + b * cos(t) - c1 * c[2];
	cn[2] = k2 * c[2] - c2 * c[0];
	if (DisplayOscillator(c, cn, dt, ((DWORD)(t / 25.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Pseudo-Random Number Generator based on a Generalised Conservative Sprott-A System
	Shijian Cang, Zhijun Kang and  Zenghui Wang 11 February 2021
	https://www.researchgate.net/publication/349425489
***************************************************************************/

int	DoPseudoRandomNumberGenerator(void)

    {
    double	t, c[3], cn[3], k;

    c[0] = param[10];	// x
    c[1] = param[11];	// y
    c[2] = param[12];	// z

    k = param[0];
    totpasses = 10;

    InitOscillator(c, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	cn[0] = c[1] * (c[1] * c[1] - 4);
	cn[1] = -c[0] + c[1] * c[2];
	cn[2] = -pow(c[1], 4) + 4 * c[1]  * c[1] + k;
	if (DisplayOscillator(c, cn, dt, ((DWORD)(t / 25.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Pulse Excited Chaotic Oscillator Images
	PULSE-EXCITED RC NONAUTONOMOUS CHAOTIC OSCILLATOR STRUCTURES
	A. S. ELWAKIL, S. OZOGUZ June 1, 2004
***************************************************************************/

int	DoPulseExcited(void)

    {
    double	i, c1[3], cn[3], k1, k2, kp, kf, fi, n, f, p; 
    bool	multiply;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    k1 = param[0];
    k2 = param[1];
    kp = param[2];
    kf = param[3];
    fi = param[4];
    n = param[5];
    multiply = (param[6] != 0);

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	f = ((k1 * c1[0] - k2 * c1[1]) >= 0) ? 1.0 : -1.0;
	p = (sin((multiply ? fi*i : fi)) >= 0) ? 1.0 : -1.0;
	cn[0] = -(kf + kp - k1 + 1) * c1[0] - k2 * c1[1] + kf * f + kp * p;
	cn[1] = (n + (1 - k1) * (1 - k1)) / k2 * c1[0] + (1 - k1) * c1[1];
	cn[2] = c1[0] - c1[0] * c1[0] - c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Qi-3D Chaotic Attractor Images
***************************************************************************/

int	DoQi3D(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + e * c1[1] * c1[2];
	cn[1] = c * c1[0] + d * c1[1] - c1[0] * c1[2];
	cn[2] = c1[0] * c1[1] - b * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Qi-Chen Chaotic Attractor Images
***************************************************************************/

int	DoQiChen(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[1] * c1[2];
	cn[1] = c * c1[0] + c1[1] - c1[0] * c1[2];
	cn[2] = c1[0] * c1[1] - b * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Qi-Slave Chaotic Attractor Images
***************************************************************************/

int	DoQiSlave(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[1] * c1[2];
	cn[1] = b * (c1[0] + c1[1]) - c1[0] * c1[2];
	cn[2] = -c * c1[2] - e * c1[3] + c1[0] * c1[1];
	cn[3] = -d * c1[3] + f * c1[2] + c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Qi-Slave and Marcus Chaotic Attractor Images
***************************************************************************/

int	DoQiSlaveMarcus(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e, f, r, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    k = param[6];
    r = param[7];
    totpasses = 10;

    InitOscillator(c1, 4);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + e * c1[1] * c1[2] - k * c1[3];
	cn[1] = c * c1[0] - d *  c1[1] - c1[0] * c1[2];
	cn[2] = -b * c1[2] + c1[0] * c1[1];
	cn[3] = r * c1[0] + f * c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Quadratic Chaotic Attractor Images
***************************************************************************/

int	DoQuadratic(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = -a * c1[2] + c1[1] * c1[1] - c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Quadratic Equations Images
	GENERATING CHAOS IN 3D SYSTEMS OF QUADRATIC DIFFERENTIAL EQUATIONS
	WITH 1D EXPONENTIAL MAPS VASILIY YE. BELOZYOROV, SERGEY V. CHERNYSHENKO
	November 1, 2012
***************************************************************************/

int	DoQuadraticEquations(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x1
    c1[1] = param[11];	// x2
    c1[2] = param[12];	// x3

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 3.0 * c1[0] + 10.0 * c1[1] + 2 * c1[0] * c1[0] + 2.0 * c1[0] * c1[1] + c1[0] * c1[2] - c1[1] * c1[1] + c1[2] * c1[2];
	cn[1] = -10.0 * c1[0] + 3.0 * c1[1] - c1[0] * c1[0] + 2.0 * c1[0] * c1[1] + c1[1] * c1[2] + c1[1] * c1[1] - c1[2] * c1[2];
	cn[2] = c1[2] * c1[2] + 2.0 * c1[0] * c1[2] + 3.0 * c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Quantum Cellular Neural Network Model
	Hyperchaotic Behavior in Arbitrary-Dimensional
	Fractional-order Quantum Cellular Neural Network Model
	Ling Liu, Chongxin Liu and Deliang Liang July 11, 2012
***************************************************************************/

int	DoQuantumCellular(void)

    {
    double	i, c1[4], cn[4], beta1, beta2, teta1, teta2, s1, s2;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    beta1 = param[0];
    beta2 = param[1];
    teta1 = param[2];
    teta2 = param[3];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	s1 = sqrt(fabs(1.0 - c1[0] * c1[0]));
	cn[0] = -2.0 * teta1 * s1 * sin(c1[1]);
	cn[1] = -beta1 * (c1[0] - c1[2]) + 2.0 * teta1 * c1[0] / s1 * cos(c1[1]);
	s2 = sqrt(fabs(1.0 - c1[2] * c1[2]));
	cn[2] = -2.0 * teta2 * s2 * sin(c1[3]);
	cn[3] = -beta2 * (c1[2] - c1[0]) + 2.0 * teta2 * c1[2] / s2 * cos(c1[3]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Quasiperiodicity and Suppression of Multistability in Nonlinear Dynamical Systems
	Ying-Cheng Lai and Celso Grebogi April 14, 2017
	https://arxiv.org/pdf/1704.03938.pdf
***************************************************************************/

int	DoQuasiperiodicitySuppressionMultistability(void)

    {
    double	i, c1[3], cn[3], k, v, p, w1, w2;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    k = param[0];
    v = param[1];
    p = param[2];
    w1 = param[3];
    w2 = param[4];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = p * (k + v * (cos(w1 / w2 * c1[2]) + cos(c1[2])) + cos(c1[0]) - c1[1]);
	cn[2] = w2;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Rabbits and Foxes Images
	Predator-Prey Modeling
	Shaza Hussein 2010 
***************************************************************************/

int	DoRabbitsAndFoxes(void)

    {
    double	i, c1[3], cn[3], ar, af, br, bf;

    c1[0] = param[10];	// Rabbits
    c1[1] = param[11];	// Foxes
    c1[2] = param[12];	// z

    ar = param[0];	// birth rabbits
    af = param[1];	// birth foxes
    br = param[2];	// death rabbits
    bf = param[3];	// death foxes
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = ar * c1[0] - br * c1[0] * c1[1];
	cn[1] = af * c1[0] * c1[1] - bf * c1[1];
	cn[2] = sqrt(sqr(2.0 * sin(c1[0])) + sqr(2.0 * cos(c1[1])));
//	cn[2] = c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Rabinovich-Fabrikant Limited Cycle Chaotic Images
	Rabinovich-Fabrikant equations
	http://en.wikipedia.org/wiki/Rabinovich%E2%80%93Fabrikant_equations
	the site above corrects the formulae for 'xn3' 1979
***************************************************************************/

int	DoRabinovich(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x1
    c1[1] = param[11];	// x2
    c1[2] = param[12];	// x3

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1] * (sqr(c1[0]) - 1.0) - a * c1[0];
	cn[1] = c1[0] * (3.0 * c1[2] + 1.0 - sqr(c1[0])) + a * c1[1];
	cn[2] = -2.0 * c1[2] * (b + c1[0] * c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Rabinovich–Fabrikant System-IV
***************************************************************************/

int	DoRabinovichSystemIV(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1] * (c1[2] - 1 + sqr(c1[0])) + a * c1[0];
	cn[1] = c1[0] * (3.0 * c1[2] + 1.0 - sqr(c1[0])) + a * c1[1];
	cn[2] = -2.0 * c1[2] * (b + c1[0] * c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Rayleigh-Bénard Chemical Oscillator Images
***************************************************************************/

int	DoRayleighBenard(void)

    {
    double	i, c1[3], cn[3], a, r, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    r = param[1];
    b = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = -a * c1[0] + a * c1[1];
	cn[1] = r * c1[0] - c1[1] - c1[0] * c1[2];
	cn[2] = c1[0] * c1[1] - b * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Rayleigh-Bénard Convection Model in 9 Dimensions Images
***************************************************************************/

int	DoRayleighBenard9D(void)

    {
    double	i, c[9], cn[9], r, a, s, b1, b2, b3, b4, b5, b6;

    c[0] = param[10];	// x1
    c[1] = param[11];	// y1
    c[2] = param[12];	// z1
    c[3] = param[13];	// x2
    c[4] = param[14];	// y2
    c[5] = param[15];	// z2
    c[6] = param[16];	// x3
    c[7] = param[17];	// y3
    c[8] = param[18];	// z3

    r = param[0];
    a = param[1];
    s = param[2];
    totpasses = 10;
    InitOscillator(c, 9);						// pass in number of dimensions

    b1 = 4.0 * (1.0 + a * a) / (1.0 + 2.0 * a * a);
    b2 = (1.0 + 2.0 * a * a) / (2.0 * (1.0 + a * a));
    b3 = 2.0 * (1.0 - a * a) / (1.0 + a * a);
    b4 = a * a / (1.0 + a * a);
    b5 = 8.0 * a * a / (1.0 + 2.0 * a * a);
    b6 = 4.0 / (1.0 + 2.0 * a * a);

    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = -s * b1 * c[0] - c[1] * c[3] + b4 * c[3] * c[3] + b3 * c[2] * c[4] - s * b2 * c[6];
	cn[1] = -s * c[1] + c[0] * c[3] - c[1] * c[4] + c[3] * c[4] - s * c[8] / 2.0;
	cn[2] = -s * b1 * c[2] + c[1] * c[3] - b4 * c[1] * c[1] - b3 * c[0] * c[4] + s * b2 * c[7];
	cn[3] = -s * c[3] - c[1] * c[2] - c[1] * c[4] + c[3] * c[4] + s * c[8] / 2.0;
	cn[4] = -s * b5 * c[4] + c[1] * c[1] / 2.0 - c[3] * c[3] / 2.0;
	cn[5] = -b6 * c[5] + c[1] * c[8] - c[3] * c[8];
	cn[6] = -b1 * c[6] - r * c[0] + 2.0 * c[4] * c[7] - c[3] * c[8];
	cn[7] = -b1 * c[7] + r * c[2] - 2.0 * c[4] * c[6] + c[1] * c[8];
	cn[8] = -c[8] - r * c[1] + r * c[3] - 2.0 * c[1] * c[5] + 2.0 * c[3] * c[5] + c[3] * c[6] - c[1] * c[7];
	if (DisplayOscillator(c, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 9, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Recent New Examples of Hidden Attractors-Case A
	S. Jafari, J.C. Sprott and F. Nazarimehr 27 July 2015
***************************************************************************/

int	DoRecentNewHiddenAttractors(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;
    InitOscillator(c1, 3);						// pass in number of dimensions

    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1];
	cn[1] = -c1[0] + c1[1] * c1[2];
	cn[2] = 1.0 - c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Research on a New 3D Autonomous Chaotic System with Coexisting Attractors
	Qiang Lai and Shiming Chen 5 December 2015
	https://www.researchgate.net/requests/r46443226
***************************************************************************/

int	DoResearchNew3DAutonomousChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    k = param[3];
    totpasses = 10;
    InitOscillator(c1, 3);						// pass in number of dimensions

    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = b * c1[1] * c1[2] - c * c1[0];
	cn[2] = k - c1[1] * c1[1] - c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Research on a 3D Predator-Prey Evolutionary System in Real Estate Market
	Yujing Yang and Wenzhe Tang 26 February 2018
	https://www.hindawi.com/journals/complexity/2018/6154940/
***************************************************************************/

int	DoResearch3DPredatorPreyEvolutionarySystem(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e, f, g, h, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];
    h = param[7];
    k = param[8];
    totpasses = 10;
    InitOscillator(c1, 3);						// pass in number of dimensions

    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] * (1.0 - c1[0]) - c1[0] * c1[1] / (c1[0] + a);
	cn[1] = -b * c1[1] + c * c1[0] * c1[1] / (c1[0] + d) - c1[1] * c1[2] / (c1[1] + e * c1[2] + f);
	cn[2] = g * c1[2] * c1[2] - h * c1[2] * c1[2] / (c1[1] + k);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Research on Grid Scroll Chaotic Extended Sequence Algorithm and Its Circuit Implementation for F-OFDM System
	Yingjie Ma, Ya Li, Geng Zhao, Ping Zeng and Yatao Yang 28 November 2019
	https://www.hindawi.com/journals/complexity/2019/5904801/
***************************************************************************/

int	DoResearchGridScrollChaoticExtendedSequenceAlgorithm(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;
    InitOscillator(c1, 3);						// pass in number of dimensions

    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - a * fabs(c1[1]) / c1[1];
	cn[1] = c1[2] - b * fabs(c1[2]) / c1[2];
	cn[2] = -c * c1[0] - c * c1[1] - d * c1[2] + e * fabs(c1[0] + c1[1]) / (c1[0] + c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Resonance and chaotic trajectories in magnetic field reversed configuration Images
	A.S. Landsman, S.A. Cohen, M. Edelman, G.M. Zaslavsky accepted 9 January 2004
***************************************************************************/

int	DoResonance(void)

    {
    double	i, c1[4], cn[4], p, b;

    c1[0] = param[10];    // r
    c1[1] = param[11];    // z
    c1[2] = param[12];    // m
    c1[3] = param[13];    // w

    p = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2];
	cn[1] = c1[3];
	cn[2] = -c1[0] * (1.0 + 2.0 * p) + p * p / c1[0] * c1[0] * c1[0] + 4.0 * c1[0] * c1[0] * c1[0] 
		- 3.0 * c1[0] * c1[0] * c1[0] * c1[0] * c1[0] - b * b * c1[1] * c1[1] * (4.0 * c1[0] * c1[0] * c1[0] - 2.0 * c1[0] + b * b * c1[1] * c1[1] * c1[0]);
	cn[3] = -2.0 * p * p * c1[1] * (p - c1[0] * c1[0] * (1.0 - c1[0] * c1[0] - b * b * c1[1] * c1[1]));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Retailers Dynamics System Images
	The Study of the Chaotic Behavior in Retailers Dynamics System
	Junhai Ma and Yun Feng 14 September 2008
***************************************************************************/

int	DoRetailersDynamics(void)

    {
    double	i, c1[3], cn[3], q, b1, b2, d1, d2, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    q = param[0];
    b1 = param[1];
    b2 = param[2];
    d1 = param[3];
    d2 = param[4];
    e = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] * (1.0 - c1[0] - c1[1] / (b1 + c1[0])) / q;
	cn[1] = c1[1] * (c1[0] / (b1 + c1[0]) - d1 - c1[2] / (b2 + c1[1]));
	cn[2] = e * c1[2] * (c1[1] / (b2 + c1[1]) - d2);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Riddled Attraction Basin and Multistability in Three-Element-Based Memristive Circuit
	Quan Xu, Xiao Tan, Yunzhen Zhang, Han Bao, Yihua Hu, Bocheng Bao and Mo Chen August 2020
	Sent to ManpWIN by Mo Chen through https://www.researchgate.net/publication/343904267_Riddled_Attraction_Basin_and_Multistability_in_Three-Element-Based_Memristive_Circuit
***************************************************************************/

int	DoRiddledAttractionBasinMultistability(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    f = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (1 - b * c1[1] * c1[1]) * c1[0] - c * exp(-c1[2]) * sinh(c1[0]);
	cn[1] = -c1[0] - d * c1[1];
	cn[2] = c * exp(-c1[2]) * cosh(c1[0]) - c - c1[3];
	cn[3] = f * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Rikitake Chaotic Attractor Images
***************************************************************************/

int	DoRikitake(void)

    {
    double	i, c1[3], cn[3], a, s, U;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    s = param[1];
    U = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = -U * c1[0] + s * c1[1] * c1[2];
	cn[1] = -U * c1[1] + (s * c1[2] - a) * c1[0];
	cn[2] = 1.0 - s * c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Rikitake Attractor in 4 Dimensions and its Synchronisation Application for Secure Communication Systems
	IHSAN PEHLIVAN AND YILMAZ UYAROGLU 2007
***************************************************************************/

int	DoRikitake4D(void)

    {
    double	i, c1[4], cn[4], mu, a, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    mu = param[0];
    a = param[1];
    k = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = -mu * c1[0] + c1[2] * c1[1];
	cn[1] = -mu * c1[0] + (c1[2] - a) * c1[0];
	cn[2] = 1.0 - c1[0] * c1[1];
	cn[3] = (1.0 - 3.0 * c1[2] * c1[2] - k) - c1[2] * k * c1[3] * c1[1] * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Robust Adaptive Synchronisation of the Energy Resource System with Constraint
	DuoMeng 5 June 2013
***************************************************************************/

int	DoRobustAdaptive(void)

    {
    double	i, c[3], cn[3], m, n, a1, a2, b1, b2, b3, c1, c2, c3;

    c[0] = param[10];	// x
    c[1] = param[11];	// y
    c[2] = param[12];	// z

    m = param[0];
    n = param[1];
    a1 = param[2];
    a2 = param[3];
    b1 = param[4];
    b2 = param[5];
    b3 = param[6];
    c1 = param[7];
    c2 = param[8];
    c3 = param[9];
    totpasses = 10;

    InitOscillator(c, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = a1 * c[0] * (1.0 - c[0] / m) - a2 * (c[1] + c[2]);
	cn[1] = -b1 * c[1] - b2 * c[2] + b3 * c[0] * (n - (c[0] - c[2]));
	cn[2] = c1 * c[2] * (c2 * c[0] - c3);
	if (DisplayOscillator(c, cn, dt, ((DWORD)(i / 16.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Robust Multiple-Scroll Dynamics in Memristive-Based Generator System
	A. O. Adelakun and Y. A. Odusote 22 May 2023
	https://www.nature.com/articles/s41598-023-34423-1.....https://doi.org/10.1038/s41598-023-34423-1
	Corresponding Author: aoadelakun@futa.edu.ng <aoadelakun@futa.edu.ng>;
***************************************************************************/

int	DoRobustMultipleScrollDynamics(void)

    {
    double	i, c1[4], cn[4], a, b, c, e, alpha, beta, epsilon, fz, fw;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    e = param[3];
    alpha = param[4];
    beta = param[5];
    epsilon = param[6];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	fz = c1[2] + alpha * sin(c1[2]);
	fw = c1[3] + alpha * sin(c1[3]);

	cn[0] = a * c1[1];
	cn[1] = -c1[0] + c1[1] * (b * fz + c * fw);
	cn[2] = e - c1[1] * c1[1];
	cn[3] = c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 16.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Robust Synchronisation of Hyperchaotic Systems
	Robust Synchronisation of Fractional-Order Hyperchaotic Systems 
	Subjected to Input Nonlinearity and Unmatched External Perturbations
	Teh-Lu Liao, Jun-Juh Yan, and Jen-Fuh Chang 10 April 2014
***************************************************************************/

int	DoRobustSynchronisation(void)

    {
    double	i, c1[4], cn[4], a, b1, b2, b3, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b1 = param[1];
    b2 = param[2];
    b3 = param[3];
    c = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = a * c1[0] - c1[1];
	cn[1] = c1[0] - c1[1] * c1[2] * c1[2];
	cn[2] = -b1 * c1[1] - b2 * c1[2] - b3 * c1[3];
	cn[3] = c1[2] + c * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 16.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Rossler Chaotic Attractor Images
***************************************************************************/

int	DoRossler(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = -c1[1] - c1[2];
	cn[1] = c1[0] + a * c1[1];
	cn[2] = b + c1[2] * (c1[0] - c);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 3.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Rossler-Like System - II Images
	Hopf Bifurcation Analysis and Anticontrol of Hopf Circles of the 
	Rossler-Like System Ranchao Wu and Xiang Li 20 June 2012
***************************************************************************/

int	DoRosslerLike(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = -c1[1] - c1[2];
	cn[1] = c1[0] + c * c1[2];
	cn[2] = a * c1[1] - b * c1[2] - c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 3.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Rössler Prototype-4 System Based on Chua’s Diode Nonlinearity : Dynamics, Multistability, Multiscroll Generation and FPGA Implementation
	Paul Didier Kamdem Kuatea, Achille Ecladore Tchahou Tchendjeu and Hilaire Fotsin 17 August 2020
	Received from Achille Ecladore Tchahou Tchendjeu through https://www.researchgate.net/requests/r78054054
***************************************************************************/

int	DoRosslerPrototype4System(void)

    {
    double	i, c1[3], cn[3], a, b, c, m0, m1, gy;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    m0 = param[3];
    m1 = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	gy = m1 * c1[1] + 0.5 * (m0 - m1) * (fabs(c1[1] + 1) - fabs(c1[1] - 1));
	cn[0] = c1[1] + a * c1[2];
	cn[1] = -b * c1[0];
	cn[2] = gy - c * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 3.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Rucklidge Chaotic Attractor Images
***************************************************************************/

int	DoRucklidge(void)

    {
    double	i, c1[3], cn[3], a, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    k = param[0];
    a = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = -k * c1[0] + a * c1[1] - c1[1] * c1[2];
	cn[1] = c1[0];
	cn[2] = -c1[2] + c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Russian Pendulum
	Construction of Dynamical Systems from Output Regular and Chaotic Signals
	Evgeniy D. Pechuk, Tatyana S. Krasnopolskaya
***************************************************************************/

int	DoRussianPendulum(void)

    {
    double	i, c1[3], cn[3], c, e, f, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    c = param[0];
    e = param[1];
    f = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c * c1[0] - c1[1] * c1[2] - 0.125 * (c1[0] * c1[0] * c1[1] + c1[1] * c1[1] * c1[1]);
	cn[1] = c * c1[1] + c1[0] * c1[2] + 0.125 * (c1[0] * c1[0] * c1[0] + c1[0] * c1[1] * c1[1]);
	cn[2] = d * c1[1] + e * c1[2] + f;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Safieddine Chaotic Attractor Images
***************************************************************************/

int	DoSafieddine(void)

    {
    double	i, c1[3], cn[3], a, b, g, m;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z

    a = param[0];
    b = param[1];
    m = param[2];
    g = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] * (1.0 - c1[1]) - b * c1[2];
	cn[1] = -g * c1[1] * (1.0 - c1[0] * c1[0]);
	cn[2] = m * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Saito Chaotic Attractor Images
	"AntiSynchronisation in coupled chaotic oscillators" -Physics Letters A 354 (2006) 119–125
***************************************************************************/

int	DoSaito(void)

    {
    double	i, c1[3], cn[3], mu, alfa, alfa1, alfa2, beta, m, fze;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alfa = param[0];
    alfa1 = param[1];
    alfa2 = param[2];
    beta = param[3];
    mu = param[4];
    m = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = mu * (c1[1] - c1[0] - c1[2]);
	cn[1] = (1.0 - 1.0 / alfa) * c1[1] - c1[0];
	fze = alfa1 * c1[2] + alfa2 * (fabs(c1[2] + m) - fabs(c1[2] - m));
	cn[2] = beta * (c1[0] - fze);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Sakarya Chaotic Attractor Images
***************************************************************************/

int	DoSakarya(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = -c1[0] + c1[1] + c1[1] * c1[2];
	cn[1] = -c1[0] - c1[1] + a * c1[0] * c1[2];
	cn[2] = c1[2] - b * c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Scenario of the Birth of Hidden Attractors in the Chua Circuit
	Nataliya V. Stankevich, Nikolay V. Kuznetsov, Gennady A. Leonov and Leon O. Chua 13 Oct 2017
	https://www.researchgate.net/publication/320296805
***************************************************************************/

int	DoScenarioBirthHiddenAttractors(void)

    {
    double	i, c1[3], cn[3], alpha, beta, gamma, m0, m1, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alpha = param[0];
    beta = param[1];
    gamma = param[2];
    m0 = param[3];
    m1 = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	f = m1 * c1[0] + 0.5 * (m0 - m1) * (fabs(c1[0] + 1.0) - fabs(c1[0] - 1.0));
	cn[0] = alpha * (c1[1] - c1[0]) - alpha * f;
	cn[1] = c1[0] - c1[1] + c1[2];
	cn[2] = -(beta * c1[1] + gamma * c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Second Order Adaptive Time Varying Sliding Mode Control for Synchronisation of Hidden Chaotic Orbits in a New Uncertain 4-D Conservative Chaotic System
	Jay P Singh and Binoy K Roy 2017
	https://www.researchgate.net/publication/319986856_Second_order_adaptive_time_varying_sliding_mode_control_for_synchronization_of_hidden_chaotic_orbits_in_a_new_uncertain_4-D_conservative_chaotic_system
***************************************************************************/

int	DoSecondOrderAdaptiveTimeVaryingSlidingModeControl(void)

    {
    double	i, c1[4], cn[4], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[0] + a * c1[1] * c1[2] + c1[3];
	cn[2] = 1 - c1[1] * c1[1] * c1[1] * c1[1];
	cn[3] = -b * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Secure Communication Scheme Based Generalised Function Projective Synchronisation of a New 5D Hyperchaotic System
	Xiangjun Wu, Zhengye Fu and Jurgen Kurths 27 March 2015
***************************************************************************/

int	DoSecureCommunicationScheme(void)

    {
    double	i, c1[5], cn[5], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w
    c1[4] = param[14];	// u

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = -c1[0] * c1[2] + c * c1[1] + c1[3];
	cn[2] = c1[0] * c1[1] - b * c1[2];
	cn[3] = -c1[0] - c1[1];
	cn[4] = c1[0] * c1[2] + d * c1[4];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Secure Communication Scheme Based on a New 5D Multistable Four-Wing Memristive Hyperchaotic System with Disturbance Inputs
	Fei Yu, Zinan Zhang, Li Liu, Hui Shen, Yuanyuan Huang, Changqiong Shi, Shuo Cai, Yun Song, Sichun Du and Quan Xu 10 January 2020
	https://www.hindawi.com/journals/complexity/2018/6069401/
***************************************************************************/

int	DoSecureCommunicationScheme5DMultistableFourWing(void)

    {
    double	i, c1[5], cn[5], a, b, c, d, e, beta, w5;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w
    c1[4] = param[14];	// u

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    beta = param[5];
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	w5 = beta * fabs(c1[4]);
	cn[0] = -a * c1[0] + c1[1] * c1[2];
	cn[1] = b * c1[1] - c1[0] * c1[2];
	cn[2] = c1[0] * c1[1] - c * c1[2] + d * c1[3] * w5;
	cn[3] = c1[0] * c1[1] - e * c1[3];
	cn[4] = -c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 6.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Secure Communication Using a New Hyperchaotic System with Hidden Attractors - modified
	Jay Prakash Singh, Kshetrimayum Lochan and Binoy Krishna Roy January 2019
	Send directly by Jay Prakash Singh through Research Gate
***************************************************************************/

int	DoSecureCommunicationUsingNewHyperchaoticSystem(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] * c1[0]) + b * c1[1] * c1[2] + c1[2] * c1[3];
	cn[1] = -b * c1[0] * c1[2] + c * c1[1] + c1[3];
	cn[2] = 4 + c1[0] * c1[1] - d * c1[2];
	cn[3] = -e * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Self-Excited and Hidden Attractors in a Novel Chaotic System with Complicated Multistability
	Hayder Natiq, M.R.M. Said, M.R.K. Ariffin, Shaobo He, Lamberto Rondoni and Santo Banerjee 31 December 2018
	Sent by Lamberto Rondoni
***************************************************************************/

int	DoSelfExcitedHiddenAttractors(void)

    {
    double	i, c1[3], cn[3], a, s, b, d, m;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    s = param[1];
    b = param[2];
    d = param[3];
    m = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = -c1[1];
	cn[1] = c1[0] + d * c1[1] * c1[2];
	cn[2] = s * fabs(cos(c1[0])) - b * c1[1] * c1[1] - a * c1[2] - m;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Self-reproducing Chaos and Bursting Oscillation Analysis in a meminductor-Based Conservative System
	Fang Yuan, Yuan Jin and Yuxia Li 12 May 2020
	https://www.researchgate.net/profile/Fang_Yuan59/publication/341333516
***************************************************************************/

int	DoSelfReproducingChaosBurstingOscillationAnalysis(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = -(a * sin(c * c1[0]) * c1[1] + b) * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Seven-Dimensional Hyperchaotic System Images
	Design and Application of a NEW Seven-Dimensional Hyperchaotic System
	Jianliang Zhu and Chunyu Yu 2014
***************************************************************************/

int	DoSevenDimensions(void)

    {
    double	t, c1[7], cn[7], a, b, c, d, e, f, g, h, i;

    c1[0] = param[10];	// x1
    c1[1] = param[11];	// x2
    c1[2] = param[12];	// x3
    c1[3] = param[13];	// x4
    c1[4] = param[14];	// x5
    c1[5] = param[15];	// x6
    c1[6] = param[16];	// x7

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];
    h = param[7];
    i = param[8];
    totpasses = 10;

    InitOscillator(c1, 7);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[0] + b * c1[5] + c * c1[1] * c1[2] * c1[3] * c1[4] * c1[5] * c1[6];
	cn[1] = -b * c1[0] - b * c1[1] - c1[0] * c1[2] * c1[3] * c1[4] * c1[5] * c1[6];
	cn[2] = b * c1[1] - a * c1[2] - b * c1[4] + c1[0] * c1[1] * c1[3] * c1[4] * c1[5] * c1[6];
	cn[3] = -d * c1[3] - e * c1[5] - c1[0] * c1[1] * c1[2] * c1[4] * c1[5] * c1[6];
	cn[4] = -f * c1[4] + g * c1[5] + c1[0] * c1[1] * c1[2] * c1[3] * c1[5] * c1[6];
	cn[5] = e * c1[4] + h * c1[5] - c1[0] * c1[1] * c1[2] * c1[3] * c1[4] * c1[6];
	cn[6] = -b * c1[5] - a * c1[6] + i * c1[0] * c1[1] * c1[2] * c1[3] * c1[4] * c1[5];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 5.0) % threshold), i, 7, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Shaw-Pol Chaotic Oscillator Images
***************************************************************************/

int	DoShawPol(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1] + a * sin(c * c1[2]);
	cn[1] = -c1[0] + b * (1 - c1[0] * c1[0]) * c1[1];
	cn[2] = c;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Shell Chaotic Oscillator Images
	Analysis of Two Time Scale Property of Singularly 
	Perturbed System on Chaotic Attractor 
	Mozhgan Mombeini, Ali Khaki Sedigh, Mohammad Ali Nekoui 
	June 2011, Agios Nikolaos, Crete Greece
***************************************************************************/

int	DoShell(void)

    {
    double	i, c1[3], cn[3], a1, a2, b1, b2, d1, d2, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a1 = param[0];
    a2 = param[1];
    b1 = param[2];
    b2 = param[3];
    d1 = param[4];
    d2 = param[5];
    e = param[6];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = (c1[0] * (1.0 - c1[0]) - a1 * c1[1] * c1[0] / (b1 * c1[0] + 1.0)) / e;
	cn[1] = c1[1] * ((a1 * c1[0] / (b1 * c1[0] + 1.0) - d1) - a2 * c1[2] * c1[1] / (b2 * c1[1] + 1.0));
	cn[2] = e * c1[2] * (c1[1] * a2 / (b2 * c1[1] + 1.0) - d2);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Shilnikov Chaotic Oscillator Images
	Analysis of Two Time Scale Property of Singularly 
	Perturbed System on Chaotic Attractor 
	Mozhgan Mombeini, Ali Khaki Sedigh, Mohammad Ali Nekoui 
	June 2011, Agios Nikolaos, Crete Greece
***************************************************************************/

int	DoShilnikov(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] + c1[1] + c1[1] * c1[2];
	cn[1] = -c1[0] * c1[2] - c1[1] * c1[2];
	cn[2] = -c1[2] - a * c1[0] * c1[1] + 1.0;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Shimizu-Morioka chaotic dynamical system Images
	Construction of bidirectionally coupled systems using generalized 
	Synchronisation method 
	Mitul Islam, Bipul Islam, Nurul Islam and H. P. Mazumder 2013
***************************************************************************/

int	DoShimizu(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1];
	cn[1] = c1[0] - c1[0] * c1[2] - a * c1[1];
	cn[2] = c1[0] * c1[0] - b * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Silnikov Homoclinic Orbits in Two Classes of 3D Autonomous Nonlinear Systems
	BAOYING CHEN, TIANSHOU ZHOU 23 November 2008
***************************************************************************/

int	DoSilnikov(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[0] + a * c1[1];
	cn[1] = -a * c1[0] + c1[1] + c1[2];
	cn[2] = c1[0] * c1[2] - b * c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Silva-Young Anharmonic Chaotic Oscillator Images
	These equations for this Oscillator appeared in an article Autonomous Silva-Young Type Chaotic Oscillator with 
	Flat Power Spectrum writern by E. Tamaseviciute, G. Mykolaitis, A. Tamasevicius, all of them from Lithuania. 
***************************************************************************/

int	DoSilvaYoung(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e, k, mu, fx;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    k = param[5];
    mu = param[6];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	if (c1[0] < -0.5) fx = -0.5;
	else if (fabs(c1[0]) < 0.5) fx = c1[0];
	else fx = 0.5;
	cn[0] = c1[1];
	cn[1] = k * fx - c1[0] - b * c1[1]  + c * c1[3];
	cn[2] = c1[3] / e;
	cn[3] = 1.0 / mu * (a * c1[1] - c1[2] - d * c1[3]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simple Chaotic Circuit Images
***************************************************************************/

int	DoSimple(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1];
	cn[1] = -c1[0] + c1[1] * c1[2];	
	cn[2] = -c1[0] - a * c1[0] * c1[1] - b * c1[0] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simple Chaotic Circuit with a Light-Emitting Diode
	Viet-Thanh Pham, Christos Volos, Sajad Jafari, Xiong Wang And Tomasz Kapitaniak September-October 2016
***************************************************************************/

int	DoSimpleChaoticCircuitLightEmittingDiode(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = -c1[1];
	cn[1] = -c1[2];	
	cn[2] = -c1[0] + a * (exp(c1[1]) - 1.0) - b * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simple Chaotic Flow With A Continuously Adjustable Attractor Dimension
	BUNCHA MUNMUANGSAEN, JULIEN CLINTON SPROTT 2011
***************************************************************************/

int	DoSimpleChaoticFlowAdjustableAttractor(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1] - b * c1[0];
	cn[1] = c1[1] * c1[2] - c1[0];	
	cn[2] = a - fabs(c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simple Chaotic Flow With A Continuously Adjustable Attractor Dimension
	BUNCHA MUNMUANGSAEN, JULIEN CLINTON SPROTT 2011
***************************************************************************/

/*
int	DoSimpleChaoticFlowAdjustableAttractorIII(void)

    {
    double	i, c1[3], cn[3], a, b, dt;

    c1[0] = 1.0;	// x
    c1[1] = 1.0;	// y
    c1[2] = 1.0;	// z

    a = param[0];
    b = param[1];
    dt = 0.001;

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1] - b * c1[0];
	cn[1] = c1[1] * c1[2] - c1[0];	
	cn[2] = a - fabs(c1[1]) - b * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }
*/

/**************************************************************************
	Simple Chaotic Flow Images
	A SIMPLE CHAOTIC FLOW WITH A CONTINUOUSLY ADJUSTABLE ATTRACTOR DIMENSION
	BUNCHA MUNMUANGSAEN, JULIEN CLINTON SPROTT 2014?
	REM with Sprott´s contribution, everything gets easy....Marcus
***************************************************************************/

int	DoSimpleChaoticFlow(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1];
	cn[1] = -c1[0] + c1[1] * c1[2];	
	cn[2] = a - c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simple Chaotic Flows with One Stable Equilibrium I
	MALIHE MOLAIE and SAJAD JAFARI, JULIEN CLINTON SPROTT, S. MOHAMMAD REZA HASHEMI GOLPAYEGANI May 3, 2013
***************************************************************************/

int	DoSimpleChaoticFlows1(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1];
	cn[1] = c1[2];	
	cn[2] = -c1[0] - 0.6 * c1[1] - 2.0 * c1[2] + c1[2] * c1[2] - 0.4 * c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simple Chaotic Flows with One Stable Equilibrium VII
	MALIHE MOLAIE and SAJAD JAFARI, JULIEN CLINTON SPROTT, S. MOHAMMAD REZA HASHEMI GOLPAYEGANI May 3, 2013
***************************************************************************/

int	DoSimpleChaoticFlows7(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1];
	cn[1] = -c1[0] + c1[1] * c1[2];	
	cn[2] = -2.0 * c1[2] - 8.0 * c1[0] * c1[1] + c1[0] * c1[2] - 1.0;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simple Chaotic Flows with One Stable Equilibrium VIII
	MALIHE MOLAIE and SAJAD JAFARI, JULIEN CLINTON SPROTT, S. MOHAMMAD REZA HASHEMI GOLPAYEGANI May 3, 2013
***************************************************************************/

int	DoSimpleChaoticFlows8(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1];
	cn[1] = -c1[0] + c1[1] * c1[2];	
	cn[2] = -c1[2] - 0.7 * c1[0] * c1[0] + c1[1] * c1[1] - 0.1;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simple Chaotic Flows with One Stable Equilibrium X
	MALIHE MOLAIE and SAJAD JAFARI, JULIEN CLINTON SPROTT, S. MOHAMMAD REZA HASHEMI GOLPAYEGANI May 3, 2013
***************************************************************************/

int	DoSimpleChaoticFlows10(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1];
	cn[1] = -c1[0] + c1[1] * c1[2];	
	cn[2] = c1[0] - 0.3 * c1[1] - 2.0 * c1[2] + c1[0] * c1[2] - 0.1;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simple Chaotic Flows with One Stable Equilibrium XI
	MALIHE MOLAIE and SAJAD JAFARI, JULIEN CLINTON SPROTT, S. MOHAMMAD REZA HASHEMI GOLPAYEGANI May 3, 2013
***************************************************************************/

int	DoSimpleChaoticFlows11(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1];
	cn[1] = -c1[0] + c1[1] * c1[2];	
	cn[2] = -c1[1] - 12.0 * c1[2] + c1[0] * c1[0] + 9.0 * c1[0] * c1[2] - 1.0;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simple Chaotic Flows with One Stable Equilibrium XII
	MALIHE MOLAIE and SAJAD JAFARI, JULIEN CLINTON SPROTT, S. MOHAMMAD REZA HASHEMI GOLPAYEGANI May 3, 2013
***************************************************************************/

int	DoSimpleChaoticFlows12(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1];
	cn[1] = -c1[0] + c1[1] * c1[2];	
	cn[2] = -66.0 * c1[2] + c1[1] * c1[1] + 35.0 * c1[0] * c1[2] - 1.0;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simple Chaotic Flows with One Stable Equilibrium XIII
	MALIHE MOLAIE and SAJAD JAFARI, JULIEN CLINTON SPROTT, S. MOHAMMAD REZA HASHEMI GOLPAYEGANI May 3, 2013
***************************************************************************/

int	DoSimpleChaoticFlows13(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1];
	cn[1] = -c1[0] + c1[1] * c1[2];	
	cn[2] = -4.9 * c1[2] + 0.4 * c1[1] * c1[1] + c1[0] * c1[1] - 1.0;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Simple Chaotic Flow With A Continuously Adjustable  Attractor Dimension
	BUNCHA MUNMUANGSAEN, j.C. SPROTT
***************************************************************************/

int	DoSimpleChaoticFlowAdjustable(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1];
	cn[1] = -c1[0] + c1[1] * c1[2];	
	cn[2] = -c1[1] * c1[1] + a;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simple Chaotic Flow (With an Error) Images
	SIMPLE CHAOTIC FLOW-I- WITH ALMOST A MEGA ERROR
	A SIMPLE CHAOTIC FLOW WITH A CONTINUOUSLY ADJUSTABLE ATTRACTOR DIMENSION
	BUNCHA MUNMUANGSAEN, JULIEN CLINTON SPROTT
***************************************************************************/

int	DoSimpleChaoticFlowError(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1];
	cn[1] = -c1[0] - c1[1] * c1[2];	
	cn[2] = c1[1] * c1[1] - i;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simple Chaotic Flows with a Curve of Equilibria-CE1
	Kosar Barati, Sajad Jafari, Julien Clinton Sprott and Viet-Thanh Pham  July 21, 2016
	https://pdfs.semanticscholar.org/3f17/ebb74bf8bd67907af7dd7c12ff26d435583d.pdf
***************************************************************************/

int	DoSimpleChaoticFlowsCurveEquilibriaCE1(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[2];
	cn[1] = -c1[2] * (c1[1] * c1[1] + c1[0] * c1[2]);	
	cn[2] = c1[0] * c1[0] + c1[1] * c1[1] - 1.0 + c1[2] * (c1[1] * c1[1] - a * c1[2] * c1[2] + c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simple Chaotic Flows with a Curve of Equilibria-CE2
	Kosar Barati, Sajad Jafari, Julien Clinton Sprott and Viet-Thanh Pham  July 21, 2016
	https://pdfs.semanticscholar.org/3f17/ebb74bf8bd67907af7dd7c12ff26d435583d.pdf
***************************************************************************/

int	DoSimpleChaoticFlowsCurveEquilibriaCE2(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = -c1[2];
	cn[1] = c1[2] * (c1[2] * c1[2] - 1.0);	
	cn[2] = c1[0] * c1[0] - c1[1] * c1[1] - 1.0 + c1[2] * (c1[1] * c1[1] - c1[2] * c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simple Chaotic Flows with a Curve of Equilibria-CE3
	Kosar Barati, Sajad Jafari, Julien Clinton Sprott and Viet-Thanh Pham  July 21, 2016
	https://pdfs.semanticscholar.org/3f17/ebb74bf8bd67907af7dd7c12ff26d435583d.pdf
***************************************************************************/

int	DoSimpleChaoticFlowsCurveEquilibriaCE3(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = a * c1[2];
	cn[1] = c1[2] * (b * c1[1] * c1[1] + c * c1[0] * c1[2]);	
	cn[2] = c1[1] * c1[1] - 1.0 - c1[0] * c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simple Chaotic Flows with a Curve of Equilibria-CE4
	Kosar Barati, Sajad Jafari, Julien Clinton Sprott and Viet-Thanh Pham  July 21, 2016
	https://pdfs.semanticscholar.org/3f17/ebb74bf8bd67907af7dd7c12ff26d435583d.pdf
***************************************************************************/

int	DoSimpleChaoticFlowsCurveEquilibriaCE4(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = -a * c1[2];
	cn[1] = -c1[2] * c1[2] * c1[2];	
	cn[2] = c1[0] * c1[0] + c1[1] + c1[2] * (c1[2] - c1[0] * c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simple Chaotic Lorenz-Type System and Its Digital Realization Using a TFT Touch-Screen Display Embedded System
	Rodrigo Méndez-Ramírez, Adrian Arellano-Delgado, César Cruz-Hernández and Rigoberto Martínez-Clark 26 July 2017
***************************************************************************/

int	DoSimpleChaoticLorenzTypeSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = -a * c1[0] - b * c1[1] * c1[2];
	cn[1] = -c1[0] + c * c1[1];	
	cn[2] = d - c1[1] * c1[1] - c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simple Chaotic Oscillator For Educational Purposes
	A Tamaševic?ius, G Mykolaitis, V Pyragas and K Pyragas 3 November 2004 / 2015
***************************************************************************/

int	DoSimpleChaoticOscillator(void)

    {
    double	i, c1[3], cn[3], a, b, epsilon, c, e = exp(1.0);

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    epsilon = param[2];
    c = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1] + c1[2] / c1[0];
	cn[1] = a * c1[1] - c1[0] - c1[2];	
	cn[2] = (b + c1[1] - c * (pow(e, c1[2]) - 1.0)) / epsilon;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simple Chaotic Hyperjerk System
	Fatma Yildirim Dalkiran, J. C. Sprott June 13, 2016
***************************************************************************/

int	DoSimpleChaoticHyperjerk(void)

    {
    double	i, c1[4], cn[4], a, b, c, kx, ky, kz, kw, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    kx = param[3];
    ky = param[4];
    kz = param[5];
    kw = param[6];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = ky / kx * c1[1];
	cn[1] = kz / ky * c1[2];	
	cn[2] = kw / kz * c1[3];
	f = -exp(kz * c1[2]);
	cn[3] = -a * c1[3] + 1.0 / kw * f - b * ky / kw * c1[1] - c * kx / kw * c1[0] ;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simple Memristor Chaotic Circuit Images
	A SIMPLE MEMRISTOR CHAOTIC CIRCUIT WITH COMPLEX DYNAMICS
	BOCHENG BAO, ZHENGHUA MA, JIANPING XU, ZHONG LIU, QIANG XU March 4, 2011
***************************************************************************/

int	DoSimpleMemristor(void)

    {
    double	i, c1[4], cn[4], alpha, beta, gamma, a, b, wao;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z
    c1[3] = param[13];    // w


    alpha = param[0];
    beta = param[1];
    gamma = param[2];
    a = param[3];
    b = param[4];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1];
	wao = -a + 3 * b * c1[0] * c1[0];
	cn[1] = alpha * (c1[2] - wao * c1[1]);	
	cn[2] = c1[1] - gamma * c1[2] + c1[3];
	cn[3] = -beta * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simplest Chaotic Circuit Images
***************************************************************************/

int	DoSimplest(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1];
	cn[1] = -a * c1[0] + b * c1[1] - b * c1[2] * c1[2] * c1[1];	
	cn[2] = -c1[1] - c * c1[2] + c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simplest 2 Chaotic Circuit Images
***************************************************************************/

int	DoSimplest2(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1];
	cn[1] = (-1.0 / a) * (c1[0] + b * (c1[2] * c1[2] - 1) * c1[1] + c * c1[1]);
	cn[2] = -c1[1] - d * c1[2] + c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simplest 3D Continuous-Time Quadratic System
	as Candidates for Generating Multiscroll Chaotic Attractors
	ZERAOULIA ELHADJ March 19, 2013
***************************************************************************/

int	DoSimplest3D(void)

    {
    double	i, c1[3], cn[3], c8;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    c8 = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] - c1[1] + 0.5 * c1[2] - 3.0 * c1[1] * c1[2];
	cn[1] = -0.1 * c1[0] - 6 * c1[1] + c1[0] * c1[2] - c1[1] * c1[2];
	cn[2] = 0.06 * c1[0] - 10.0 * c1[1] - 5.0 * c1[2] + 2.0 * c1[0] * c1[1] + c8 * c1[0] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simplest Circulant System
	J. C. Sprott 2011
	Elegant chaos book
***************************************************************************/

int	DoSimplestCirculantSystem(void)

    {
    double	i, c1[3], cn[3];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] * c1[1] - c1[2];
	cn[1] = c1[2] * c1[2] - c1[0];
	cn[2] = c1[0] * c1[0] - c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simplest Hyperchaotic System with Only One Piecewise Linear Term
	J. P. Sing and B. K. Roy 4th of April, 2019
	https://link.springer.com/article/10.1186/s13662-017-1341-9
	sent by one of the authors.
***************************************************************************/

int	DoSimplestHyperchaoticSystem(void)

    {
    double	i, c1[4], cn[4], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[1] - c1[2] - c1[3];
	cn[1] = c1[0];
	cn[2] = a * (c1[1] - fabs(c1[1]) / c1[1]) - b * c1[2];
	cn[3] = -c * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Simulation and Implementation of Memristive Chaotic System and its Application for Communication Systems
	M.E. Sahin, Z.G. Cam Taskiran, H. Guler and S.E. Hamamci 2 March 2019
	Sent to us by the author Muhammet Emin Sahin through https://www.researchgate.net/requests/r68388416
***************************************************************************/

int	DoSimulationImplementationMemristiveChaoticSystem(void)

    {
    double	i, c1[3], cn[3], c, l, alpha, beta;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    c = param[0];
    l = param[1];
    alpha = param[2];
    beta = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] / c;
	cn[1] = -1 / l * (c1[0] + beta * (c1[2] * c1[2] - 1) * c1[1]);
	cn[2] = c1[1] - alpha * c1[2] + c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Sine-Cosine Optimisation-Based Bijective Substitution-Boxes Construction Using Enhanced Dynamics of Chaotic Map
	Amer Awad Alzaidi, Musheer Ahmad, Hussam S. Ahmed and Eesa Al Solami4 2 December 2018
	https://www.hindawi.com/journals/complexity/2018/9389065/
***************************************************************************/

int	DoSineCosineOptimisationBasedBijectiveSubstitution(void)

    {
    double	i, c1[3], cn[3], c, r;

    c1[0] = param[10];	// x
    c1[1] = 0.0;	// y
    c1[2] = 0.0;	// z

    cn[0] = c1[0];
    c = param[0];
    r = param[1];
    totpasses = 10;

    InitOscillator(c1, 1);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = (c * c * c1[0] + fabs(sin(PI * (c1[0] * c1[0] * c1[0] - r * c1[0]))) / sin(PI * (c1[0] * c1[0] * c1[0] - r * c1[0])));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 1, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Sine-Cosine Shock Images
	ATTRACTOR FROM QI 3-D FOUR-WING CHAOTIC SYSTEM
	GUOYUAN QI, ZHONGLIN WANG, YANLING GUO February 17, 2012
***************************************************************************/

int	DoSineCosineShock(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, m, k, w, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    m = param[4];
    k = param[5];
    w = param[6];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	f = m * ((cos(w * i) <= 0) ? -1.0 : 1.0) + k * ((sin(w * i) <= 0) ? -1.0 : 1.0);
	cn[0] = a * (c1[1] - c1[0]) + f * c1[1] * c1[2];
	cn[1] = c * c1[0] + d * c1[1] - c1[0] * c1[2];
	cn[2] = -b * c1[2] + c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Single Amplifier Biquad Based Inductor-free Chua’s Circuit
	Tanmoy Banerjee 29 Oct 2012
	https://arxiv.org/pdf/1210.8409.pdf
**************************************************************************/

int	DoSingleAmplifierBiquadBasedInductorFreeChuasCircuit(void)

    {
    double	i, c1[3], cn[3], k, m0, m1, alpha, r1, r2, hx;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    k = param[0];
    m0 = param[1];
    m1 = param[2];
    alpha = param[3];
    r1 = param[4];
    r2 = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	hx = m1 * c1[0] + 0.5 * (m0 - m1) * (fabs(c1[0] + 1) - fabs(c1[0] - 1));
	cn[0] = alpha * (c1[1] - hx);
	cn[1] = -k * c1[0] + k * (r1 + 1) * c1[1] - (2 * k + 1) * r2 * c1[2] / (k + 1);
	cn[2] = -(k + 1) * c1[0] + (k + 1) * (r1 + 1) * c1[1] - 2 * r2 * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Sinusoidally Driven Lorenz System and Circuit Implementation
	Chunyan Han, Simin Yu, and Guangyi Wang 10 May 2015
***************************************************************************/

int	DoSinusoidallyDrivenLorenz(void)

    {
    double	i, c1[4], cn[4], a, b, d, azao, w;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    azao = param[0];
    b = param[1];
    d = param[2];
    a = param[3];
    w = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -azao * (c1[0] - c1[1] - a * sin(c1[3]));
	cn[1] = b * c1[0] - c1[0] * c1[2] - c1[1];
	cn[2] = c1[0] * c1[1] - d * c1[2];
	cn[3] = w;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Sinusoidally Forced Simplified Lorenz System
	Hyperchaos and hyperchaos control of the sinusoidally forced simplified Lorenz system
	Keihui Sun, Xuan Liu, Congxu Zhu, J.C. Sprott 23 February 2012
***************************************************************************/

int	DoSinusoidallyForcedLorenz(void)

    {
    double	i, c1[4], cn[4], c0, q, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    c0 = param[0];
    q = param[1];
    k = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 10.0 * (c1[1] - c1[0]) * k / c1[1];
	cn[1] = (24.0 - 4.0 * c0 * sin(c1[3])) * c1[0] - c1[0] * c1[2] + c0 * sin(c1[3]) * c1[1];
	cn[2] = c1[0] * c1[1] - 8.0 * c1[2] / 3.0;
	cn[3] = q;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	A Six-Dimensional Hyperchaotic System Selection and Its Application in DS-CDMA System
	Yaqin Zhao, Shuying Li, Huan Lian, and Zhilu Wu November 2014
***************************************************************************/

int	DoSixDHyperchaotic(void)

    {
    double	i, c1[6], cn[6], f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w

    totpasses = 10;

    InitOscillator(c1, 6);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -1.7 * c1[2] - 1.4 * c1[3];
	cn[1] = 1.7 * c1[1] + 1.0 * c1[2];
	cn[2] = 11.0 * c1[0] - 12.0 * c1[1];
	f = (fabs(c1[3] + 1.0) - fabs(c1[3] - 1.0)) / 2.0;
	cn[3] = 92.0 * c1[0] - 95.0 * c1[3] + 1.0 * c1[4] - 1.0 * c1[5] + 180.0 * f;
	cn[4] = 5.0 * c1[2] - 1.0 * c1[4];
	cn[5] = 5.0 * c1[1] - 1.0 * c1[5];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Six-Term Novel Chaotic System with Hidden Attractor and Its Circuit Design
	Aceng Sambas, Sundarapandian Vaidyanathan, Mustafa Mamat and W. S. Mada Sanjaya February 2018
	https://www.researchgate.net/requests/r41338629
***************************************************************************/

int	DoSixTermNovelChaoticSystem(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[1];
	cn[1] = -c1[0] - c1[1] * c1[2];
	cn[2] = b * c1[1] * c1[1] - c * c1[0] - d;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Sliding Mode Disturbance Observer Control Based on Adaptive Synchronisation in a Class of Fractional-Order Chaotic Systems
	Omid Mofid, Saleh Mobayen and Mohammad-Hassan Khooban 30 November 2018
	Paper received directly from the first author
***************************************************************************/

int	DoSlidingModeDisturbanceObserverControlBasedAdaptiveSynchronisation(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, h;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    h = param[4];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - a * c1[0] + b * c1[1] * c1[2];
	cn[1] = c * c1[1] - c1[0] * c1[2] + c1[2];
	cn[2] = d * c1[0] * c1[1] - h * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Smooth N-Layer Attractor Images
	A SIMPLE SMOOTH CHAOTIC SYSTEM WITH A 3-LAYER ATTRACTOR
	TIANSHOU ZHOU 'GUANRONG CHEN May 8, 2003
***************************************************************************/

int	DoSmoothNLayer(void)

    {
   double	i, ct[3], cn[3], a1, a2, a3, b, c, d, c1, c2, c3;

    ct[0] = param[10];	// x
    ct[1] = param[11];	// y
    ct[2] = param[12];	// z

    a1 = param[0];
    a2 = param[1];
    a3 = param[2];
    c1 = param[3];
    c2 = param[4];
    c3 = param[5];
    d = param[6];
    b = param[7];
    c = param[8];
    totpasses = 10;

    InitOscillator(ct, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = a1 * ct[0] - a2 * ct[1] + a3 * ct[2];
	cn[1] = -d * ct[0] * ct[2] + b;
	cn[2] = c1 * ct[0] * ct[1] + c2 * ct[1] * ct[2] + c3 * ct[2] + d;
	if (DisplayOscillator(ct, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Solitary States for Coupled Oscillators
	Patrycja Jaros, Serhiy Brezetsky, Roman Levchenko, Dawid Dudkowski, 
	Tomasz Kapitaniak and Yuri Maistrenko 15 May 2017
***************************************************************************/

int	DoSolitaryStatesForCoupledOscillators(void)

    {
   double	i, c1[3], cn[3], mi, alpha, n, epsilon, m;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    mi = param[0];
    alpha = param[1];
    n = param[2];
    epsilon = param[3];
    m = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = (-epsilon * c1[1] - mi / n * ((n - 2.0) * sin(alpha) + sin(c1[0] + alpha) + (n - 1) * sin(c1[0] - alpha))) / m;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Snap Hyperchaos (Elegant Chaos book)
	Sprott 2010
***************************************************************************/

int	DoSnapHyperchaos(void)

    {
   double	i, c1[4], cn[4], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1];							// first derivative
	cn[1] = c1[2];							// second derivative
	cn[2] = c1[3];							// third derivative
	cn[3] = -pow(c1[0], 4) * c1[3] - a * c1[2] - c1[1] - c1[0];	// fourth derivative
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Snap-Hyperchaos Modified From Elegant Chaos
	Chlouverakis and Sprott (2006) + Marcus Rezende 2006 / 2015
***************************************************************************/

int	DoSnapHyperchaosModified(void)

    {
   double	i, c1[4], cn[4], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1];							// first derivative
	cn[1] = c1[2];							// second derivative
	cn[2] = c1[3];							// third derivative
	cn[3] = -pow(c1[0], 4) * c1[3] - a * c1[2] - c1[1] - b * c1[0] + c1[1] - c1[2];	// fourth derivative
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Solution and Dynamics of a Fractional-Order 5-D Hyperchaotic System with Four Wings
	Limin Zhang, Kehui Sun, Shaobo He, Huihai Wang and Yixin Xu  23 January 2017
	Sent by the second author....
	https://www.hindawi.com/journals/complexity/2018/9430637/
***************************************************************************/

int	DoSolutionDynamicsFractionalOrder5DHyperchaoticSystem(void)

    {
   double	i, c1[5], cn[5], a, b, c, d, e, f, g, h;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];
    h = param[7];
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = -a * c1[0] + c1[1] * c1[2];
	cn[1] = -b * c1[1] + f * c1[4];
	cn[2] = -c * c1[2] + g * c1[3] + c1[0] * c1[1];
	cn[3] = d * c1[3] - h * c1[2];
	cn[4] = e * c1[4] - c1[1] * c1[0] * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Some Attractors in the Extended Complex Lorenz Model
	X. Gomez-Mont, J.-J. Flores-Godoy and G. Fenandez-Anaya March 28, 2013
***************************************************************************/

int	DoSomeAttractorsComplexLorenz(void)

    {
   double	i, c1[6], cn[6], s, r, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// v
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w

    s = param[0];
    r = param[1];
    b = param[2];
    totpasses = 10;

    InitOscillator(c1, 6);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = s * (-c1[0] + c1[2]);
	cn[1] = s * (-c1[1] + c1[3]);
	cn[2] = r * c1[0] - c1[2] - c1[0] * c1[4] + c1[1] * c1[5];
	cn[3] = r * c1[1] - c1[3] - c1[1] * c1[4] - c1[0] * c1[5];
	cn[4] = c1[0] * c1[2] - c1[1] * c1[3] - b * c1[4];
	cn[5] = c1[1] * c1[2] + c1[0] * c1[3] - b * c1[5];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Spatial Feedback Control on Multistability in Hidden Attractors -II
	SHIVA DIXIT, M. PAUL ASIR, AWADESH PRASAD, NIKOLAY V. KUZNETSOV and MANISH DEV SHRIMALI 2020
	Sent to ManopWIN by NIKOLAY V. KUZNETSOV through https://www.ias.ac.in/article/fulltext/conf/003/0002
***************************************************************************/

int	DoSpatialFeedbackControl(void)

    {
    double	i, c1[3], cn[3], alpha, m, beta, w;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alpha = param[0];
    m = param[1];
    beta = param[2];
    w = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1];
	cn[1] = (alpha + c1[2] + c1[0] * c1[0] - beta * pow(c1[0], 4)) * c1[1] - w * w * c1[0];
	cn[2] = m - c1[0] * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Spatiotemporal Chaos due to Spiral Waves Core Expansion
	H. Sabbagh (equations - initial proposition)
	& Marcus (new equations + new constants + initial values) 2013
***************************************************************************/

int	DoSpatiotemporal(void)

    {
    double	i, c1[3], cn[3], a, b, c, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    e = param[2];
    c = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[2] - c1[0];
	cn[1] = 1.0 / c * (pow(c1[0], 37.0) - c1[0] * c1[1] * c1[2]);
	cn[2] = c * c1[2] - (1.0 / e) * c1[0] * (1.0 - c1[0]) * (c1[0] - (b + c1[1]) / a) - c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Spatio-Temporal Patterns with Hyperchaotic Dynamics in Diffusively Coupled Biochemical Oscillators
	GEROLD BAIER and SVEN SAHLE  9 October 1996
***************************************************************************/

int	DoSpatiotemporalHyperchaotic(void)

    {
    double	i, c1[4], cn[4], a1, b1, a2, b2;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a1 = param[0];
    a2 = param[1];
    b1 = param[2];
    b2 = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[1] + a1 * c1[0];
	cn[1] = c1[0] - c1[3];
	cn[2] = -c1[3] + a2 * c1[2];
	cn[3] = 0.1 + 3.0 * c1[3] * (b1 * c1[1] + b2 * c1[2]) - 8.0 * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Spherically skrew oscillator-2
	Generation of a novel spherical chaotic attractor from a new
	three-dimensional system Sun Chang-Chun, Zhao En-Liang, and Xu Qi-Cheng
	published online 25 March 2014
***************************************************************************/

int	DoSphericallyScrew(void)

    {
    double	i, c1[3], cn[3], a1, b1, C1, a2, b2, c2, a3, c3;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a1 = param[0];
    b1 = param[1];
    C1 = param[2];
    a2 = param[3];
    b2 = param[4];
    c2 = param[5];
    a3 = param[6];
    c3 = param[7];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = a1 * c1[0] + b1 * c1[1] + C1;
	cn[1] = a2 * c1[0] + b2 * c1[1] * c1[2] + c2;
	cn[2] = a3 * c1[1] * c1[1] + c3;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	SPICE Implementation of a Novel 4-D Hyperchaotic Rikitake Dynamo System
	Analysis, Control, Synchronization and SPICE Implementation of a Novel
	4-D Hyperchaotic Rikitake Dynamo System without Equilibrium
	S. Vaid'yanathan, Ch. K. Volos and V. -T. Pham 29 November 2014
***************************************************************************/

int	DoSPICERikitakeDynamo(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, p = 0.0;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = -a * c1[0] + c1[1] * c1[2] - p * c1[3];
	cn[1] = -a * c1[1] + c1[0] * (c1[2] - b) - p * c1[3];
	cn[2] = 1.0 - c1[0] * c1[1];
	cn[3] = c * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Spiral Waves in Externally Excited Neuronal Network: Solvable Model with a Monotonically Differentiable Magnetic Flux
	Karthikeyan Rajagopal, Fatemeh Parastesh, Hamed Azarnoush, Boshra Hatef, Sajad Jafari, and Vesna Berec 11 April 2019
	https://aip.scitation.org/doi/abs/10.1063/1.5088654
***************************************************************************/

int	DoSpiralWavesExternallyExcitedNeuronalNetwork(void)

    {
    double	t, c1[4], cn[4], a, b, k, c, d, r, s, k1, k2, alpha, beta, f, i, rw;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    k = param[2];
    c = param[3];
    d = param[4];
    r = param[5];
    s = param[6];
    k1 = param[7];
    k2 = param[8];
    alpha = param[9];
    beta = 0.5;
    f = 0.01;
    i = 1.0;
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	rw = alpha - beta * tanh(c1[3]);
	cn[0] = c1[1] - a * c1[0] * c1[0] * c1[0] + b * c1[0] * c1[0] - c1[2] + i - k * c1[0] * rw;
	cn[1] = c - d * c1[0] * c1[0] - c1[1];
	cn[2] = r * (s * (c1[0] + 1.6) - c1[2]);
	cn[3] = k1 * c1[0] - k2 * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 10.0) % threshold), t, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Spontaneous Synchronisation in Two Mutually Coupled Memristor-Based Chua’s Circuits-Numerical Investigations
	Eleonora Bilotta, Francesco Chiaravalloti and Pietro Pantano 7 May 2014
	https://www.hindawi.com/journals/mpe/2014/594962/
***************************************************************************/

int	DoSpontaneousSynchronisation(void)

    {
    double	t, c1[8], cn[8], omega, a, epsilon, alpha, gamma, omega1, omega2, s1, s2;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w
    c1[6] = param[16];	// p
    c1[7] = param[17];	// q

    omega = param[0];
    a = param[1];
    epsilon = param[2];
    alpha = param[3];
    gamma = param[4];
    omega1 = param[5];
    omega2 = param[6];
    s1 = param[7];
    s2 = param[8];
    totpasses = 10;

    InitOscillator(c1, 8);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);

	cn[0] = c1[1] * (1 + epsilon * (c1[1] * c1[1] + omega * omega * c1[0] * c1[0])) - gamma * c1[0];
	cn[1] = -omega * omega * c1[0] * (1 + epsilon * (c1[1] * c1[1] + omega * omega * c1[0] * c1[0])) - gamma * c1[1] + alpha * c1[2] + a * cos(omega1 * t);
	cn[2] = c1[3] * (1 + epsilon * (c1[3] * c1[3] + omega * omega * c1[2] * c1[2])) - gamma * c1[2];
	cn[3] = -omega * omega * c1[2] * (1 + epsilon * (c1[3] * c1[3] + omega * omega * c1[2] * c1[2])) - gamma * c1[3] + alpha * c1[0] + a * cos(omega2 * t);
	cn[4] = c1[5] * (1 + epsilon * (c1[5] * c1[5] + omega * omega * c1[4] * c1[4])) - gamma * c1[4] + s1 * (c1[0] - c1[4]);
	cn[5] = -omega * omega * c1[4] * (1 + epsilon * (c1[5] * c1[5] + omega * omega2 * c1[4] * c1[4])) - gamma * c1[5] + alpha * c1[6] + a * cos(omega1 * t) + s1 * (c1[1] - c1[5]);
	cn[6] = c1[7] * (1 + epsilon * (c1[7] * c1[7] + omega * omega2 * c1[6] * c1[6])) - gamma * c1[6] + s2 * (c1[2] - c1[6]);
	cn[7] = -omega * omega * c1[6] * (1 + epsilon * (c1[7] * c1[7] + omega * omega2 * c1[6] * c1[6])) - gamma * c1[7] + alpha * c1[4] + a * cos(omega2 * t) + s2 * (c1[3] - c1[7]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 10.0) % threshold), t, 8, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Stabilisation and Synchronisation of Uncertain Zhang System by Means of Robust Adaptive Control
	J. Humberto Pérez-Cruz 2 December 2018
	Sent by  Ricardo Aguilar-Lopez
***************************************************************************/

int	DoStabilisationSynchronisationUncertainZhangSystem(void)

    {
    double	t, c1[3], cn[3], a, b, c, d, f, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    f = param[4];
    g = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);

	cn[0] = -a * c1[0] + b * c1[1] * c1[2];
	cn[1] = -c * c1[1] * c1[1] * c1[1] + d * c1[0] * c1[2];
	cn[2] = f * c1[2] - g * c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 10.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Stabilizing Near-Nonhyperbolic Chaotic Systems and its Potential Applications in Neuroscience
	Debin Huang 11 May, 2004
***************************************************************************/

int	DoStabilizingNearNonhyperbolicChaoticSystems(void)

    {
    double	t, c1[3], cn[3], r, i;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    r = param[0];
    i = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);

	cn[0] = c1[1] + 3.0 * c1[0] * c1[0] - c1[0] * c1[0] * c1[0] - c1[2] + i;
	cn[1] = 1.0 - 5.0 * c1[0] * c1[0] - c1[1];
	cn[2] = -r * c1[2] + 4.0 * r * (c1[0] + 1.6);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 10.0) % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Stability Analysis and Control Chaos for Fractional 5D Maxwell-Bloch Model
	Mihai Ivan 21 February 2018
***************************************************************************/

int	DoStabilityAnalysisControlChaos(void)

    {
    double	t, c1[5], cn[5];

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v

    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);

	cn[0] = c1[2];
	cn[1] = c1[3];
	cn[2] = c1[0] * c1[4];
	cn[3] = c1[1] * c1[4];
	cn[4] = -(c1[0] - c1[2] + c1[1] * c1[3]);

	c1[3] += cn[3] * dt;						// Marcus bug - added to get his images

	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 10.0) % threshold), t, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Steady Periodic Memristor Oscillator with Transient Chaotic Behaviours
	B.C. Bao, Z. Liu and J.P. Xu  4th February 2010
	https://www.researchgate.net/profile/Bocheng_Bao/publication/224113326_Steady_periodic_Memristor_oscillator_with_transient_chaotic_behaviours/links/00b49534fb67b8f43c000000.pdf
***************************************************************************/

int	DoSteadyPeriodicMemristorOscillator(void)

    {
    double	t, c1[4], cn[4], a, b, c, aa, bb, k, wx;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    aa = param[3];
    bb = param[4];
    k = param[5];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	wx = aa + 3 * bb * c1[0] * c1[0];
	cn[0] = k * a * (c1[1] - c1[0] * wx);
	cn[1] = k * (c1[2] - c1[0]);
	cn[2] = k * (-b * c1[1] + c * c1[2]);
	cn[3] = k * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(t / 10.0) % threshold), t, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Stimulus-Induced Chaotic Synchronisation of Chua's Oscillators
	V. V. Klinshov, V. B. Kazantsev and V. I. Nekorkin November 29, 2005
***************************************************************************/

int	DoStimulusInducedChaoticSync(void)

    {
    double	i, c1[3], cn[3], alpha, beta, gamma, d, e, ma, mb, mc;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alpha = param[0];
    beta = param[1];
    gamma = param[2];
    d = param[3];
    e = param[4];
    ma = param[5];
    mb = param[6];
    mc = param[7];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = alpha * (c1[1] - c1[0] - (mc * c1[0] + 0.5 * (mb - mc) * (fabs(c1[0] + d) - fabs(c1[0] - d)) + 0.5 * (ma - mb) * (fabs(c1[0] + 1.0) - fabs(c1[0] - 1.0))));
	cn[1] = c1[0] - c1[1] + c1[2];
	cn[2] = -beta * c1[1] - gamma * c1[2] + e;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Strange Double-Deck Butterfly Chaotic Attractor
	from a Permanent Magnet Synchronous Motor with Smooth Air Gap:
	Numerical Analysis and Experimental Observation
	ZhonglinWang, Shijian Cang, ZenghuiWang, Wei Xue, and Zengqiang Chen
	17 July 2014
***************************************************************************/

int	DoStrangeButterfly(void)

    {
    double	i, c1[3], cn[3], a, w, ab, g, v;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    w = param[1];
    ab = param[2];
    g = param[3];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = ab * (c1[1] - c1[0]);
	v = a * sin(w * i);
	cn[1] = g * c1[0] - c1[1] - 100.0 * c1[0] * c1[2] + 0.1 * v;
	cn[2] = -c1[2] + c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Strange Non-chaotic Attractor
	Experimental Study on the Blowout Bifurcation Route to Strange Nonchaotic Attractor
	YoungHun Yu, Doo Chul Kim, Kuemcheol Kwak, Tong Kun Lim, Wonki Jung 2000
***************************************************************************/

int	DoStrangeNonChaotic(void)

    {
    double	i, c1[4], cn[4], gamma, beta, f1, f2, k, w1, w2;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// q

    gamma = param[0];
    beta = param[1];
    f1 = param[2];
    f2 = param[3];
    k = param[4];
    w1 = param[5];
    w2 = param[6];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[1];
	cn[1] = -k * c1[1] - gamma * c1[0] * c1[0] * c1[0] + (beta + f1 * sin(c1[2]) + f2 * sin(c1[3])) * sin(2.0 * PI * c1[0]);
	cn[2] = w1;
	cn[3] = w2;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Strizhak-Kawczynski Chaotic Attractor Images
***************************************************************************/

int	DoStrizhak(void)

    {
    double	i, c1[3], cn[3], a, b, b1, b2, q, r, ax1, ax2, ax3;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    b1 = param[2];
    b2 = param[3];
    q = param[4];
    r = param[5];
    ax1 = param[6];
    ax2 = param[7];
    ax3 = param[8];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = r * (c1[1] - (c1[0] - ax1) * (c1[0] - ax2) * (c1[0] - ax3) - a);
	cn[1] = b - b1 * c1[2] - b2 * c1[0] - c1[1];
	cn[2] = q * (c1[0] - c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Study of a Two-Memcapacitor Circuit Model with Semi-Explicit ODE Solver
	Denis N. Butusov, Valerii Y. Ostrovskii, Atur I. Karimov and Dmitry A. Belkin November 2020
***************************************************************************/

int	DoStudyTwoMemcapacitorCircuitModel(void)

    {
    double	i, c1[3], cn[3], a1, b1, a2, b2, c, d, ee, yCubed, zCubed;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a1 = param[0];
    b1 = param[1];
    a2 = param[2];
    b2 = param[3];
    c = param[4];
    d = param[5];
    ee = param[6];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	yCubed = c1[1] * c1[1] * c1[1];
	zCubed = c1[2] * c1[2] * c1[2];
	cn[0] = c * (a2 * c1[2] + b2 * zCubed);
	cn[1] = (d - ee) * (a1 * c1[1] + b1 * yCubed) + ee * (a2 * c1[2] + b2 * zCubed);
	cn[2] = ee * (a1 * c1[1] + b1 * yCubed - a2 * c1[2] - b2 * zCubed) - c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Study of the Coexistence of Three Types of Attractors in an Autonomous System
	DENIS DE CARVALHO BRAGA, LUIS FERNANDO MELLO. August 25, 2013
***************************************************************************/

int	DoStudyOfOCoexistence(void)

    {
    double	i, c1[3], cn[3], a, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    c = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[1] * c1[2];
	cn[1] = -c1[1] + c1[0] * c1[0];
	cn[2] = 1.0 - c * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Suppression of Chaos in Porous Media Convection under Multifrequency Gravitational Modulation
	Karam Allali 3 April 2018
	https://www.hindawi.com/journals/amp/2018/1764182/
**************************************************************************/

int	DoSuppressionChaosPorousMedia(void)

    {
    double	i, c1[4], cn[4], d, l1, l2, alpha, s1, s2, r, n;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    d = param[0];
    l1 = param[1];
    l2 = param[2];
    alpha = param[3];
    r = param[4];
    s1 = param[5];
    s2 = param[6];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	n = s2 / s1;
	cn[0] = -alpha * (c1[0] - c1[1]) + alpha * (l1 * sin(c1[3]) + l2 * sin(n * c1[3])) * c1[1];
	cn[1] = -c1[1] + r * c1[0] - (r - 1) * c1[0] * c1[2];
	cn[2] = 4 * r * (c1[0] * c1[1] - c1[2]);
	cn[3] = s1;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Switching Synchronisation Control between Integer-order and Fractional-order Dynamics of a Chaotic System
	modified-Manashita Borah and Binoy K. Roy January 4-6, 2017
	Paper sent by the first author
***************************************************************************/

int	DoSwitchingSynchronisationControl(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, l, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    l = param[4];
    k = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + b * c1[1] * c1[2] * c1[2];
	cn[1] = c * c1[0] + d * c1[0] * c1[2] * c1[2];
	cn[2] = l * c1[2] + k * c1[0] * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Symmetric Flow Chaotic Attractor Images
***************************************************************************/

int	DoSymmetricFlow(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i += dt)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[0] - 4.0 * c1[1] - 4.0 * c1[2] - c1[1] * c1[1];
	cn[1] = -a * c1[1] - 4.0 * c1[2] - 4.0 * c1[0] - c1[2] * c1[2];
	cn[2] = -a * c1[2] - 4.0 * c1[0] - 4.0 * c1[1] - c1[0] * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / dt) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Synchronisation and an Application of a Novel Fractional Order King Cobra Chaotic System
	P. Muthukumar, P. Balasubramaniam and K. Ratnavelu 2014
	https://docksci.com/queue/synchronization-and-an-application-of-a-novel-fractional-order-king-cobra-chaoti_5a8d3a91d64ab256632f5a7a.html
***************************************************************************/

int	DoSynchronisationApplicationNovelFractionalOrderKingCobra(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, h, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    h = param[4];
    k = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + b * c1[1] * c1[2] * c1[2];
	cn[1] = c * c1[0] + d * c1[0] * c1[2] * c1[2];
	cn[2] = h * c1[2] + k * fabs(c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Synchronisation Behaviors of Coupled Systems Composed of Hidden Attractors
	Ge Zhang, Fuqiang Wu, Chunni Wang and Jun Ma 25 May 2017
	https://www.researchgate.net/publication/317211215
***************************************************************************/

int	DoSynchronisationBehaviorsCoupledSystems(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, r;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    r = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i += dt)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[2];
	cn[1] = b * c1[0] * c1[2] + c * c1[2] * c1[2] * c1[2];
	cn[2] = c1[0] * c1[0] + c1[1] * c1[1] - r * r + d * c1[0] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / dt) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Synchronisation and Anti-Synchronisation of Chaos in an Extended Bonhoffer - van der Pol Oscillator using Active Control
	A.N. Njaha and  U.E. Vincentb  30 June 2008
***************************************************************************/

int	DoSynchronisationAntiSynchronisation(void)

    {
    double	i, c1[3], cn[3], a, b, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    d = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i += dt)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[2] + a * c1[0] + tanh(b * c1[2]);
	cn[1] = c1[2] - d * c1[1];
	cn[2] = c1[0] - c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / dt) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Synchronisation Between Fractional-Order and Integer-Order
	Hyperchaotic Systems via Sliding Mode Controller
	Yan-Ping Wu and Guo-Dong Wang 19 January 2013
***************************************************************************/

int	DoSyncFractional(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, gamma;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    gamma = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[3];
	cn[1] = gamma * c1[0] - c1[0] * c1[2] + c * c1[1];
	cn[2] = c1[0] * c1[1] - b * c1[2];
	cn[3] = c1[1] * c1[2] + d * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Synchronisation Between Two Non-Autonomous Chaotic Systems Via Intermittent Event-Triggered Control
	Wenlan Qiu1, Jianping Cai and Jianbin He  December 2022
	http://www.ijicic.org/ijicic-190318.pdf.....DOI: 10.24507/ijicic.19.03.907
	Corresponding authors: 1258517804@qq.com
***************************************************************************/

int	DoSyncBetween2NonAutonomousChaoticSystems(void)

    {
    double	i, c1[3], cn[3], a, /*b, */c/*, d, e, f, s*/;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
/*
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
*/
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	c = cos(i);
//	s = sin(i);

	cn[0] = -c1[1] * c1[2] - 0.5 * (1 + 6.5 * c) * c1[1] + 0.4 * c1[2] - 0.002 * (c1[0] + cube(c1[0]));
	cn[1] = c1[0] * c1[2] + 0.5 * (1 + 6.5 * c) * c1[0] - 0.4 * c1[2] - 0.002 * (c1[1] + cube(c1[1]));
	cn[2] = -0.2 * (c1[1] - c1[0] - c1[2]) - 0.001 * (c1[2] + cube(c1[2])) + 1.625 * sin(i);
	if (i > a)
	    if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
		break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Synchronisation Dependence on Initial Setting of Chaotic Systems Without Equilibria - 3D and 6D
	Fuqiang Wu, Ping Zhou, Ahmed Alsaedi, Tasawar Hayat and Jun Ma  +  Marcus  Rezende 12/02/2019
	https://www.researchgate.net/requests/r53531023 and sent by Jun Ma
***************************************************************************/

int	DoSynchronisationDependenceInitialSetting(bool SixD)

    {
    double	i, c1[6], cn[6], k0, a, l, v0, w0;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w

    k0 = param[0];
    a = param[1];
    l = param[2];
    totpasses = 10;

    InitOscillator(c1, (SixD ? 6 : 3));						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[0] + c1[1] * c1[2] - k0 * c1[2] * c1[2] * c1[1];
	cn[2] = a - c1[1] * c1[1];
	if (SixD)
	    {
	    v0 = 0.5 * (c1[0] + c1[1]);
	    w0 = (c1[0] - c1[1]) / l;
	    cn[3] = v0 * cos(c1[5]);
	    cn[4] = v0 * sin(c1[5]);
	    cn[5] = w0;
	    }
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 35.0) % threshold), i, (SixD ? 6 : 3), 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

int	DoSynchronisationDependenceInitialSetting3D(void)
    {
    return DoSynchronisationDependenceInitialSetting(false);
    }
int	DoSynchronisationDependenceInitialSetting6D(void)
    {
    return DoSynchronisationDependenceInitialSetting(true);
    }


/**************************************************************************
	Synchronisation of Chaotic Systems using Feedback Controller: An Application to Diffie–Hellman Key Exchange Protocol and ElGamal Public Key Cryptosystem
	P. Balasubramaniam and P. Muthukumar 14 November 2013
	https://mail.google.com/mail/u/0/#inbox/FMfcgxvzLhbhKvXJfJSWkZHTznJRCWXq
***************************************************************************/

int	DoSynchronisationChaoticSystemsFeedbackController(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i += dt)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] * (1 - c1[2]);
	cn[1] = c1[1] * (1 + c1[2]) - a * c1[0];
	cn[2] = a - c1[0] * c1[1] - c1[1] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / dt) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Synchronisation of Hyperchaotic Oscillators Using a Scalar Signal
	G. Grassi and S. Mascolo 1997 
***************************************************************************/

int	DoSyncScalarSignal(void)

    {
    double	i, c1[4], cn[4], h;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 0.7 * c1[0] - c1[1] - c1[2];
	cn[1] = c1[0];
	cn[2] = 3.0 * (c1[0] - c1[3]);
	h = (c1[3] < -1.0) ? 0.0 : 1.0;
	cn[3] = 3.0 * c1[2] - 30.0 * (c1[3] - 1.0) * h;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Synchronisation of Coupled Bistable Chaotic Systems: Experimental Study
	Alexander N Pisarchik, Rider Jaimes-Reategui, J. Hugo Garcia-Lopez 13 February 2008
***************************************************************************/

int	DoSyncCoupledBistable(void)

    {
    double	i, c1[3], cn[3], a, b, mu, f, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    mu = param[2];
    g = param[3];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	f = (c1[0] <= 3.0) ? 0 : mu * c1[0];
	cn[0] = -a * c1[0] - b * c1[1] - c1[2];
	cn[1] = c1[0] + g * c1[1];
	cn[2] = f - c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Synchronisation of Chaotic Fractional-Order WINDMI Systems via
	Linear State Error Feedback Control Baogui Xin, Tong Chen, and Yanqin Liu 
***************************************************************************/

int	DoSyncWindmi(void)

    {
    double	i, c1[3], cn[3], a, b, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    e = exp(1.0);

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = -a * c1[2] - c1[1] + b - pow(e, c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Synchonisation Chaotic Attractor Images
	New Criteria for Generalized Synchronisation Preserving the Chaos Type 
	M. U. Akhmet and M. O. Fen 
	Proceedings, 6th Chaotic Modeling and Simulation International Conference
	11 - 14 June 2013 Istanbul, Turkey
***************************************************************************/

int	DoSynchronisation(void)

    {
    double	i, c1[6], cn[6];

    c1[0] = param[10];    // x1
    c1[1] = param[11];    // x2
    c1[2] = param[12];    // x3
    c1[3] = param[13];    // y1
    c1[4] = param[14];    // y2
    c1[5] = param[15];    // y3

    totpasses = 10;

    InitOscillator(c1, 6);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 10.0 * (-c1[0] + c1[1]);
	cn[1] = -c1[1] + 28.0 * c1[0] - c1[0] * c1[2];
	cn[2] = -8.0 / 3.0 * c1[2] + c1[0] * c1[1];
	cn[3] = -2.0 * c1[3] - c1[5] + 0.003 * c1[4] * c1[4] + c1[1] - 1.0 / 2.0 * cos(c1[1]);
	cn[4] = -c1[3] - 2.0 * c1[4] + 5.0 * c1[0] + 0.01 * c1[0] * c1[0] * c1[0];
	cn[5] = c1[3] - c1[4] - 3.0 * c1[5] + 2.0 * tan((c1[2] + c1[4]) / 120.0);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 6, 2) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Synchronisation Control of a Novel Fractional-order Chaotic System with Hidden Attractor
	Manashita Borah, Prasanta Roy and Binoy K. Roy 2016
	https://www.researchgate.net/publication/314668312_Synchronisation_control_of_a_novel_fractional-order_chaotic_system_with_hidden_attractor
***************************************************************************/

int	DoSynchronisationControl(void)

    {
    double	i, c1[3], cn[3], a, b, m, c;

    c1[0] = param[10];    // x1
    c1[1] = param[11];    // x2
    c1[2] = param[12];    // x3

    a = param[0];
    b = param[1];
    m = param[2];
    c = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = -b * c1[1] + m * c1[0] * c1[2];
	cn[2] = c - exp(c1[0] * c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 2) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Synchronisation in Coupled Multistable Systems with Hidden Attractors
	Gokul PM and Tomasz Kapitaniak 19 April 2017
***************************************************************************/

int	DoSynchronizationCoupledMultistableSystems(void)

    {
    double	i, c1[9], cn[9], a, k;

    c1[0] = param[10];	    // x
    c1[1] = param[11];	    // y
    c1[2] = param[12];	    // z
    c1[3] = param[13];	    // u
    c1[4] = param[14];	    // v
    c1[5] = param[15];	    // w
    c1[6] = param[16];	    // p
    c1[7] = param[17];	    // q
    c1[8] = param[18];	    // r

    a = param[0];
    k = param[1];

    totpasses = 10;

    InitOscillator(c1, 9);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] * c1[2] + a + k * (c1[3] - c1[0]);
	cn[1] = c1[0] * c1[0] - c1[1];
	cn[2] = 1.0 - 4.0 * c1[0];

	cn[3] = c1[4] * c1[5] + a + k * (c1[6] - c1[3]);
	cn[4] = c1[3] * c1[3] - c1[4];
	cn[5] = 1.0 - 4.0 * c1[3];

	cn[6] = c1[7] * c1[8] + a + k * (c1[0] - c1[6]);
	cn[7] = c1[6] * c1[6] - c1[7];
	cn[8] = 1.0 - 4.0 * c1[6];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 9, 2) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Synchronisation of a Novel Fractional Order Stretch-Twist-Fold (STF) Flow Chaotic System and Its Application to a New Authenticated Encryption Scheme (AES)
	P. Muthukumar, P. Balasubramaniam and K. Ratnavelu 13 April 2014
	https://umexpert.um.edu.my/file/publication/00004152_106522_66571.pdf
***************************************************************************/

int	DoSynchronisationNovelFractionalOrderStretchTwistFold(void)

    {
    double	i, c1[3], cn[3], alpha, beta;

    c1[0] = param[10];	    // x
    c1[1] = param[11];	    // y
    c1[2] = param[12];	    // z

    alpha = param[0];
    beta = param[1];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = alpha * c1[2] - 8.0 * c1[0] * c1[1];
	cn[1] = 11.0 * c1[0] * c1[0] + 3.0 * c1[1] * c1[1] + c1[2] * c1[2] + beta * c1[0] * c1[2] - 3.0;
	cn[2] = -alpha * c1[0] + 2.0 * c1[1] * c1[2] - beta * c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 15.0) % threshold), i, 3, 2) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Synchronisation of Chaotic Cellular Neural Networks in Small-World Topology
	Soriano-Sanchez A.G., Platas-Garza M.A., Lopez-Gutierrez R.M.,Cruz-Hernandez C., and Posadas-Castillo C. 2015
***************************************************************************/

int	DoSynchronisationNeuralNetworks(void)

    {
    double	i, c1[3], cn[3], fx, fy, start;
    int		type;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y

    start = param[0];
    type = (int)param[1];

    totpasses = 10;

    InitOscillator(c1, 2);						// pass in number of dimensions
    for (i = start; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	fx = 0.5 * (fabs(c1[0] + 1.0) - fabs(c1[0] - 1.0));
	fy = 0.5 * (fabs(c1[1] + 1.0) - fabs(c1[1] - 1.0));
	switch (type)
	    {
	    case 0:							// original
		cn[0] = -c1[0] + 2.0 * fx - 1.2 * fy + 4.4 * sin(HALF_PI * i);
		break;
	    case 1:							// no trig
		cn[0] = -c1[0] + 2.0 * fx - 1.2 * fy;
		break;
	    default:							// tan
		cn[0] = -c1[0] + 2.0 * fx - 1.2 * fy + 4.4 * tan(PI * i);
		break;
	    }
	cn[1] = -c1[1] + 1.2 * fx + 2.0 * fy;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 2, 2) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Synchronisation of Chaotic Cellular Neural Networks in Small-World Topology - An Experiment with Pi
	Soriano-Sanchez A.G., Platas-Garza M.A., Lopez-Gutierrez R.M.,Cruz-Hernandez C., and Posadas-Castillo C. 2015
***************************************************************************/

int	DoSynchronisationNeuralNetworksPi(void)

    {
    double	i, c1[4], cn[4], fx, fy, pie;

    c1[0] = param[10];	   // x
    c1[1] = param[11];	   // y
    c1[2] = param[12];	   // z
    c1[3] = param[13];	   // w

    pie = param[0];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	fx = 0.5 * (fabs(c1[0] + 1.0) - fabs(c1[0] - 1.0));
	fy = 0.5 * (fabs(c1[1] + 1.0) - fabs(c1[1] - 1.0));
	cn[0] = -c1[0] + 2.0 * fx - 1.2 * fy + 4.4 * sin(pie / 2.0 * i);
	cn[1] = -c1[1] + 1.2 * fx + 2.0 * fy;
	cn[2] = fx + fy;
	cn[3] = fx - fy;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 2) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Synchronisation of Chaotic Systems via Adaptive Control of Symmetry Coefficient in Semi-Implicit Models
	Aleksandra V. Tutueva, Timur I. Karimov, Valery S. Andreev, Alexander V. Zubarev, Ekaterina A. Rodionova and Denis N. Butusov 2020
	https://www.researchgate.net/publication/347780581
***************************************************************************/

int	DoSynchronisationChaoticSystemsAdaptiveControl(void)

    {
    double	i, c1[3], cn[3], h, s, t1;

    c1[0] = param[10];	   // x
    c1[1] = param[11];	   // y
    c1[2] = param[12];	   // z

    h = param[0];
    s = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	t1 = c1[0] + c1[1];
	cn[0] = c1[0] + t1 * s * c1[1] * c1[2];
	cn[1] = c1[1] + t1 * s * (cn[0] - c1[1]);
	cn[2] = c1[2] + t1 * s * (1 - cn[0] * cn[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 40.0) % threshold), i, 3, 2) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Synchronisation of Irregular Complex Networks with Chaotic Oscillators: Hamiltonian Systems Approach
	C. Posadas-Castillo, E. Garza-González, D. A. Diaz-Romero, E. Alcorta-Garcia and C. Cruz-Hernández agosto, 2014
***************************************************************************/

int	DoSyncIrregularComplexNetworks(void)

    {
    double	i, c1[4], cn[4], g, s, e, gamma, delta, beta;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    gamma = param[0];
    g = param[1];
    delta = param[2];
    s = param[3];
    beta = param[4];
    e = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - gamma * c1[0] + g * c1[2];
	cn[1] = -c1[3] * c1[0] - delta * c1[1];
	cn[2] = ((1 - c1[2] * c1[2]) * (s * c1[0] + c1[2]) - beta * c1[2]) / e;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Synchronisation of Two, Four Dimensional Chaotic Systems with Cubic Nonlinearities Images
	Servilia OANCEA,  Ioan GROSU, Andrei Victor OANCEA
***************************************************************************/

int	DoSynchronisation2by4D(void)

    {
    double	i, c1[8], cn[8], b, c, d, e1, e2, e3, e4, k;
    DWORD	ColourSlave, ColourMaster;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z
    c1[3] = param[13];    // t
    c1[4] = param[14];    // x
    c1[5] = param[15];    // y
    c1[6] = param[16];    // z
    c1[7] = param[17];    // t

    e1 = e2 = e3 = e4 = 1.0;

    b = param[0];
    c = param[1];
    d = param[2];
    k = param[3];
    ColourMaster = (DWORD)param[4];
    ColourSlave = (DWORD)param[5];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 30.0 * (c1[1] - c1[0]) + c1[1] * c1[2] * c1[3];
	cn[1] = b * (c1[0] + c1[1]) - c1[0] * c1[2] * c1[3];
	cn[2] = -c * c1[2] + c1[0] * c1[1] * c1[3];
	cn[3] = -d * c1[3] + c1[0] * c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, (ColourMaster == 0) ? (DWORD)i % threshold : ColourMaster, i, 4, 1) < 0)
	    break;
	}
    c1[0] = k;    // x1
    c1[1] = k;    // y1
    c1[2] = k;    // z1
    c1[3] = k;    // t1

    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[4] = 30.0 * (c1[5] - c1[4]) + c1[5] * c1[6] * c1[7];
	cn[5] = b * (c1[4] + c1[5]) - c1[4] * c1[6] * c1[7];
	cn[6] = -c * c1[6] + c1[4] * c1[5] * c1[7];
	cn[7] = -d * c1[7] + c1[4] * c1[5] * c1[7];
	cn[0] = 30.0 * (c1[1] - c1[0]) + c1[1] * c1[2] * c1[3] + e1 * (c1[0] - c1[4]);
	cn[1] = 10.0 * (c1[0] + c1[1]) - c1[0] * c1[2] * c1[3] + e2 * (c1[1] - c1[5]);
	cn[2] = c1[2] + c1[0] * c1[1] * c1[2] + e3 * (c1[2] - c1[6]);
	cn[3] = -d * c1[3] + c1[0] * c1[1] * c1[2] + e3 * (c1[3] - c1[7]);
	if (DisplayOscillator(c1, cn, dt, (ColourSlave == 0) ? (DWORD)i % threshold : ColourSlave, i, 4, 1) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Synchronisation of Two coupled UNFractional-Order Chaotic Oscillators Images
	Xin Gao, Juebang Yu
	I DID NOT obbey the "fractional-order" (Marcus)
***************************************************************************/

int	DoSyncUNFractional(void)

    {
    double	i, c1[3], cn[3], a;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = -a * (c1[0] + c1[2] - ((c1[0] >= 0) ? 1.0 : -1.0));
	if (DisplayOscillator(c1, cn, dt, (DWORD)(i / 20.0) % threshold, i, 3, 1) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Synchronisation Phenomena of Two Simple RC Chaotic Circuits by a Capacitor Images
	Ayana Shimada, Yoko Uwate, Yoshifumi Nishio, Jingnin Xin 
***************************************************************************/

int	DoSyncPhenomena(void)

    {
    double	i, c1[4], cn[4], x1, x2, x3, x4, xn1, xn2, xn3, xn4, g, va, et, egt;
    double	f01, f02, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10;

    c1[0] = x1 = param[10];
    c1[1] = x2 = param[11];
    c1[2] = x3 = param[12];
    c1[3] = x4 = param[13];

    g = param[0];
    va = param[1];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	et = exp(-i);
	egt = exp(-g * i);
	f01 = (x1 - 1.0) * et + 1.0; 
	f02 = (x1 + 1.0) * et - 1.0;
	xn1 = (x2 > va) ? f01 : f02;
	f1 = ((x2 + x4) / 2.0 + 1.0) * et;
	f2 = (x2 - x4) / 2.0 * egt;
	f3 = ((x2 + x4) / 2.0 - 1.0) * et;
	f4 = f2;
	xn2 = (x1 > va) ? f1 + f2 - 1.0 : f3 + f4 + 1.0;
	f5 = (x3 - 1.0) * et + 1.0;
	f6 = (x3 + 1.0) * et - 1.0;
	xn3 = (x4 > va) ? f5 : f6;
	f7 = ((x2 + x4) / 2.0 + 1.0) * et;
	f8 = (x2 - x4) / 2.0 * egt;
	f9 = ((x2 + x4) / 2.0 - 1.0) * et;
	f10 = (x2 - x4) / 2.0 * egt;
	xn4 = (x3 > va) ? f7 - f8 - 1.0 : f9 - f10 + 1.0;
	x1 += xn1 * dt;
	x2 += xn2 * dt;
	x3 += xn3 * dt;
	x4 += xn4 * dt;
//	c1[0] = floor(x1 * exp(2.0)) / exp(3.0);
//	c1[1] = floor(x2 * exp(3.0)) / exp(3.0);
//	c1[2] = floor(x3 * exp(4.0)) / exp(4.0);
//	c1[3] = floor(x4 * exp(5.0)) / exp(5.0);
	c1[0] = x1;
	c1[1] = x2;
	c1[2] = x3;
	c1[3] = x4;
	cn[0] = cn[1] = cn[2] = cn[3] = 0.0;
	if (DisplayOscillator(c1, cn, dt, (DWORD)i % threshold, i, 4, 1) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Synchronisation Phenomena in Coupled Birkhoff-Shaw Chaotic Systems Using Nonlinear Controllers
	Christos K. Volos, Hector E. Nistazakis, Ioannis M. Kyprianidis, Ioannis N. Stouboulos and George S. Tombras 2016
	https://www.researchgate.net/requests/r41338629
***************************************************************************/

int	DoSyncPhenomenaCoupledBirkhoffShawChaoticSystems(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, real, imag;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = 1.0;	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    real = param[2];
    imag = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[1] + c1[0] - c * c1[0] * (c1[1] * c1[1]);
	cn[1] = -c1[0] - b * cos(d * i);
	cn[2] = real * cos(c1[1]) + imag * sin(c1[0]);
	if (DisplayOscillator(c1, cn, dt, (DWORD)i % threshold, i, 3, 1) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Synchronisation of Cyclic Coupled Hyperchaotic Systems and its Circuit Implementation
	K. S. Ojo, A. O. Adelakun, A. I. Egunjobi and E. I. Udoh 22.09.2019
	https://www.researchgate.net/publication/338407464
***************************************************************************/

int	DoSynchronisationCyclicCoupledHyperchaoticSystems(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z
    c1[3] = param[13];    // w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[0] - c1[1]) - c1[1] * c1[2] + c1[3];
	cn[1] = -b * c1[1] + c1[0] * c1[2];
	cn[2] = -c * c1[2] + d * c1[0] + c1[0] * c1[1];
	cn[3] = -e * (c1[0] + c1[1]);
	if (DisplayOscillator(c1, cn, dt, (DWORD)i % threshold, i, 4, 1) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Synchronisation Phenomena in Coupled Non-Identical Chaotic Circuits
	Ch. K. Volos, A. Giakoumis, I. M. Kyprianidis, I. N. Stouboulos H. E. Nistazakis and G. S. Tombras 15 September 2016
	https://pdfs.semanticscholar.org/4cb6/cb085e8e6a76182f9b7d1a91efe576fdd539.pdf
***************************************************************************/

int	DoSynchronisationPhenomena(void)

    {
    double	i, c1[4], cn[4], c, d;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z
    c1[3] = param[13];    // w

    c = param[0];
    d = param[1];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] - c1[0];
	cn[1] = -c1[0] * c1[2] + c1[3];
	cn[2] = c1[0] * c1[1] - c;
	cn[3] = -d * c1[1];
	if (DisplayOscillator(c1, cn, dt, (DWORD)i % threshold, i, 4, 1) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Synchronisation Phenomena of Two Chaotic Oscillators with Shifting Input Wave
	Yoshinori Doike, Yoko Uwate, Yoshifumi Nishio and Jingmin Xin 
***************************************************************************/

int	DoSyncPhenomena1 (void)

    {
    double	i, c1[4], cn[4], x1, x2, x3, x4, xn1, xn2, xn3, xn4, d, g, va, et, egt, edt, egdt;
    double	f01, f02, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10;

    c1[0] = x1 = param[10];
    c1[1] = x2 = param[11];
    c1[2] = x3 = param[12];
    c1[3] = x4 = param[13];

    g = param[0];
    va = param[1];
    d = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	et = exp(-i);
	egt = exp(-(1.0 + 2.0 * g) * i);
	edt = exp(-d * i);
	egdt = exp(-(1 + 2 * g) * d * i);
	f01 = (x1 - 1.0) * et + 1.0; 
	f02 = (x1 + 1.0) * et - 1.0;
	xn1 = (x2 > va) ? f01 : f02;
	f1 = ((x2 + x4) / 2.0 + 1.0) * et;
	f2 = (x2 - x4) / 2.0 * egt;
	f3 = ((x2 + x4) / 2.0 - 1.0) * et;
	f4 = f2;
	xn2 = (x1 > va) ? f1 + f2 - 1.0 : f3 + f4 + 1.0;
	f5 = (x3 - 1.0) * et + 1.0;
	f6 = (x3 + 1.0) * et - 1.0;
	xn3 = (x4 > va) ? f5 : f6;
	f7 = ((x2 + x4) / 2.0 + 1.0) * edt;
	f8 = (x2 - x4) / 2.0 * egdt;
	f9 = ((x2 + x4) / 2.0 - 1.0) * edt;
	f10 = (x2 - x4) / 2.0 * egdt;
	xn4 = (x3 > va) ? f7 - f8 - 1.0 : f9 - f10 + 1.0;
	x1 += xn1 * dt;
	x2 += xn2 * dt;
	x3 += xn3 * dt;
	x4 += xn4 * dt;
	c1[0] = x1;
	c1[1] = x2;
	c1[2] = x3;
	c1[3] = x4;
	cn[0] = cn[1] = cn[2] = cn[3] = 0.0;
	if (DisplayOscillator(c1, cn, dt, (DWORD)i % threshold, i, 4, 1) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Synchronising Nonautonomous Chaotic Circuits
	Thomas L. Carroll and Louis M. Pecora 1993
	https://www.researchgate.net/profile/Louis_Pecora/publication/3324428_Synchronizing_nonautonomous_chaotic_circuits/links/0046352556071229b3000000.pdf
***************************************************************************/

int	DoSynchronisingNonautonomousChaoticCircuits(void)

    {
    double	i, c1[3], cn[3], a, gamay, gamaz, b, fd, w, fx, gx;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z

    a = param[0];
    b = param[1];
    gamay = param[2];
    gamaz = param[3];
    fd = param[4];
    w = 2 * PI * fd;
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	fx = 0.5 * c1[0] + fabs(c1[0] - 1) - fabs(c1[0] + 1);
	gx = -3.8 + 0.5 * (fabs(c1[0] + 2.6) + fabs(c1[0] - 2.6) + fabs(c1[0] + 1.2) + fabs(c1[0] - 1.2));

	cn[0] = b * (c1[1] - c1[2]);
	cn[1] = b * (-gamay * c1[1] - gx + a * cos(w * i));
	cn[2] = b * (fx - gamaz * c1[2]);
	if (DisplayOscillator(c1, cn, dt, (DWORD)i % threshold, i, 3, 1) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	System with an Infinite Number of Equilibrium Points
	A Fractional-Order Chaotic System with an Infinite Number of Equilibrium Points
	Ping Zhou, Kun Huang, and Chun-de Yang 21 March 2013
***************************************************************************/

int	DoSystemInfinite(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[3];
	cn[1] = b * c1[0] - c1[0] * c1[2];
	cn[2] = c * c1[2] + e * c1[0] * c1[0];
	cn[3] = d * c1[1] - c1[3];
	if (DisplayOscillator(c1, cn, dt, (DWORD)(i / 20.0) % threshold, i, 4, 1) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	System with Multiple Attractors-Dynamic Analysis, Circuit Realisation and S-Box Design
	Qiang Lai, Akif Akgul, Chunbiao Li, Guanghui Xu and Unal Cavusoglu 27 December 2017 received from the authors
***************************************************************************/

int	DoSystemMultipleAttractorsDynamicAnalysis(void)

    {
    double	i, c1[3], cn[3], a, b, c, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    k = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] - c1[1] * c1[2] + c1[1];
	cn[1] = -b * c1[1] + c1[0] * c1[2];
	cn[2] = -c * c1[2] + c1[0] * c1[1] * c1[2] + k;
	if (DisplayOscillator(c1, cn, dt, (DWORD)(i / 20.0) % threshold, i, 3, 1) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Takagi-Sugeno Chaotic Oscillators or Sprott-390
	Application of Takagi-Sugeno fuzzy model to a class of 
	chaotic Synchronisation and anti-Synchronisation
	Diyi Chen, Weili Zhao, Julien Clinton Sprott, Xiaoyi Ma 6 April 2013 
***************************************************************************/

int	DoTakagiSugeno(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = d * c1[0] + c * c1[1] - c1[0] * c1[2] - c1[3];
	cn[2] = -b * c1[2] + c1[0] * c1[1];
	cn[3] = c1[0];
	if (DisplayOscillator(c1, cn, dt, (DWORD)i % threshold, i, 4, 1) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Tamari-original Chaotic Attractor Images
	http://www.bentamari.com/attractors.html
***************************************************************************/

int	DoTamari(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e, f, g, v, I;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];
    v = param[7];
    I = param[8];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = (c1[0] - a * c1[1]) * cos(c1[2]) - b * c1[1] * sin(c1[2]);
	cn[1] = (c1[0] + c * c1[1]) * sin(c1[2]) + d * c1[1] * cos(c1[2]);
	cn[2] = e + f * c1[2] + g * atan((1.0 - v) / (1.0 - I) * c1[0] * c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Taming Chaos by Linear Regulation with Bound Estimation
	Jiqiang Wang and Weijian Chen 16 March 2015
***************************************************************************/

int	DoTamingChaos(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, h;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    h = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[0] + c1[1] + b * c1[1] * c1[2];
	cn[1] = c * c1[1] - c1[0] * c1[2] + c1[2];
	cn[2] = d * c1[0] * c1[1] - h * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Tent + Logistic Maps-Complex-8
	Marcus Rezende April/2015
***************************************************************************/

int	DoTentPlusLogistic(void)

    {
    double	i, c1[4], cn[4];

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z
    c1[3] = param[13];    // w

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	c1[0] = 1.0 - 2.0 * fabs(c1[0] - 0.5);
	c1[2] = 1.0 - 2.0 * fabs(c1[2] - 0.5);
	if (c1[0] < 0.5)
	    {
	    cn[0] = 2.0 * c1[0];
	    cn[1] = (2.0 * c1[0] - c1[1]) / dt;
	    }
	else
	    {
	    cn[0] = 2.0 * (1.0 - c1[0]);
	    cn[1] = (2.0 * (1.0 - c1[0]) - c1[1]) / dt;
	    }
	cn[2] = 2.0 * c1[2] * (1.0 - c1[2]);
	cn[3] = (2.0 * c1[2] * (1.0 - c1[2]) - c1[3]) / dt;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 1.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Test for Chaos in a Fractional Order Financial System with Investment Incentive
	Baogui Xin1,2 and Yuting Li1 25 September 2013
***************************************************************************/

int	DoTestForChaos(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2] + (c1[1] - a) * c1[0];
	cn[1] = 1.0 - b * c1[1] - c1[0] * c1[0] + c1[3];
	cn[2] = -c1[0] - c * c1[2];
	cn[3] = d * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 60.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	The Dynamics of Coupled Oscillators
	Nigel Lawrence Holland 2008
	Victoria University of Wellington
***************************************************************************/

/* 
	// cancelled by Marcus 2019-03-09

int	DoTheDynamicsCoupledOscillators(void)

    {
    double	i, c1[3], cn[3], r, f, rn, fn, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    r = param[0];
    f = param[1];
    e = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	rn = 5 * (1 - r) * (r - 0.5) * r;
	fn = 1 + e * (1 - r);
	r += (rn * dt); 
	f += (fn * dt);

	cn[0] = rn * cos(fn);
	cn[1] = rn * sin(fn);
	c1[0] = r * cos(f);
	c1[1] = r * sin(f);
	cn[2] = sin(c1[0]) + cos(c1[1]);
	if (DisplayOscillator(c1, cn, 0.0, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }
*/

/**************************************************************************
	Theoretical Analysis and Adaptive Synchronisation of a 4D Hyperchaotic Oscillator I
	(including Marcus errors)
	T. Fonzin Fozin, J. Kengne, and F. B. Pelap & Marcus Rezende 27 February 2014
***************************************************************************/

int	DoTheoreticalHyperchaoticI(void)

    {
    double	i, c1[4], cn[4], e1, e2, alpha, gamma, fi, sigma;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w
    e1 = param[0];
    e2 = param[1];
    alpha = param[2];
    sigma = param[3];
    fi = param[4];

    gamma = alpha / 10.0;
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2];
	cn[1] = e1 * (c1[2] - c1[3] - gamma * fi);
	cn[2] = sigma * c1[0] - alpha * fi;
	cn[3] = (sigma * c1[0] - alpha * fi - e2 * (alpha * fi - c1[1])) / (1.0 + gamma * fi);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Theoretical Analysis and Adaptive Synchronisation of a 4D Hyperchaotic Oscillator II
	T. Fonzin Fozin, J. Kengne, and F. B. Pelap & Marcus Rezende 27 February 2014
***************************************************************************/

int	DoTheoreticalHyperchaoticII(void)

    {
    double	i, c1[4], cn[4], e1, e2, alpha, gamma, fi, sigma;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    e1 = param[0];
    e2 = param[1];
    alpha = param[2];
    sigma = param[3];
    fi = param[4];
    gamma = alpha / 10.0;
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2];
	fi = -1.0 + pow(exp(1.0), c1[3]);
	cn[1] = e1 * (c1[2] - c1[3] - gamma * fi);
	cn[2] = sigma * c1[2] - c1[0] - alpha * fi;
	cn[3] = (sigma * c1[2] - c1[0] - alpha * fi - e2 * (alpha * fi - c1[1])) / (1.0 + gamma * fi);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Theoretical Analysis and Adaptive Synchronisation of a 4D Hyperchaotic Oscillator III
	T. Fonzin Fozin, J. Kengne, and F. B. Pelap & Marcus Rezende 27 February 2014
***************************************************************************/

int	DoTheoreticalHyperchaoticIII(void)

    {
    double	i, c1[4], cn[4], e1, e2, alpha, gamma, fi, sigma;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w
    e1 = param[0];
    e2 = param[1];
    alpha = param[2];
    sigma = param[3];

    gamma = alpha / 10.0;
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[2];
	fi = -1.0 + pow(exp(1.0), c1[3]);
	cn[1] = e1 * (c1[2] - c1[3] - gamma * fi);
	cn[2] = sigma * c1[2] - c1[0] - alpha * fi;
	cn[3] = (sigma * c1[2] - c1[0] - alpha * fi - e2 * (alpha * fi - c1[1])) / (1.0 + gamma * (fi + 1.0));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Theoretical Analysis and Circuit Verification for Fractional-Order Chaotic Behavior in a New Hyperchaotic System
	Jay Prakash Singh and B. K. Roy 30 June 2016
***************************************************************************/

int	DoTheoreticalCircuitVerification(int kind)

    {
    double	i, c1[4], cn[4], b1, b2, b3, b4;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    b1 = param[0];
    b2 = param[1];
    b3 = param[2];
    b4 = param[3];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = b1 * (c1[1] + 0.2 * c1[0] - 2.0 * c1[0] * c1[0] * c1[0]);
	cn[1] = b2 * c1[0] - c1[1] + c1[2] + c1[3];
	if (kind == 0)
	    cn[2] = -b3 * c1[1] + c1[3];
	else
	    cn[2] = -b3 - c1[1] + c1[3];
	cn[3] = -b4 * c1[0];					// this LOG (ABS(  ) was my invention; the original was only “x” 
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

int	DoTheoreticalCircuitVerificationI(void)
    {
    return DoTheoreticalCircuitVerification(0);
    }
int	DoTheoreticalCircuitVerificationII(void)
    {
    return DoTheoreticalCircuitVerification(1);
    }

/**************************************************************************
	Third order Chaotic Oscillator  in 4 Dimensions Images
***************************************************************************/

int	DoThirdOrder4D(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[1] = c1[0];							// first derivative
	cn[2] = c1[1];							// second derivative
	cn[3] = c1[2];							// third derivative
	cn[0] = -(-c1[3] + a * c1[2] + b * c1[1] - c1[1] * c1[1] * c1[1] + d) / c;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Third order Chaotic Oscillator  in 7 Dimensions Images
	Seven-Dimensional Third -Order Hyperchaotic System and It's Applications in Image Encryption
	Duanzeng Liu, Jianliang Zhu, Hao Sun 2013
***************************************************************************/

int	DoThirdOrder7D(void)

    {
    double	i, c1[7], cn[7], a, b, c, d, e, f, g, h;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z
    c1[3] = param[13];    // w
    c1[4] = param[14];    // q
    c1[5] = param[15];   // r
    c1[6] = param[16];   // s

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];
    h = param[7];
    totpasses = 10;

    InitOscillator(c1, 7);						// pass in number of dimensions
    for (i = 0; i < iterations; i += dt)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
//	cn[0] = -(-c1[3] + a * c1[2] + b * c1[1] - c1[1] * c1[1] * c1[1] + d) / c;
	cn[0] = -a * c1[0] + a * c1[4] - b * c1[4] * c1[5] * c1[6];
	cn[1] = -c * c1[1] - d * c1[5] + c1[0] * c1[5] * c1[6];
	cn[2] = -a * c1[2] + a * c1[4] - g * c1[0] * c1[1] * c1[6];
	cn[3] = -a * c1[3] + e * c1[0] + c1[0] * c1[1] * c1[2];
	cn[4] = -a * c1[4] + e * c1[6] - c1[1] * c1[2] * c1[3];
	cn[5] = -e * c1[5] + e * c1[4] + c1[2] * c1[3] * c1[4];
	cn[6] = -b * c1[6] + f * c1[1] - h * c1[3] * c1[4] * c1[5];
//	cn[1] = c1[0];							// first derivative
//	cn[2] = c1[1];							// second derivative
//	cn[3] = c1[2];							// third derivative
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / dt) % threshold), i, 7, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Third-Order Generalised Memristor-Based Chaotic Circuit and its Complex Dynamics
	Li Xu, Ning Wang, Han Bao, Quan Xu, Mo Chen and Bocheng Bao 2018
	Sent from Research Gate
***************************************************************************/

int	DoThirdOrderGeneralisedMemristorBasedChaoticCircuit(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * log(fabs(c * cosh(c1[2]))) - a * log(fabs(c1[0] + c));
	cn[1] = b * (c1[1] + c1[2]);
	cn[2] = -c1[1] - (c1[0] - c) * tanh(c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Third-Order RLCM-Four-Elements-based Chaotic Circuit and its Coexisting Bubbles
	Bocheng Bao, Li Xu, Ning Wang, Han Bao, Quan Xu and Mo Chen 26 June 2018
	https://www.researchgate.net/publication/326039136_Third-order_RLCM-four-elements-based_chaotic_circuit_and_its_coexisting_bubbles and Sent by the first author
***************************************************************************/

int	DoThirdOrderRLCMFourElements(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];    // x
    c1[1] = param[11];    // y
    c1[2] = param[12];    // z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i += dt)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * log(fabs(c * cosh(c1[2]))) - a * log(fabs(c1[0] + c));
	cn[1] = b * (c1[1] + c1[2]);
	cn[2] = -c1[1] - (c1[0] + c) * tanh(c1[2]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 1.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Thomas cyclically symetric attractor Images
***************************************************************************/

int	DoThomas(void)

    {
    double	i, c1[3], cn[3], b, val;
    int		j, ptr;
    char	trig[4];

    c1[0] = param[10]; // x
    c1[1] = param[11]; // y
    c1[2] = param[12]; // z

    b = param[0];
    totpasses = 10;
    strcpy(trig, OscillatorSpecific[subtype].function);

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
//	xn = -b*x+sin(y);
//	yn = -b*y+sin(z);
//	zn = -b*z+sin(x);
	for (j = 0;j < 3; j++)
	    {
	    ptr = (j + 1) % 3;
	    switch(trig[j])
		{
		case 'S':
		    val = sin(c1[ptr]);
		    break;
		case 'C':
		    val = cos(c1[ptr]);
		    break;
		case 'T':
		    val = tan(c1[ptr]);
		    break;
		}
	    cn[j] = -b*c1[j]+val;
	    }
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Three-Dimensional Memristive Hindmarsh–Rose Neuron Model with Hidden Coexisting Asymmetric Behaviors
	Bocheng Bao, Aihuang Hu, Han Bao, Quan Xu, Mo Chen and Huagan Wu  28 February 2018
	https://www.hindawi.com/journals/complexity/2018/3872573/
***************************************************************************/

int	DoThreeDimensionalMemristiveHindmarshRoseNeuronModel(void)

    {
    double	t, c1[3], cn[3], a, b, c, d, k, i;

    c1[0] = param[10]; // x
    c1[1] = param[11]; // y
    c1[2] = param[12]; // z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    k = param[4];
    i = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (t = 0; t < iterations; t++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(t * totpasses / iterations);
	cn[0] = c1[1] - a * c1[0] * c1[0] * c1[0] + b * c1[0] * c1[0] + i + k * c1[2] * c1[0];
	cn[1] = c - d * c1[0] * c1[0] - c1[1];
	cn[2] = c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)t % threshold), t, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Three Dimensional Spherical Chaotic Attractor 
	ZENGHUI WANG, YANXIA SUN, SHIJIAN CANG DECEMBER, 16, 2010
***************************************************************************/

int	DoThreeDimensional(void)

    {
    double	i, c[3], cn[3], a1, a2, a3, b, c1, c2, c3, c4, d, e = exp(1.0);

    c[0] = param[10];	// x
    c[1] = param[11];	// y
    c[2] = param[12];	// z

    e = 0.5;	    // another Marcus Norty!!!

    a1 = param[0];
    a2 = param[1];
    a3 = param[2];
    b = param[3];
    c1 = param[4];
    c2 = param[5];
    c3 = param[6];
    c4 = param[7];
    d = param[8];
    totpasses = 10;

    InitOscillator(c, 3);							// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a1 * c[0] - a2 * c[1] + a3 * c[2] + 2.0 * (1.0 - pow(e, (-200.0 * sin(c[1]))) / (1.0 + pow(e, (-200.0 * sin(c[1])))));
	cn[1] = -d * c[0] * c[2] + b + e * c[0];
	cn[2] = c1 * c[0] * c[1] + c2 * c[1] * c[2] + c3 * c[2] + c4;
	if (DisplayOscillator(c, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Three Layer Chaotic Oscillator Images
***************************************************************************/

int	DoThreeLayer(void)

    {
    double	i, ct[3], cn[3], a1, a2, a3, b, c, c1, c2, c3, d;

    ct[0] = param[10];	// x
    ct[1] = param[11];	// y
    ct[2] = param[12];	// z

    a1 = param[0];
    a2 = param[1];
    a3 = param[2];
    c1 = param[3];
    c2 = param[4];
    c3 = param[5];
    d = param[6];
    totpasses = 10;

    InitOscillator(ct, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	b = d * a2 * a2 * c3 * c3 / (32.0 * a3 * a3 * c2 * c2) * sqrt(-a3 * c2 / (a1 * c1));
	c = 1.0 / a2 * (a2 * a2 * a3 * a3 / 4.0 / a3 / c2 - b / d * (a3 * c2 + a1 * c2));
	cn[0] = a1 * ct[0] - a2 * ct[1] + a3 * ct[2];
	cn[1] = -d * ct[0] * ct[2] + b;
	cn[2] = c1 * ct[0] * ct[1] + c2 * ct[1] * ct[2] + c3 * ct[2] + c;
	if (DisplayOscillator(ct, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Time-Reversal Symmetry and Covariant Lyapunov Vectors for Simple Particle Models in and Out of Thermal Equilibrium
	Hadrien Bosetti, Harald A. Posch, Christoph Dellago and William G. Hoover February 26, 2018
***************************************************************************/

int	DoTimeReversalSymmetry(void)

    {
    double	i, c1[4], cn[4], epsilon, tq;

    c1[0] = param[10]; // x
    c1[1] = param[11]; // y
    c1[2] = param[12]; // z
    c1[3] = param[13]; // w

    epsilon = param[0];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	tq = 1.0 + epsilon * ((exp(c1[0]) - exp(-c1[0])) / (exp(c1[0]) + exp(-c1[0])));
	cn[0] = c1[1];
	cn[1] = -c1[0] - c1[2] * c1[1];
	cn[2] = c1[1] * c1[1] - tq - c1[2] * c1[3];
	cn[3] = c1[2] * c1[2] - tq;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Tokamaks Boundaries Fractal Images
	Fractal and Wada exit basin boundaries in tokamaks
	Jefferson S. E. Portela, Ibere L. Caldas Ricardo L. Viana, Miguel A. F. Sanjuan
	July 9, 2004)
***************************************************************************/

int	DoTokamaks(void)

    {
    double	i, c1[3], cn[3], a1, a, r, teta, q, gamma, t, rn, tetan;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    r = param[0];
    teta = param[1];
    a1 = param[2];
    gamma = param[3];
    a = param[4];
    q = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	rn = r / (1.0 - a1 * sin(teta));
	t = 2.0 * PI * a * a / q / r * r * (1.0 + (1.0 - pow(1.0 - r * r / a * a, (gamma + 1.0)) * teta * (a - r)));
	tetan = teta + 2.0 * PI * t * r + a1 * cos(teta);
	cn[0] = 0.0;
	cn[1] = 0.0;
	cn[2] = 0.0;
	r += rn * dt;
	teta += tetan * dt;
	c1[0] = r * cos(teta);
	c1[1] = r * sin(teta);
	c1[2] = c1[0] + sqrt(fabs(c1[1]));
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Torus and Fixed Point Attractors of a New Hyperchaotic 4D System
	Changjin Xu, Zixin Liu, Yicheng Pang, Sayed Saifullah and Javed Khan 17 February 2023
	https://www.sciencedirect.com/science/article/abs/pii/S1877750323000340....https://doi.org/10.1016/j.jocs.2023.101974
***************************************************************************/

int	DoTorusFixedPointAttractors(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e, f;

    c1[0] = param[10]; // x
    c1[1] = param[11]; // y
    c1[2] = param[12]; // z
    c1[3] = param[13]; // w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[2]);
	cn[1] = c1[3] * (b - c1[2]) - c * c1[0];
	cn[2] = c1[3] * c1[1] - d * c1[2];
	cn[3] = e * c1[0] * c1[1] - f * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Transient Chaos in a Closed Chemical System Images
	Stephen K. Scott, Bo Peng, Alison S. Tomlin, Kenneth Showaltera*)
	4 October 1990 : REM  a very old program.
***************************************************************************/

int	DoTransientChaos(void)

    {
    double	i, ct[4], cn[4], sigma, k, delta, ro;

    ct[0] = param[10];	// mu
    ct[1] = param[11];	// alpha
    ct[2] = param[12];	// beta
    ct[3] = param[13];	// gamma

    sigma = param[0];
    k = param[1];
    delta = param[2];
    ro = param[3];
    totpasses = 10;

    InitOscillator(ct, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -ro * ct[0] * (k + ct[3]);
	cn[1] = ct[0] * (k + ct[3]) - ct[1] * ct[2] * ct[2] - ct[1];
	cn[2] = 1.0 / sigma * (ct[1] * ct[2] * ct[2] + ct[1] - ct[2]);
	cn[3] = 1.0 / delta * (ct[2] - ct[3]);
	if (DisplayOscillator(ct, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Transient Chaos in Fractional Bloch Equations
	Sachin Bhalekar, Varsha Daftardar-Gejji, Dumitru Baleanu and Richard Magin 2012
	https://reader.elsevier.com/reader/sd/pii/S0898122112000909?token=5FF5DF270A19B512F481F1BEADD2E74E2A51D6FDB4C10FDCF3EC56997753C4691ACB0E72D194FE4FCB4DF782DFC6CA3E
***************************************************************************/

int	DoTransientChaosFractionalBlochEquations(void)

    {
    double	i, c1[3], cn[3], lambda, psi, t1, t2, delta;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    lambda = param[0];
    psi = param[1];
    t1 = param[2];
    t2 = param[3];
    delta = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = delta * c1[1] + lambda * c1[2] * (c1[0] * sin(psi) - c1[1] * cos(psi)) - 1 / t2 * c1[0];
	cn[1] = -delta * c1[0] - c1[2] + lambda * c1[2] * (c1[1] * sin(psi) + c1[0] * cos(psi)) - 1 / t2 * c1[1];
	cn[2] = c1[1] - lambda * sin(psi) * (c1[0] *c1[0] + c1[1] * c1[1]) - 1 / t1 * (c1[2] - 1);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Transport Properties in the Standard Map Images
	Transport properties in the standard map with long time
	Lydia Bouchara1, Ouerdia Ourrad Meziani2, and Xavier Leoncini 7-10 June 2014
***************************************************************************/

int	DoTransport(void)

    {
    double	i, ct[3], cn[3], k, m;

    ct[0] = param[10];	// x
    ct[1] = param[11];	// y
    ct[2] = param[12];	// z

    k = param[0];
    m = param[1];
    totpasses = 10;

    InitOscillator(ct, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = ct[0] + k * sin(ct[1] * 2.0 * PI) - ct[1];
	cn[1] = -(ct[1] + ct[0] * 2.0 * PI + sin(2 * PI * ct[0]) - 3.0 * ct[0]);
	cn[2] = m * sin(2 * PI * ct[0]) * sqrt(fabs(ct[1]));
	if (DisplayOscillator(ct, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Trial and Error Chaotic Oscillator Images
	My own full regretion chaotic oscillator
	Marcus Rezende 09/12/2014
***************************************************************************/

int	DoTrialAndError(void)

    {
    double	i, ct[3], cn[3];

    ct[0] = param[10]; // x
    ct[1] = param[11]; // y
    ct[2] = param[12]; // z

    totpasses = 10;

    InitOscillator(ct, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = ct[0] - pow(ct[1], 3) + pow(ct[2], 5);
	cn[1] = ct[2] * pow(ct[0], 7) + pow(ct[2], 4);
	cn[2] = ct[1] * sin(i) + ct[1] * cos(i) + ct[2] * sin(ct[1]);
	if (DisplayOscillator(ct, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Trilobyte (Dynamics of a New Hyperchaotic System with Only One Equilibrium Point)
	Xiang Li and Ranchao Wu 2 July 2013
***************************************************************************/

int	DoTrilobyte(void)

    {
    double	i, c1[4], cn[4], a, b, c, d, e, v;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    v = param[5];

    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = c * c1[0] - c1[0] * c1[2] - c1[1] + e * c1[3];
	cn[2] = pow(c1[0], 4) + c1[1] * c1[1] - b * c1[2];
	cn[3] = -d * c1[1] + v;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Triternion Images
	Attributed to Russell Walsmith
	Written by Paul Bourke
	August 2005 
	The images shown here are based upon triternion arithmetic and are created 
	in a similar way to the Mandelbrot set. That is, a function is iterated with 
	some dependency on a position on the complex plane. The outcome of the series 
	(infinity, zero, or otherwise) determines the state of that position and 
	ultimately how it is represented graphically. Generally the distinction is 
	made between the series tending to zero (inside the set) and other behavior 
	(outside the set). 
	The difference here is the function being iterated is not in the complex plane 
	but rather in three dimensions. To determine whether the position in 3D is inside 
	or outside the set, a test is made whether the magnitude of the series (a vector)
	in 3D tends to zero. The result, as shown in the images is a Mandelbrot like outline, 
	extruded in 3D space over some limited range. 
***************************************************************************/
/*
#define		NMAX	    2000
#define		MAX(a,b)    (a >= b ? a : b)
//int		nvol = 512;
int		nvol = 120;
float		***vol = NULL;
double		xmin = -2,ymin = -1.375,zmin = -1.25;
double		xmax = 0.75,ymax = 1.375,zmax = 1.5;
*/

int Eval(double x,double y,double z,int nmax)
    {
    int n = 0;
    double x1 = 0,y1 = 0,z1 = 0;
    double a,b,c;
    double zz = 0;

    while (zz < 100 && n < nmax) 
	{
	a = x1*x1 + 2*y1*z1;
	b = z1*z1 + 2*x1*y1;
	c = y1*y1 + 2*x1*z1;
	x1 = a + x;
	y1 = b + y;
	z1 = c + z;
	zz = x1*x1 + y1*y1 + z1*z1;
	n++;
	}
    return(n);
    }

/*
int	DoTriternion(void)
    {
    int i,j,k,n;
    double x,y,z;
    double vf,vmax = 0;
    DWORD colour;
    int	u, v;

   // Create volumetric data
    vol = (float ***)malloc(nvol*sizeof(float **));
    for (i=0;i<nvol;i++)
	vol[i] = (float **)malloc(nvol*sizeof(float *));
    for (i=0;i<nvol;i++)
	for (j=0;j<nvol;j++)
	    vol[i][j] = (float *)malloc(nvol*sizeof(float));
    for (i=0;i<nvol;i++)
	for (j=0;j<nvol;j++)
	    for (k=0;k<nvol;k++)
		vol[i][j][k] = 0;

    totpasses = 10;
   // Compute volume
    for (k=0;k<nvol;k++) 
	{
	z = zmin + k * (zmax - zmin) / (nvol - 1);
//	if (k % (nvol / 10) == 0)
//	    fprintf(stderr,"z = %g\n",z);

	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(k * totpasses / nvol);
	for (j=0;j<nvol;j++) 
	    {
	    y = ymin + j * (ymax - ymin) / (nvol - 1);

	    for (i=0;i<nvol;i++) 
		{
		x = xmin + i * (xmax - xmin) / (nvol - 1);
		n = Eval(x,y,z,NMAX);
		vol[i][j][k] = (float)n;
		vmax = MAX(vmax,vol[i][j][k]);
		} // i
	    } // j
	} // k
//    fprintf(stderr,"Maximum value: %g\n",vmax);

   // Write raw file for Drishti
//    fptr = fopen("triternion.raw","w");
//    fputc(0,fptr);
//    fwrite(&nvol,sizeof(int),1,fptr);
//    fwrite(&nvol,sizeof(int),1,fptr);
//    fwrite(&nvol,sizeof(int),1,fptr);
    for (i=0;i<nvol;i++) 
	{
	for (j=0;j<nvol;j++) 
	    {
	    for (k=0;k<nvol;k++) 
		{
		vf = vol[i][j][nvol / 2] / vmax; // 0 ... 1
//		vf = vol[i][j][k] / vmax; // 0 ... 1
		vf = pow(vf,0.2);         // Non linear stretching of histogram
		colour = (DWORD)(255 * vf);             // 0 ... 255
//		colour = (DWORD)(vol[i][j][k]);             // 0 ... 255
//		colour = (DWORD)(vol[i][j][nvol / 2]);             // 0 ... 255
		u = (long)((x - hor) * xscale);
		v = (long)((vert + mandel_width - y) * yscale);
//		plot(u, v, colour);
		plot(i + 100, j + 100, colour);
//		fwrite(&v,1,1,fptr);
		}
	    }
	}
    return 0;
    }
*/

int	DoTriternion(void)

    {
    int n = 0, k;
//    int	u, v;
    double x1 = 0.0,y1 = 0.0,z1 = 0.0;
    double c1[3], cn[3], x, y, z;
    double zz = 0.0;
    double i;
    double xGap, yGap;
   
    x = c1[0] = param[10];	// x
    y = c1[1] = param[11];	// y
    z = c1[2] = param[12];	// z

    totpasses = 10;
    threshold = (long)iterations;

    InitOscillator(c1, 3);						// pass in number of dimensions
    xGap = mandel_width * ScreenRatio / (double) xdots;
    yGap = mandel_width / (double) ydots;
    for (z = param[0], k = 0; z < param[1]; z += yGap, k++)
	{
	curpass = (int)(k * totpasses * yGap / (param[1] - param[0]));
	for (x = hor; x < hor + mandel_width * ScreenRatio; x += xGap)
	    {
	    for (y = vert; y < vert + mandel_width; y += yGap)
		{
		if (user_data(GlobalHwnd) == -1)				// user pressed a key?
		    return -1;
		n = Eval(x,y,z,threshold);
/*
		zz = 0.0;
		n = 0;
		x1 = 0.0;
		y1 = 0.0;
		z1 = 0.0;
		while (zz < 4.0 && n < threshold) 
		    {
		    a = x1*x1 + 2.0*y1*z1;
		    b = z1*z1 + 2.0*x1*y1;
		    c = y1*y1 + 2.0*x1*z1;
		    x1 = a + x;
		    y1 = b + y;
		    z1 = c + z;
		    zz = x1*x1 + y1*y1 + z1*z1;
		    n++;
		    }
		
*/
		c1[0] = x;
		c1[1] = y;
		c1[2] = z * 5.0;
		cn[0] = 0.0;
		cn[1] = 0.0;
		cn[2] = 0.0;
		i = (double) n;
		if (n < threshold)
		    {
//		    u = (long)((x - hor) * xscale);
//		    v = (long)((vert + mandel_width - y) * yscale);
//		    plot(u, v, (DWORD)n);
		    if (DisplayOscillator(c1, cn, yGap, ((DWORD)(i * 1.0) % threshold), i, 3, 0) < 0)
			break;
		    }
		}
	    }
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Tritrophic Food Chains Images
	Synchronisation AND PEAK-TO-PEAK DYNAMICS IN NETWORKS OF LOW-DIMENSIONAL CHAOTIC OSCILLATORS
	STEFANO MAGGI. and SERGIO RINALDI February 24, 2006
***************************************************************************/

int	DoTritrophicFoodChains(void)

    {
    double	i, c1[3], cn[3], a2, b2, e2, d2, a3, b3, e3, d3, r, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a2 = param[0];
    b2 = param[1];
    e2 = param[2];
    d2 = param[3];
    a3 = param[4];
    b3 = param[5];
    e3 = param[6];
    d3 = param[7];
    r = param[8];
    k = param[9];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = r * c1[0] * (1.0 - c1[0] / k) - a2 * c1[0] / (b2 + c1[0]) * c1[1];	// resource
	cn[1] = e2 * a2 * c1[0] / (b2 + c1[0]) * c1[1] - d2 * c1[1] - a3 * c1[1] / (b3 + c1[1]) * c1[2];	// prey
	cn[2] = e3 * a3 * c1[1] / (b3 + c1[1]) * c1[2] - d3 * c1[2];			// predator
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 20.0) % threshold), i, 3, 2) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Trumpets Chaotic Oscillator Images
	The analysis of complex behaviours of a novel three dimensional 
	autonomous system Dong Gao-Gao, Zheng Song, Tian Li-Xin, Du Rui-Jin and Sun Mei 
	Received 25 January 2010
***************************************************************************/

int	DoTrumpets(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e, f, g, h;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];
    h = param[7];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * c1[0] * c1[2] - b * c1[0] + c * c1[1] * c1[2];
	cn[1] = c1[2] + d * c1[1] - e * c1[0] * c1[2];
	cn[2] = f * c1[0] * c1[1] - g * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Tsucs Chaotic Oscillator Images
***************************************************************************/

int	DoTsucs(void)

    {
    double	i, c1[3], cn[3], a, c, d, e, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    c = param[1];
    d = param[2];
    e = param[3];
    f = param[4];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + d * c1[0] * c1[2];
	cn[1] = f * c1[1] - c1[0] * c1[2];
	cn[2] = c * c1[2] + c1[0] * c1[1] - e * c1[0] * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Tsucs Chaotic Oscillator + Marcus Images
	A New Three-Scroll Unified Chaotic System Coined
	Lin Pan, Wuneng Zhou, Jian'an Fang , Dequan Li 10 March 2010
***************************************************************************/

int	DoTsucsMarcus(void)

    {
    double	i, c1[4], cn[4], alpha, gamma, m;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    alpha = param[0];
    gamma = param[1];
    m = param[2];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = (20.0 * alpha + 40.0) * (c1[1] - c1[0]) + (6.0 * alpha + 4.0) / 25.0 * c1[0] * c1[2];
	cn[1] = (55.0 - 90.0 * alpha) * c1[0] + (5.0 * alpha + 20.0) * c1[1] - c1[0] * c1[2];
	cn[2] = -13.0 / 20.0 * c1[0] * c1[0] + c1[0] * c1[1] + (11.0 - 6.0 * alpha) / 6.0 * c1[2] + m;
	cn[3] = gamma * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Tumor Growth Model Images
	TOPOLOGICAL COMPLEXITY AND PREDICTABILITY IN THE DYNAMICS
	OF A TUMOR GROWTH MODEL WITH SHILNIKOV’S CHAOS JORGE DUARTE, CRISTINA JANUARIO, 
	CARLA RODRIGUES, JOSEP SARDANYES February 2, 2013
***************************************************************************/

int	DoTumorGrowth(void)

    {
    double	i, c1[3], cn[3], a12, a21, a13, a31, r2, r3, d3, k3;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a12 = param[0];
    a21 = param[1];
    a13 = param[2];
    a31 = param[3];
    r2 = param[4];
    r3 = param[5];
    d3 = param[6];
    k3 = param[7];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] * (1.0 - c1[0]) - a12 * c1[0] * c1[1] - a13 * c1[0] * c1[2];
	cn[1] = r2 * c1[1] * (1.0 - c1[1]) - a21 * c1[0] * c1[1];
	cn[2] = r3 * c1[0] * c1[2] / (c1[0] + k3) - a31 * c1[0] * c1[2] - d3 * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Two Hyperchaotic Systems with Four-wing Attractors and Their Synchronisation
	Yandong Chu, Yingxiang Chang, Xinlei An and Jiangang Zhang  JULY 2011
***************************************************************************/

int	DoTwoHyperchaoticSystems(void)

    {
    double	i, c1[6], cn[6], a, b, c, k1, k2;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    k1 = param[3];
    k2 = param[4];
    totpasses = 10;

    InitOscillator(c1, 6);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = -c1[0] * c1[2] + c * c1[1] + k1 * (c1[3] - c1[4]);
	cn[2] = c1[0] * c1[1] - b * c1[2];
	cn[3] = a * (c1[4] - c1[3]);
	cn[4] = -c1[3] * c1[5] + c * c1[4] + k2 * (c1[0] - c1[1]);
	cn[5] = c1[3] * c1[4] - b * c1[5];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Two-Time Synchronism and Induced Synchronisation
	Przemyslaw Szlachetka, Krzysztof Grygiel and Marcin Misiak November 15, 2017)
	https://arxiv.org/pdf/nlin/0202025.pdf
***************************************************************************/

int	DoTwoTimeSynchronism(void)

    {
    double	i, c1[8], cn[8], omega, a, epsilon, alpha, gamma, omega1, omega2, s1, s2;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w
    c1[6] = param[16];	// p
    c1[7] = param[17];	// q

    omega = param[0];
    a = param[1];
    epsilon = param[2];
    alpha = param[3];
    gamma = param[4];
    omega1 = param[5];
    omega2 = param[6];
    s1 = param[7];
    s2 = param[8];
    totpasses = 10;

    InitOscillator(c1, 8);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1] * (1 + epsilon * (c1[1] * c1[1] + omega * omega * c1[0] * c1[0])) - gamma * c1[0];
	cn[1] = -omega * omega * c1[0] * (1 + epsilon * (c1[1] * c1[1] + omega * omega * c1[0] * c1[0])) - gamma * c1[1] + alpha * c1[2] + a * cos(omega1 * i);
	cn[2] = c1[3] * (1 + epsilon * (c1[3] * c1[3] + omega * omega * c1[2] * c1[2])) - gamma * c1[2];
	cn[3] = -omega * omega * c1[2] * (1 + epsilon * (c1[3] * c1[3] + omega * omega * c1[2] * c1[2])) - gamma * c1[3] + alpha * c1[0] + a * cos(omega2 * i);
	cn[4] = c1[5] * (1 + epsilon * (c1[5] * c1[5] + omega * omega * c1[4] * c1[4])) - gamma * c1[4] + s1 * (c1[0] - c1[4]);
	cn[5] = -omega * omega * c1[4] * (1 + epsilon * (c1[5] * c1[5] + omega * omega * c1[4] * c1[4])) - gamma * c1[5] + alpha * c1[6] + a * cos(omega1 * i) + s1 * (c1[1] - c1[5]);
	cn[6] = c1[7] * (1 + epsilon * (c1[7] * c1[7] + omega * omega * c1[6] * c1[6])) - gamma * c1[6] + s2 * (c1[2] - c1[6]);
	cn[7] = -omega * omega * c1[6] * (1 + epsilon * (c1[7] * c1[7] + omega * omega2 * c1[6] * c1[6])) - gamma * c1[7] + alpha * c1[4] + a * cos(omega2 * i) + s2 * (c1[3] - c1[7]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 8, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Ueda Chaotic Oscillator Images
***************************************************************************/

int	DoUeda(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[0] * c1[0] * c1[0] - b * c1[1] + a * sin(c * c1[2]);
	cn[2] = c;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Ultimate Bound of a 3D Chaotic System and Its Application in Chaos Synchronisation
	Jiezhi Wang, Qing Zhang, Zengqiang Chen, and Hang Li 14 July 2014
***************************************************************************/

int	DoUltimateBound(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e, f, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -a * c1[0] + b * c1[1] + c1[1] * c1[2];
	cn[1] = c * c1[0] - d * c1[1] - c1[0] * c1[2];
	cn[2] = e * c1[0] - f * c1[2] + g * c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Uncertain Destination Dynamics of a Novel Memristive 4D Autonomous System
	Z.T. Njitacke, J. Kengne, R. Wafo Tapche, F.B. Pelap - 4 January 2018 - received from the authors
***************************************************************************/

int	DoUncertainDestinationDynamics(void)

    {
    double	i, c1[4], cn[4], sigma, gamma, alpha, beta, eta;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    sigma = param[0];
    gamma = param[1];
    alpha = param[2];
    beta = param[3];
    eta = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = sigma * c1[2];
	cn[2] = c1[0] - gamma * c1[1] - c1[2] - (-eta + beta * fabs(c1[3])) * c1[0];
	cn[3] = -alpha * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Unilateral Coupling of Two X-Band Gunn Oscillators 
	EFFECTS OF UNILATERAL COUPLING BETWEEN TWO CHAOTIC X-BAND GUNN OSCILLATORS
	B. C. SARKAR, S. SARKAR, C. KOLEY, A. K. GUIN and T. BANERJEE June 18, 2013
***************************************************************************/

int	DoUnilateralCoupling(void)

    {
    double	i, c[4], cn[4], a1, a2, b1, b2, c1, c2, d1, d2, qs, omega, k = 0.2;

    c[0] = param[10];	// x
    c[1] = param[11];	// y
    c[2] = param[12];	// z
    c[3] = param[13];	// w

    a1 = param[0];
    a2 = param[1];
    b1 = param[2];
    b2 = param[3];
    c1 = param[4];
    c2 = param[5];
    d1 = param[6];
    d2 = param[7];
    qs = param[8];
    omega = param[9];
    totpasses = 10;

    InitOscillator(c, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c[1];
	cn[1] = a1 * c[0] - b1 * c[0] * c[0] * c[0] + c1 * c[1] - d1 * c[1] * c[1] * c[1] + qs * cos(omega * i);
	cn[2] = c[3];
	cn[3] = a2 * c[2] - b2 * c[2] * c[2] * c[2] + c2 * c[3] - d2 * c[3] * c[3] * c[3] + k * (c[0] - c[2]) + qs * cos(omega * i);
	if (DisplayOscillator(c, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Unimodal Chaotic Attractor Images
***************************************************************************/

int	DoUnimodal(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e, f, g, h, j, k, l, m;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    
    l = 5.29;
    m = 750.0;

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];
    h = param[7];
    j = param[8];
    k = param[9];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = a * c1[0] + b * c1[1] - c1[0] * c1[1] - (d * c1[2] + e * c1[0] / (c1[0] + c));
	cn[1] = f + g * c1[2] - h * c1[1] - (j * c1[0] * c1[1] / (c1[1] + c));
	cn[2] = k + l * c1[0] * c1[2] - m * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Unknown Author
	March 2010
***************************************************************************/

int	DoUnknownAuthor(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = c * c1[0] - c1[0] * c1[2] - c1[3];
	cn[2] = c1[0] * c1[1] - b * c1[2];
	cn[3] = c1[0] * c1[2] + d * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Unknown Oscillator
	June 2018
***************************************************************************/

int	DoUnknownOscillator(void)

    {
    double	i, c1[4], cn[4], k1, k2, alpha, beta, a, b, c, d, s, r, x0, iex, phi;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    k1 = param[0];
    k2 = param[1];
    alpha = param[2];
    beta = param[3];
    a = param[4];
    b = param[5];
    c = param[6];
    d = param[7];
    s = param[8];
    r = param[9];
    x0 = -1.6;
    iex = 1.3;
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	phi = alpha + 3 * beta * c1[3] * c1[3];
	cn[0] = c1[1] - a * c1[0] * c1[0] * c1[0] + b * c1[0] * c1[0] - c1[2] + iex - k1 * phi * c1[0];
	cn[1] = c - d * c1[0] * c1[0] - c1[1];
	cn[2] = r * (s * (c1[0] - x0) - c1[2]);
	cn[3] = c1[0] - k2 * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Unique Signum Switch for Chaos and Hyperchaos
	Chunbiao Li, Julien Clinton Sprott, Wesley Thio, Huanqiang Zhu 2014 -201
***************************************************************************/

int	DoUniqueSignum(void)

    {
    double	i, c1[4], cn[4], a, b;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = -c1[0] + c1[1];
	cn[1] = -c1[2] * fabs(c1[0]) / c1[0];
	cn[2] = c1[0] * fabs(c1[1]) / c1[1] - a;
	cn[3] = c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 25.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Unknown Fountain Chaotic Attractor
***************************************************************************/

int	DoUnknownFountain(void)

    {
    double	i, c1[3], cn[3], a, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    c = param[1];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = c1[0] + c1[1] * c1[2];
	cn[1] = -c1[1] + c1[0] * c1[0] + c1[2];
	cn[2] = 1.0 - c * c1[0] + c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Unknown Oscillator in 4 Dimensions
	Author Unknown
***************************************************************************/

int	DoUnknownOscillator4D(void)

    {
    double	i, c[4], cn[4], te, ti, ke, ki, c1, c2, c3, c4, alpha, beta, se = 1.0, si = 5.0, p1 = 0.0;

    c[0] = param[10];	// x
    c[1] = param[11];	// y
    c[2] = param[12];	// z
    c[3] = param[13];	// w

    te = param[0];
    ti = param[1];
    ke = param[2];
    ki = param[3];
    c1 = param[4];
    c2 = param[5];
    c3 = param[6];
    c4 = param[7];
    alpha = param[8];
    beta = param[9];
    totpasses = 10;

    InitOscillator(c, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = (-c[0] + (ke - c[0]) * se * (c1 * c[0] - c2 * c[1] + p1)) / te;
	cn[1] = (-c[1] + (ki - c[1]) * si * (c3 * c[0] - c4 * c[1])) / ti;
	cn[2] = (-c[2] + (ke - c[2]) * se * (c1 * c[2] - c2 * c[3] + alpha * c[0])) / te;
	cn[3] = (-c[3] + (ki - c[3]) * si * (c3 * c[2] - c4 * c[3] + beta * c[0])) / ti;
	if (DisplayOscillator(c, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Unscrew or back to the future Images
	Theoretical and Numerical Investigation of Intermittent Intermittency
	in Coupled Chaotic Systems
	M.O. Zhuravlev*, A. A. Koronovskii, O. I. Moskalenko, and A. E. Hramov March 1, 2013
***************************************************************************/

int	DoUnscrew(void)

    {
    double	i, c1[3], cn[3], a, p, c, w;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    p = param[1];
    c = param[2];
    w = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = -w * c1[1] - c1[2];
	cn[1] = w * c1[0] + a * c1[1];
	cn[2] = p + c1[2] * (c1[0] - c);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Using Recurrences To Characterize The Hyperchaos-Chaos Transition
	Everton G. Souza, Ricardo L. Viana and Sérgio R. Lopes  10 December 2008
***************************************************************************/

int	DoUsingRecurrences(void)

    {
    double	i, c1[6], cn[6], a, b, alpha, beta, k, m, f1, f2;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v
    c1[5] = param[15];	// w
    
    a = param[0];
    b = param[1];
    alpha = param[2];
    beta = param[3];
    k = param[4];
    m = param[5];
    totpasses = 10;

    InitOscillator(c1, 6);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	f1 = beta * c1[0] + 0.5 * (alpha - beta) * (fabs(c1[0] + 1.0) - fabs(c1[0] - 1.0));
	cn[0] = a * (c1[1] - c1[0] - f1);
	cn[1] = c1[0] - c1[1] + c1[2] + k * (c1[4] - c1[1]);
	cn[2] = -b * c1[1];
	f2 = beta * c1[3] + 0.5 * (alpha - beta) * (fabs(c1[3] + 1.0) - fabs(c1[3] - 1.0));
	cn[3] = a * (c1[4] - c1[3] - f2);
	cn[4] = c1[3] - c1[4] + c1[5] + m * (c1[1] - c1[4]);
	cn[5] = -b * c1[4];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 10.0) % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Van der Pol Chaotic Oscillator Images
***************************************************************************/

int	DoVanderpol(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = -c1[0] + b * (1 - sqr(fabs(c1[0]))) * c1[1] + a * sin(c * c1[2]);
	cn[2] = c;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Various Types of Coexisting Attractors in a New 4D Autonomous Chaotic System
	Qiang La, Akif Akgul, Xiao-Wen Zhao and Huiqin Pei, May 22, 2017
	https://www.researchgate.net/publication/319623569_Various_Types_of_Coexisting_Attractors_in_a_New_4D_Autonomous_Chaotic_System
***************************************************************************/

int	DoVariousTypesCoexistingAttractors(void)

    {
    double	i, c1[4], cn[4], a, b, c, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    k = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = c1[0] * c1[2] - c1[0] * c1[3];
	cn[2] = b - c1[0] * c1[1];
	cn[3] = c * fabs(c1[2]) / c1[2] - k * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Wang Chaotic Oscillator Images
***************************************************************************/

int	DoWang(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[0] - c1[1]) - c1[1] * c1[2];
	cn[1] = -b * c1[1] + c1[0] * c1[2];
	cn[2] = -c * c1[2] + d * c1[0] + c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Wang-Sun Chaotic Oscillator Images
***************************************************************************/

int	DoWangSun(void)

    {
    double	i, c1[3], cn[3], a, b, c, d, e, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[0] * a + c * c1[1] * c1[2];
	cn[1] = b * c1[0] + d * c1[1] - c1[0] * c1[2];
	cn[2] = e * c1[2] + f * c1[0] * c1[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Wavelet Characterisation of Hyper-chaotic Time Series
	J.S. Murguia, H.C. Rosu, L.E. Reyes-Lopez, M. Mejia-Carlos and C. Vargas-Olmos 19 January 2018
	https://www.researchgate.net/publication/322591881_Wavelet_characterization_of_hyper-chaotic_time_series
***************************************************************************/

int	DoWaveletCharacterisation(void)

    {
    double	i, c1[5], cn[5], a, b, c, d, e, f, g;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// u
    c1[4] = param[14];	// v

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    e = param[4];
    f = param[5];
    g = param[6];
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[1] * c1[2] * c1[3];
	cn[1] = b * (c1[0] + c1[1]) + c1[4] - c1[0] * c1[2] * c1[3];
	cn[2] = -c * c1[1] - d * c1[2] - e * c1[3] + c1[0] * c1[1] * c1[3];
	cn[3] = -f * c1[3] + c1[0] * c1[1] * c1[2];
	cn[4] = -g * (c1[0] + c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 30.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Waves Chaotic Oscillator Images
	Peculiarities of Transition to Chaos in Nonideal Hydrodynamics Systems 
	A. Yu. Shvets1 and V. A. Sirenko2 
	Accepted: 31 March 2012 ---2012 CMSIM 
***************************************************************************/

int	DoWaves1(void)

    {
    double	i, c1[5], cn[5], a, b, mu1, n1, n3, alpha;

    c1[0] = param[10];	// p1
    c1[1] = param[11];	// p2
    c1[2] = param[12];	// beta
    c1[3] = param[13];	// q1
    c1[4] = param[14];	// q2

    a = param[0];
    b = param[1];
    mu1 = param[2];
    n1 = param[3];
    n3 = param[4];
    alpha = param[5];

    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = alpha * c1[0] - (c1[2] + a / 2 * (c1[0] * c1[0] + c1[3] * c1[3] + c1[1] * c1[1] + c1[4] * c1[4])) * c1[3] + b * (c1[0] * c1[4] - c1[1] * c1[3]) * c1[1];
	cn[3] = alpha * c1[3] + (c1[2] + a / 2 * (c1[0] * c1[0] + c1[3] * c1[3] + c1[1] * c1[1] + c1[4] * c1[4])) * c1[0] + b * (c1[0] * c1[4] - c1[1] * c1[3]) * c1[4] + 1.0;
	cn[2] = n3 + n1 * c1[2] - mu1 * c1[3];
	cn[1] = alpha * c1[1] - (c1[2] + a / 2 * (c1[0] * c1[0] + c1[3] * c1[3] + c1[1] * c1[1] + c1[4] * c1[4])) * c1[4] - b * (c1[0] * c1[4] - c1[1] * c1[3]) * c1[0];
	cn[4] = alpha * c1[4] + (c1[2] + a / 2 * (c1[0] * c1[0] + c1[3] * c1[3] + c1[1] * c1[1] + c1[4] * c1[4])) * c1[1] - b * (c1[0] * c1[4] - c1[1] * c1[3]) * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Waves Chaotic Oscillator Images
	Peculiarities of Transition to Chaos in Nonideal Hydrodynamics Systems 
	A. Yu. Shvets1 and V. A. Sirenko2 
	Accepted: 31 March 2012 ---2012 CMSIM 
***************************************************************************/

int	DoWaves3(void)

    {
    double	i, c1[5], cn[5], a, b, mu1, n1, n3, alpha;

    c1[0] = param[10];	// p1
    c1[1] = param[11];	// p2
    c1[2] = param[12];	// beta
    c1[3] = param[13];	// q1
    c1[4] = param[14];	// q2

    a = param[0];
    b = param[1];
    mu1 = param[2];
    n1 = param[3];
    n3 = param[4];
    alpha = param[5];

    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i += dt)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = alpha * c1[0] - (c1[2] + a / 2 * (c1[0] * c1[0] + c1[3] * c1[3] + c1[1] * c1[1] + c1[4] * c1[4])) * c1[3] + b * (c1[0] * c1[4] - c1[1] * c1[3]) * c1[1];
	cn[3] = alpha * c1[3] + (c1[2] + a / 2 * (c1[0] * c1[0] + c1[3] * c1[3] + c1[1] * c1[1] + c1[4] * c1[4])) * c1[0] + b * (c1[0] * c1[4] - c1[1] * c1[3]) * c1[4] + 1.0;
	cn[2] = n3 + n1 * c1[2] - mu1 * c1[3];
	cn[1] = alpha * c1[1] - (c1[2] + a / 2 * (c1[0] * c1[0] + c1[3] * c1[3] + c1[1] * c1[1] + c1[4] * c1[4])) * c1[4] - b * (c1[0] * c1[4] - c1[1] * c1[3]) * c1[0];
	cn[4] = alpha * c1[4] + (c1[2] + a / 2 * (c1[0] * c1[0] + c1[3] * c1[3] + c1[1] * c1[1] + c1[4] * c1[4])) * c1[1] - b * (c1[0] * c1[4] - c1[1] * c1[3]) * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i * 20.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Waves Chaotic Oscillator Images
	Peculiarities of Transition to Chaos in Nonideal Hydrodynamics Systems 
	A. Yu. Shvets1 and V. A. Sirenko2 
	Accepted: 31 March 2012 ---2012 CMSIM 
***************************************************************************/

int	DoWaves19(void)

    {
    double	i, c1[5], cn[5], a, b, mu1, n1, n3, alpha;

    c1[0] = param[10];	// p1
    c1[1] = param[11];	// p2
    c1[2] = param[12];	// beta
    c1[3] = param[13];	// q1
    c1[4] = param[14];	// q2

    a = param[0];
    b = param[1];
    mu1 = param[2];
    n1 = param[3];
    n3 = param[4];
    alpha = param[5];
    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = alpha * c1[0] - (c1[2] + a / 2 * (c1[0] * c1[0] + c1[3] * c1[3] + c1[1] * c1[1] + c1[4] * c1[4])) * c1[3] + b * (c1[0] * c1[4] - c1[1] * c1[3]) * c1[1];
	cn[3] = alpha * c1[3] + (c1[2] + a / 2 * (c1[0] * c1[0] + c1[3] * c1[3] + c1[1] * c1[1] + c1[4] * c1[4])) * c1[0] + b * (c1[0] * c1[4] - c1[1] * c1[3]) * c1[4] + 1.0;
	cn[2] = n3 + n1 * c1[2] - mu1 * c1[3];
	cn[1] = alpha * c1[1] - (c1[2] + a / 2 * (c1[0] * c1[0] + c1[3] * c1[3] + c1[1] * c1[1] + c1[4] * c1[4])) * c1[4];// - b * (c1[0] * c1[4] - c1[1] * c1[3]) * c1[0];
	cn[4] = alpha * c1[4] + (c1[2] + a / 2 * (c1[0] * c1[0] + c1[3] * c1[3] + c1[1] * c1[1] + c1[4] * c1[4])) * c1[1] - b * (/*c1[0] * c1[4]*/ - c1[1] * c1[3]) * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Wien 1/2 Chaotic Oscillator Images
	A. S. ELWAKIL AND A. M. SOLIMAN
***************************************************************************/

int	DoWien(void)

    {
    double	i, c1[3], cn[3], alpha, beta, wn, k;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    alpha = param[0];
    beta = param[1];
    wn = param[2];
    k = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    cn[2] = c1[2];							// initialise first occurance
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = ((c1[2] - c1[0]) <= 1.0) ? 2.0 * alpha * (c1[2] - c1[0]) : 2.0 * (alpha + beta * (c1[2] - c1[0] - 1.0));
	cn[1] = 0.5 * (cn[0] + cn[2]) - c1[1];
	cn[2] = wn * ((1.0 - 1.0 / k) * c1[1] - 1.0 / k * c1[2]) - cn[1];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Wien and Ressonator Images
	Analysis of Chaotic Circuits using Wien Bridge Oscillator and a Ressonator
	YASYTERU HOSOKAWA  and YOSHIFUMI NISHIO March 4-6, 2005
***************************************************************************/

int	DoWienRessonator(void)

    {
    double	i, c1[4], cn[4], alpha, beta, gamma, delta, epsilon, yd;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    alpha = param[0];
    beta = param[1];
    gamma = param[2];
    delta = param[3];
    epsilon = param[4];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	yd = c1[0] - c1[2] + (fabs(c1[0] - c1[2] - 1.0) - fabs(c1[0] - c1[2] + 1.0)) / 2.0;
	cn[0] = (alpha * beta - 1 / alpha) * c1[0] - alpha * c1[1] - epsilon * yd;
	cn[1] = alpha * beta * c1[0] - alpha * c1[1];
	yd = c1[0] - c1[2] + (fabs(c1[0] - c1[2] - 1.0) - fabs(c1[0] - c1[2] + 1.0)) / 2.0;
	cn[2] = -gamma * c1[3] + gamma * epsilon * yd;
	cn[3] = delta * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Willamowski-Rössler Model Images
***************************************************************************/

int	DoWillamowski(void)

    {
    double	i, c1[3], cn[3], k1a, k1b, k2a, k2b, k3a, k3b, k4a, k4b, k5a, k5b, f;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    k1a = param[0];
    k1b = param[1];
    k2a = param[2];
    k2b = param[3];
    k3a = param[4];
    k3b = param[5];
    k4a = param[6];
    k4b = param[7];
    k5a = param[8];
    k5b = param[9];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	f = k4a * c1[0] * c1[2] + k4b;
	cn[0] = k1a * c1[0] - k1b * c1[0] * c1[0] - k2a * c1[0] * c1[1] + k2b * c1[1] * c1[1] - f;
	cn[1] = k2a * c1[0] * c1[1] - k2b * c1[1] * c1[1] - k3a * c1[1] + k3b;
	cn[2] = -k4a * c1[0] * c1[2] + k4b + k5a * c1[2] - k5b * c1[2] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Wimol-Banlue Chaotic Attractor Images
***************************************************************************/

int	DoWimolBanlue(void)

    {
    double	i, c1[3], cn[3], a, h;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	h = (exp(c1[0]) - exp(-c1[0])) / (exp(c1[0]) + exp(-c1[0]));
	cn[0] = c1[1] - c1[0];
	cn[1] = -c1[2] * h;
	cn[2] = -a + c1[0] * c1[1] + fabs(c1[1]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Windmi Chaotic Attractor Images
***************************************************************************/

int	DoWindmi(void)

    {
    double	i, c1[3], cn[3], a, b;

    c1[0] = param[10]; // x
    c1[1] = param[11]; // y
    c1[2] = param[12]; // z

    a = param[0];
    b = param[1];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = c1[1];
	cn[1] = c1[2];
	cn[2] = -a * c1[2] - c1[1] + b - exp(c1[0]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Windmi 6D Chaotic Attractor Images
***************************************************************************/

/*
int	DoWindmi6D(void)

    {
    double	i, c1[6], cn[6], dt, a1, a2, b1, b3, d1, f1, g1, g2, g3, x;
    double	b2 = 0.0, vs = 0.0;					    // bad coding???

    c1[0] = 0.1;    // i
    c1[1] = 0.8;    // v
    c1[2] = 0.4;    // p
    c1[3] = 0.3;    // k
    c1[4] = 9.2;    // i1
    c1[5] = 18.0;   // vi

    f1 = 2.47;
    g1 = 1080.0;
    g2 = 4.0;
    g3 = 3.79,


    a1 = param[0];
    a2 = param[1];
    b1 = param[2];
    b3 = param[3];
    d1 = param[4];
    dt = param[5];
    totpasses = 10;

    InitOscillator(c1, 6);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a1 * (vs - c1[1]) + a2 * (c1[1] - c1[5]);
	cn[1] = b1 * (c1[0] - c1[4]) - b2 * sqrt(abs(c1[2])) - b3 * c1[1];
	x = d1 * (c1[0] - 1.0);
	cn[2] = c1[1] * c1[1] - sqrt(abs(c1[3])) * c1[2] * (1.0 + tan(x)) / 2.0;
	cn[3] = sqrt(abs(c1[2])) * c1[1] - c1[3];
	cn[4] = a2 * (vs - c1[1]) + f1 * (c1[1] - c1[5]);
//	cn[5] = g1 * c1[4] = g2 * c1[5] - g3 * sqrt(abs(c1[4])) * pow(c1[5], -1.5);
	cn[5] = g1 * c1[4] - g2 * c1[5] - g3 * sqrt(abs(c1[4])) * pow(c1[5], -1.5);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i * 5.0) % threshold), i, 6, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }
*/

/**************************************************************************
	World Without War Chaotic Attractor Images
	Courtesy of Marcus when Brazil lost the world cup in 2014
***************************************************************************/

int	DoWorldWithoutWar(void)

    {
    double	i, c1[5], cn[5], re;

    c1[0] = param[10];
    c1[1] = param[11];
    c1[2] = param[12];
    c1[3] = param[13];
    c1[4] = param[14];
    re = param[0];

    totpasses = 10;

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i += dt)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -2.0 * c1[0] + 4.0 * c1[1] * c1[2] + 4.0 * c1[3] * c1[4];
	cn[1] = -9.0 * c1[1] + 3.0 * c1[0] * c1[2];
	cn[2] = -5.0 * c1[2] - 7.0 * c1[0] * c1[1] + re;
	cn[3] = -5.0 * c1[3] - c1[0] * c1[4];
	cn[4] = -c1[4] - 2.0 * c1[0] * c1[3];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / dt) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Wrong Mixup Oscillator
	Brigita Fercec and Marcus Rezende July 2017 & April 2018
***************************************************************************/

int	DoWrongMixup(void)

    {
    double	i, c1[3], cn[3], e = exp(1.0);

    c1[0] = param[10]; // x
    c1[1] = param[11]; // y
    c1[2] = param[12]; // z

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 1.0 / e * (c1[0] * (1.0 - c1[0]));			// this is part of the equation in an attractor from the first author
	cn[1] = c1[0] - c1[1];						// this is the original equation from an attractor from the first author;
	cn[2] = sqrt(sqr(sin(c1[0])) + sqr(cos(c1[1])));
	c1[0] = -sin(2.0 * PI * c1[0]);					// made up this unconventional mess
	c1[1] = -sinh(c1[0] * e);					// made up this unconventional mess
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 2, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Xing-Yun Chaotic Oscillator Images
***************************************************************************/

int	DoXingYun(void)

    {
    double	i, c1[3], cn[3], a, b, c, e;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    e = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]) + c1[1] * c1[2] * c1[2];
	cn[1] = b * (c1[0] + c1[1]) - c1[0] * c1[2] * c1[2];
	cn[2] = -c * c1[2] + e * c1[1] + c1[0] * c1[1] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Xu Hyper-Chaotic Attractor in 4 Dimensions Images
***************************************************************************/

int	DoXu4D(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = (c - a) * c1[0] - c1[0] * c1[2] + c * c1[1];
	cn[2] = c1[0] * c1[1] - b * c1[2] - c1[1] * c1[2] - c1[3];
	cn[3] = -d * c1[3] + c1[1] * c1[2] - c1[0] * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 2.0) % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Yang-Chen Chaotic Oscillator in 4 Dimensions Images
***************************************************************************/

int	DoYangChen4D(void)

    {
    double	i, c1[4], cn[4], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = c * c1[0] - c1[0] * c1[2] + c1[3];
	cn[2] = c1[0] * c1[1] - b * c1[2];
	cn[3] = -d * c1[0];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Yet Another Chaotic Attractor
	Guanrong Chen and Tetsushi Ueta March 30, 1999
	https://www.researchgate.net/publication/242919493_Yet_Another_Chaotic_Attractor
***************************************************************************/

int	DoYetAnotherChaoticAttractor(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = -c1[1] - c1[2];
	cn[1] = c1[0] + a * c1[1];
	cn[2] = c1[0] * c1[2] - b * c1[2] + c;
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Yet Another Unknown Chaotic Attractor
	Modified by Marcus
***************************************************************************/

int	DoYetAnotherUnknownChaoticAttractor(void)

    {
    double	i, c1[4], cn[4]/*, a, b, c, k*/;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w

/*
    a = param[0];
    b = param[1];
    c = param[2];
    k = param[3];
*/
    totpasses = 10;

    InitOscillator(c1, 4);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = 45 * c1[0] - 1000 * c1[1] * c1[2];
	cn[1] = -170 * c1[1] + 1000 * c1[0] * c1[2] + 10 * (-14 + 6 * c1[3] * c1[3]);
	cn[2] = -540 * c1[2] + 1000 * c1[0] * c1[1];
	cn[3] = -1500 * c1[1] * (-14 + 6 * c1[3] * c1[3]);
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 4, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Yu-Wang Chaotic Oscillator Images
***************************************************************************/

int	DoYuWang(void)

    {
    double	i, c1[3], cn[3], a, b, c, d;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    d = param[3];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = b * c1[0] - c * c1[0] * c1[2];
	cn[2] = exp(c1[0] * c1[1]) - d * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Zaidan, Radan and Salama Chaotic Attractor Images
***************************************************************************/

int	DoZaidan(int mode)

    {
    double	i, c1[3], cn[3], m, d1, d2, d3, s0, s1, s2, gz;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    switch (mode)
	{
	case 0:	    // Zaidan 2
	    m = 1.0;
	    d1 = 1.4;
	    d2 = 2.8;
	    d3 = 0.0;
	    s2 = 0.0;
	    break;
	case 1:	    // Zaidan 3
	    m = 1.0;
	    d1 = 1.15;
	    d2 = 2.3;
	    d3 = 3.45;
	    s2 = param[3];
	    break;
	case 2:	    // Zaidan 4
	    m = 2.0;
	    d1 = 1.0;
	    d2 = 8.0;
	    d3 = 0;
	    s2 = 0.0;
	    break;
	}

    s0 = param[0];
    s1 = param[1];
    s2 = param[2];
    d1 = param[3];
    d2 = param[4];
    d3 = param[5];

    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	if (c1[2] < s0) gz = 0.0;
	if (c1[2] >= s0 && c1[2] < s1) gz = d1;
	if (mode == 1)
	    {
	    if (c1[2] >= s1 && c1[2] < s2) gz = d2;
	    if (c1[2] >= s2) gz = d3;
	    }
	else
	    if (c1[2] >= s1) gz = d2;

	cn[0] = c1[1] - c1[0];
	cn[1] = fabs(c1[0]) / c1[0] * (1 - m * c1[2] + gz);
	cn[2] = fabs(c1[0]) - 0.5 * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

int	DoZaidan2(void)
    {
    return DoZaidan(0);
    }

int	DoZaidan3(void)
    {
    return DoZaidan(1);
    }

int	DoZaidan4(void)
    {
    return DoZaidan(2);
    }

/**************************************************************************
	Zang Chaotic Oscillator in 5 Dimensions Images
	Function Projective Synchronisation of Two Identical New Hyperchaotic Systems
***************************************************************************/

int	DoZang5D(void)

    {
    double	i, c1[5], cn[5], omega, a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z
    c1[3] = param[13];	// w
    c1[4] = param[14];	// q

    a = param[0];
    b = param[1];
    c = param[2];
    omega = param[3];

    InitOscillator(c1, 5);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);

	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = c * c1[1] - c1[0] * c1[2];
	cn[2] = -b * c1[2] + c1[0] * c1[1] + c1[3];
	cn[3] = c1[4];
	cn[4] = -omega * omega * c1[3];

	if (DisplayOscillator(c1, cn, dt, ((DWORD)(i / 5.0) % threshold), i, 5, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Zhou Chaotic Oscillator Images
***************************************************************************/

int	DoZhou(void)

    {
    double	i, c1[3], cn[3], a, b, c;

    c1[0] = param[10];	// x
    c1[1] = param[11];	// y
    c1[2] = param[12];	// z

    a = param[0];
    b = param[1];
    c = param[2];
    totpasses = 10;

    InitOscillator(c1, 3);						// pass in number of dimensions
    for (i = 0; i < iterations; i++)
	{
	if (user_data(GlobalHwnd) == -1)				// user pressed a key?
	    return -1;
	curpass = (int)(i * totpasses / iterations);
	cn[0] = a * (c1[1] - c1[0]);
	cn[1] = b * c1[0] - c1[0] * c1[2];
	cn[2] = c1[0] * c1[1] + c * c1[2];
	if (DisplayOscillator(c1, cn, dt, ((DWORD)i % threshold), i, 3, 0) < 0)
	    break;
	}
    PlotExtras();
    return 0;
    }

/**************************************************************************
	Compare function for Oscillator name sort
**************************************************************************/

int	CompareOsc(int	*p1, int *p2)

    {
    char    *a1, *a2;

    a1 = OscillatorSpecific[*p1].name;
    a2 = OscillatorSpecific[*p2].name;
    if (*a1 == '\"')			    // ignore " character
	a1 = a1++;
    if (*a2 == '\"')
	a2 = a2++;
    return (_stricmp(a1, a2));
    }

/**************************************************************************
	General Oscillator Fractal
***************************************************************************/

int	setup_Oscillator(void)
    {
    int	    i;

    OscillatorNum = 0;
			// we'd better count how many records we have
    while (OscillatorSpecific[OscillatorNum].name)
	OscillatorNum++;
    for (i = 0; i < OscillatorNum; i++) 
	OscPtrArray[i] = i;
    qsort((void *)OscPtrArray, (size_t)OscillatorNum, sizeof(OscPtrArray[0]), (int (__cdecl *)(const void *, const void *)) CompareOsc);

#ifdef	PRINTOSC
    PrintOsc(OscillatorNum);		// used for listing oscillator names in d:\temp\OscDump.txt
#endif

    return 0;
    }

void	LoadParams(void)
//void	LoadOscillatorParams(void) 
    {
    // here is where we can do some specific updates to individual Oscillator fractals
    struct	OscillatorSpecificStuff	*DatabasePtr;
    int	i;

    DatabasePtr = OscProcess.LoadDatabasePointer(type, subtype);
    for (i = 0; i < NUMPARAM; i++)
	{
    	param[i] = DatabasePtr->paramvalue[i];
    	param[i + NUMPARAM] = DatabasePtr->variablevalue[i];
	}
    hor = DatabasePtr->hor;
    vert = DatabasePtr->vert;
    mandel_width = DatabasePtr->width;
    fractalspecific[type].name = DatabasePtr->name;
    iterations = DatabasePtr->iterations;
    VertBias = DatabasePtr->VertBias;
    zBias = DatabasePtr->zBias;
    if (zBias <= 0.0)
	zBias = 1.0;
    dt = DatabasePtr->dt;
    MaxDimensions = DatabasePtr->MaxDimensions;
    // LSB: Oscillator: plot lines, Fractal map: special colouring, Surfaces, Knots, Curves: Hide Background. 
    if (type == OSCILLATORS)
	DisplayLines = DatabasePtr->flags & 1;
    else if (type == SURFACES || type == KNOTS || type == CURVES)
	RemoveHiddenPixels = DatabasePtr->flags & 1;
    else if (type == FRACTALMAPS || type == SPROTTMAPS)
	FractalMapColouring = DatabasePtr->flags & 1;
    CoordSystem = (DatabasePtr->flags & 0x001E) >> 1;
    BlockAnimation = DatabasePtr->flags & BLOCKANIM;
    FindCentre = DatabasePtr->flags & AVERAGE;
    PerspectiveFlag = DatabasePtr->flags & PERSPECTIVE;
    FrameCounter = 0;
    }

#ifdef	MULTITHREAD
int	DoOscillator(PMYVARIABLES var)
#else
int	DoOscillator(void)
#endif
    {
    return (OscillatorSpecific[subtype].calctype());
    }

/**************************************************************************
	Show Oscillator Fractal
**************************************************************************/

DLGPROC FAR PASCAL SelectOscillatorDlg(HWND hDlg, unsigned message, WPARAM wParam, LPARAM lParam)

    {
    static	int	i;
    static	int	index;
    static	int	OldSubtype = -1;
    static	struct	OscillatorSpecificStuff	*DatabasePtr; 
//		BOOL	bTrans ;
//		HWND    hCtrl; 

    switch (message) 
	{
        case WM_INITDIALOG:
	    if (type == OSCILLATORS)
		{
		SetDlgItemText(hDlg, ID_LISTTITLE, "Oscillators");
		SetWindowText (hDlg, "Select Chaotic Oscillator");
		for (i = 0; i < OscillatorNum; i++) 
		    SendDlgItemMessage(hDlg, IDM_LSYSTEM, LB_ADDSTRING, (WPARAM)NULL, (LPARAM) (LPSTR) OscillatorSpecific[OscPtrArray[i]].name);
		SendDlgItemMessage(hDlg, IDM_LSYSTEM, LB_SETCURSEL, (WPARAM)OscillatorPtr, 0L);
		}
	    else if (type == FRACTALMAPS)
		{
		SetDlgItemText(hDlg, ID_LISTTITLE, "Fractal Maps");
		SetWindowText(hDlg, "Select Fractal Map");
		for (i = 0; i < OscillatorNum; i++)
		    SendDlgItemMessage(hDlg, IDM_LSYSTEM, LB_ADDSTRING, (WPARAM)NULL, (LPARAM)(LPSTR)FractalMapSpecific[OscPtrArray[i]].name);
		SendDlgItemMessage(hDlg, IDM_LSYSTEM, LB_SETCURSEL, (WPARAM)OscillatorPtr, 0L);
		}
	    else if (type == SPROTTMAPS)
		{
		SetDlgItemText(hDlg, ID_LISTTITLE, "Sprott Fractal Maps");
		SetWindowText(hDlg, "Select Fractal Map");
		for (i = 0; i < OscillatorNum; i++)
		    SendDlgItemMessage(hDlg, IDM_LSYSTEM, LB_ADDSTRING, (WPARAM)NULL, (LPARAM)(LPSTR)SprottMapSpecific[OscPtrArray[i]].name);
		SendDlgItemMessage(hDlg, IDM_LSYSTEM, LB_SETCURSEL, (WPARAM)OscillatorPtr, 0L);
		}
	    else if (type == SURFACES)
		{
		SetDlgItemText(hDlg, ID_LISTTITLE, "Surfaces");
		SetWindowText (hDlg, "Select Surface");
		for (i = 0; i < OscillatorNum; i++) 
		    SendDlgItemMessage(hDlg, IDM_LSYSTEM, LB_ADDSTRING, (WPARAM)NULL, (LPARAM) (LPSTR) SurfaceSpecific[OscPtrArray[i]].name);
		SendDlgItemMessage(hDlg, IDM_LSYSTEM, LB_SETCURSEL, (WPARAM)OscillatorPtr, 0L);
		}
	    else if (type == KNOTS)
		{
		SetDlgItemText(hDlg, ID_LISTTITLE, "Knots");
		SetWindowText (hDlg, "Select Knot");
		for (i = 0; i < OscillatorNum; i++) 
		    SendDlgItemMessage(hDlg, IDM_LSYSTEM, LB_ADDSTRING, (WPARAM)NULL, (LPARAM) (LPSTR) KnotSpecific[OscPtrArray[i]].name);
		SendDlgItemMessage(hDlg, IDM_LSYSTEM, LB_SETCURSEL, (WPARAM)OscillatorPtr, 0L);
		}
	    else if (type == CURVES)
		{
		SetDlgItemText(hDlg, ID_LISTTITLE, "Curves");
		SetWindowText (hDlg, "Select Curve");
		for (i = 0; i < OscillatorNum; i++) 
		    SendDlgItemMessage(hDlg, IDM_LSYSTEM, LB_ADDSTRING, (WPARAM)NULL, (LPARAM) (LPSTR) CurveSpecific[OscPtrArray[i]].name);
		SendDlgItemMessage(hDlg, IDM_LSYSTEM, LB_SETCURSEL, (WPARAM)OscillatorPtr, 0L);
		}
	    SendDlgItemMessage(hDlg, IDM_LSYSTEM, (UINT) LB_SETCURSEL,  (OscillatorPtr == -1) ? 0 : OscillatorPtr, 0L); 
            return ((DLGPROC)TRUE);

        case WM_COMMAND:
	    switch ((int) LOWORD(wParam))
		{
                case IDOK:
                    index = (int)SendDlgItemMessage(hDlg, IDM_LSYSTEM, LB_GETCURSEL, 0, 0L);
                    if (index == LB_ERR) 
			{
                        MessageBox(hDlg, "No Choice selected", "Select From a List", MB_OK | MB_ICONEXCLAMATION);
                        break;
                        }
                    OscillatorPtr = index;
		    subtype = OscPtrArray[OscillatorPtr];
		    DatabasePtr = OscProcess.LoadDatabasePointer(type, subtype);
		    xAxis = abs(DatabasePtr->xAxis) - 1;
		    yAxis = abs(DatabasePtr->yAxis) - 1;
		    zAxis = abs(DatabasePtr->zAxis) - 1;
		    if (subtype != OldSubtype)
			{
	    		if (type == OSCILLATORS)
			    {
			    xSign = (DatabasePtr->xAxis > 0) ? 1 : -1;
			    ySign = (DatabasePtr->yAxis > 0) ? 1 : -1;
			    }
			}
		    OldSubtype = subtype;
                    EndDialog(hDlg, TRUE);
                    return ((DLGPROC)TRUE);
                  
                case IDCANCEL:
                    OscillatorPtr = 0;
                    EndDialog(hDlg, FALSE);
                    return (FALSE);
                    
                case IDM_LSYSTEM:
                    switch (HIWORD(wParam) & 0x0003) 
			{
                        case LBN_SELCHANGE:
                            index = (int)SendDlgItemMessage(hDlg, IDM_LSYSTEM, LB_GETCURSEL, 0, 0L);
                            if (index == LB_ERR)
                                break;
                            break;
                         
			case LBN_DBLCLK:
			    index = (int)SendDlgItemMessage(hDlg, IDM_LSYSTEM, LB_GETCURSEL, 0, 0L);
			    if (index == LB_ERR) 
				{
				MessageBox(hDlg, "No Choice selected",
				    "Select From a List", MB_OK | MB_ICONEXCLAMATION);
				break;
				}
//			    subtype = OscillatorPtr = index;
			    OscillatorPtr = index;
			    subtype = OscPtrArray[OscillatorPtr];
			    DatabasePtr = OscProcess.LoadDatabasePointer(type, subtype);
			    xAxis = abs(DatabasePtr->xAxis) - 1;
			    yAxis = abs(DatabasePtr->yAxis) - 1;
			    zAxis = abs(DatabasePtr->zAxis) - 1;
			    if (subtype != OldSubtype)
				{
				if (type == OSCILLATORS)
				    {
				    xSign = (DatabasePtr->xAxis > 0) ? 1 : -1;
				    ySign = (DatabasePtr->yAxis > 0) ? 1 : -1;
				    }
				}
			    EndDialog(hDlg, TRUE);
			    return ((DLGPROC)TRUE);
                  
			}
	return (DLGPROC)(TRUE);
	}
    }
return ((DLGPROC)FALSE);
}

/**************************************************************************
	Dialog Box for loading Oscillator functions
**************************************************************************/

void	Axes2Text(char *text, int x, int y, int z)
    {
    sprintf(text, "%c%c%c", ((x < 10) ? '0' + x : 'A' - 10 + x), ((y < 10) ? '0' + y : 'A' - 10 + y), ((z < 10) ? '0' + z : 'A' - 10 + z));
    }

void	Text2Axes(int *x, int *y, int *z, char *text)
    {
    int	    i;
    char    t[4];

//    locale loc ("Australian_Australia");
    for (i = 0; i < 3; i++)
	t[i] = toupper (text[i]);

    *x = (isalpha(t[0])) ? t[0] - 'A' + 10 : t[0] - '0';
    *y = (isalpha(t[1])) ? t[1] - 'A' + 10 : t[1] - '0';
    *z = (isalpha(t[2])) ? t[2] - 'A' + 10 : t[2] - '0';
    }

DLGPROC FAR PASCAL SelectOscParams(HWND hDlg, UINT message, UINT wParam, LONG lParam)

    {
    int			i, a, b, c;
    static	int	index1 = -1, index2 = -1;
    static	int	numtrig;
    static	struct	OscillatorSpecificStuff	*DatabasePtr; 
    char		s[10][100];
    char		VertScaling[24];
    char		DeltaTString[64];
    BOOL		bTrans ;
    HWND		hCtrl; 

//    a = xAxis + 1;
//    b = yAxis + 1;
//    c = zAxis + 1;
    switch (message) 
	{
        case WM_INITDIALOG:
            SetDlgItemText(hDlg, ID_FRACNAME, GetFractalName());
	    if (type == OSCILLATORS)
		{
		SetDlgItemInt(hDlg, IDC_NUMVAR, MaxDimensions * 2, TRUE);
		hCtrl = GetDlgItem (hDlg, IDC_COLOURINGOPTION);
		ShowWindow (hCtrl, SW_HIDE);
		hCtrl = GetDlgItem (hDlg, IDC_COLOURINGLABEL);
		ShowWindow (hCtrl, SW_HIDE);
		hCtrl = GetDlgItem (hDlg, IDC_LINES);
		ShowWindow (hCtrl, SW_SHOWNORMAL);
		SendMessage(hCtrl, BM_SETCHECK, DisplayLines, 0L);

		hCtrl = GetDlgItem (hDlg, IDC_XREFLECT);
		ShowWindow (hCtrl, SW_SHOWNORMAL);
		SendMessage(hCtrl, BM_SETCHECK, (xSign < 0), 0L);
		hCtrl = GetDlgItem (hDlg, IDC_YREFLECT);
		ShowWindow (hCtrl, SW_SHOWNORMAL);
		SendMessage(hCtrl, BM_SETCHECK, (ySign < 0), 0L);
		hCtrl = GetDlgItem (hDlg, IDC_XREFLECTLABEL);
		ShowWindow (hCtrl, SW_SHOWNORMAL);
		hCtrl = GetDlgItem (hDlg, IDC_YREFLECTLABEL);
		ShowWindow (hCtrl, SW_SHOWNORMAL);
		}
	    else
		{
		SetDlgItemInt(hDlg, IDC_NUMVAR, MaxDimensions, TRUE);
		hCtrl = GetDlgItem (hDlg, IDC_COLOURINGLABEL);
		ShowWindow (hCtrl, SW_SHOWNORMAL);
		hCtrl = GetDlgItem (hDlg, IDC_COLOURINGOPTION);
		ShowWindow (hCtrl, SW_SHOWNORMAL);
		SendMessage(hCtrl, BM_SETCHECK, FractalMapColouring, 0L);
		hCtrl = GetDlgItem (hDlg, IDC_LINES);
		ShowWindow (hCtrl, SW_HIDE);

		hCtrl = GetDlgItem (hDlg, IDC_XREFLECT);
		ShowWindow (hCtrl, SW_HIDE);
		hCtrl = GetDlgItem (hDlg, IDC_YREFLECT);
		ShowWindow (hCtrl, SW_HIDE);
		hCtrl = GetDlgItem (hDlg, IDC_XREFLECTLABEL);
		ShowWindow (hCtrl, SW_HIDE);
		hCtrl = GetDlgItem (hDlg, IDC_YREFLECTLABEL);
		ShowWindow (hCtrl, SW_HIDE);
		}
	    DatabasePtr = OscProcess.LoadDatabasePointer(type, subtype);
	    NumParams = DatabasePtr->numparams;
	    for (i = 0; i < NumParams && i < NUMPARAM; i++)
		{
		sprintf(s[i], "%g", DatabasePtr->paramvalue[i]);
		SetDlgItemText(hDlg, ID_FRACPARTX1 + i, DatabasePtr->paramname[i]);
		SetDlgItemText(hDlg, ID_FRACPARAM1 + i, s[i]);
		}
	    for (i = NumParams; i < 10; i++) 
		SetDlgItemText(hDlg, ID_FRACPARTX1 + i, "     N/A");

	    NumVariables = DatabasePtr->numvariables;
	    for (i = 0; i < NumVariables && i < NUMPARAM; i++)
		{
		sprintf(s[i], "%g", DatabasePtr->variablevalue[i]);
		SetDlgItemText(hDlg, ID_FRACVARTX01 + i, DatabasePtr->variablename[i]);
		SetDlgItemText(hDlg, ID_FRACVAR01 + i, s[i]);
		}
	    for (i = NumVariables; i < NUMPARAM; i++) 
		SetDlgItemText(hDlg, ID_FRACVARTX01 + i, "     N/A");
	    hCtrl = GetDlgItem (hDlg, IDC_COLOURINGLABEL);
	    if (type == SURFACES || type == KNOTS || type == CURVES)
		SetDlgItemText(hDlg, IDC_COLOURINGLABEL, "Hide Background?");
	    else
		SetDlgItemText(hDlg, IDC_COLOURINGLABEL, "Use Special Colouring?");
	    for (i = NumVariables; i < 10; i++) 
		SetDlgItemText(hDlg, ID_FRACVARTX01 + i, "     N/A");

	    hCtrl = GetDlgItem (hDlg, IDC_X);
	    ShowWindow (hCtrl, SW_SHOWNORMAL);
	    hCtrl = GetDlgItem (hDlg, IDC_Y);
	    ShowWindow (hCtrl, SW_SHOWNORMAL);
	    hCtrl = GetDlgItem (hDlg, IDC_Z);
	    ShowWindow (hCtrl, SW_SHOWNORMAL);
	    hCtrl = GetDlgItem (hDlg, IDC_DIM_X);
	    ShowWindow (hCtrl, SW_SHOWNORMAL);
	    hCtrl = GetDlgItem (hDlg, IDC_DIM_Y);
	    ShowWindow (hCtrl, SW_SHOWNORMAL);
	    hCtrl = GetDlgItem (hDlg, IDC_DIM_Z);
	    ShowWindow (hCtrl, SW_SHOWNORMAL);
	    SetDlgItemInt(hDlg, IDC_X, xAxis + 1, TRUE);
	    SetDlgItemInt(hDlg, IDC_Y, yAxis + 1, TRUE);
	    SetDlgItemInt(hDlg, IDC_Z, zAxis + 1, TRUE);
	    SetDlgItemInt(hDlg, IDC_NUMDIM, MaxDimensions, TRUE);
	    sprintf(DeltaTString, "%g", dt);
	    SetDlgItemText(hDlg, IDC_DT, DeltaTString);
	    sprintf(VertScaling, "%g", VertBias);
	    SetDlgItemText(hDlg, IDC_VERTBIAS, VertScaling);
//	    sprintf(zScaling, "%f", zBias);
//	    SetDlgItemText(hDlg, IDC_ZBIAS, zScaling);
	    Axes2Text(AxesText, xAxis + 1, yAxis + 1, zAxis + 1);
	    SetDlgItemText(hDlg, IDC_DIMTEXT, AxesText);
	    SetDlgItemInt(hDlg, IDC_ITERATIONS, (int)iterations, TRUE);
	    SetDlgItemInt(hDlg, IDC_XPERSPECTIVE, (int)x_rot, TRUE);
	    SetDlgItemInt(hDlg, IDC_YPERSPECTIVE, (int)y_rot, TRUE);
	    SetDlgItemInt(hDlg, IDC_ZPERSPECTIVE, (int)z_rot, TRUE);
//	    SetDlgItemInt(hDlg, IDC_BG_RED, OscBackGround.rgbtRed, TRUE);
//	    SetDlgItemInt(hDlg, IDC_BG_GREEN, OscBackGround.rgbtGreen, TRUE);
//	    SetDlgItemInt(hDlg, IDC_BG_BLUE, OscBackGround.rgbtBlue, TRUE);
	    SetDlgItemInt(hDlg, IDC_BG_RED, 0, TRUE);
	    SetDlgItemInt(hDlg, IDC_BG_GREEN, 0, TRUE);
	    SetDlgItemInt(hDlg, IDC_BG_BLUE, 0, TRUE);
	    hCtrl = GetDlgItem (hDlg, IDC_WHITE_BACKGROUND);
	    SendMessage(hCtrl, BM_SETCHECK, FALSE, 0L);
	    hCtrl = GetDlgItem (hDlg, IDC_DOPERSPECTIVE);
	    SendMessage(hCtrl, BM_SETCHECK, PerspectiveFlag, 0L);
	    hCtrl = GetDlgItem (hDlg, IDC_AVERAGECENTRE);
	    SendMessage(hCtrl, BM_SETCHECK, (FindCentre == AVERAGE), 0L);
	    CheckRadioButton(hDlg, IDC_CARTESIAN, IDC_CONICAL, IDC_CARTESIAN + CoordSystem);
            return ((DLGPROC)TRUE);

        case WM_COMMAND:
	    switch ((int) LOWORD(wParam))
		{
		case IDC_CARTESIAN:
		    CoordSystem = CARTESIAN;
		    break;
		case IDC_SPHERICAL:
		    CoordSystem = SPHERICAL;
		    break;
		case IDC_CYLINDRICAL:
		    CoordSystem = CYLINDRICAL;
		    break;
		case IDC_PARABOLIC:
		    CoordSystem = PARABOLIC;
		    break;
		case IDC_PARABOLOIDAL:
		    CoordSystem = PARABOLOIDAL;
		    break;
		case IDC_ELLIPTICAL:
		    CoordSystem = ELLIPTICAL;
		    break;
		case IDC_BIPOLAR:
		    CoordSystem = BIPOLAR;
		    break;
		case IDC_TOROIDAL:
		    CoordSystem = TOROIDAL;
		    break;
		case IDC_PROLATE_SPHEROIDAL:
		    CoordSystem = PROLATE_SPHERE;
		    break;
		case IDC_OBLATE_SPHEROIDAL:
		    CoordSystem = OBLATE_SPHERE;
		    break;
		case IDC_BISPHERICAL:
		    CoordSystem = BISPHERICAL;
		    break;
		case IDC_CONICAL:
		    CoordSystem = CONICAL;
		    break;
                case IDC_DIMTEXT:
		    GetDlgItemText(hDlg, IDC_DIMTEXT, AxesText, 10);
	    	    Text2Axes(&a, &b, &c, AxesText);
		    SetDlgItemInt(hDlg, IDC_X, a, TRUE);
		    SetDlgItemInt(hDlg, IDC_Y, b, TRUE);
		    SetDlgItemInt(hDlg, IDC_Z, c, TRUE);
		    return ((DLGPROC)TRUE);
                case IDC_WHITE_BACKGROUND:
		    hCtrl = GetDlgItem (hDlg, IDC_WHITE_BACKGROUND);
		    SendMessage(hCtrl, BM_SETCHECK, TRUE, 0L);
		    SetDlgItemInt(hDlg, IDC_BG_RED, 255, TRUE);
		    SetDlgItemInt(hDlg, IDC_BG_GREEN, 255, TRUE);
		    SetDlgItemInt(hDlg, IDC_BG_BLUE, 255, TRUE);
		    return ((DLGPROC)TRUE);

/*
		case IDC_X:
                case IDC_Y:
                case IDC_Z:
		    switch ((int) LOWORD(wParam))
			{
			case IDC_X:
			    xAxis = GetDlgItemInt(hDlg, IDC_X, &bTrans, TRUE) - 1;
			    break;
			case IDC_Y:
			    yAxis = GetDlgItemInt(hDlg, IDC_Y, &bTrans, TRUE) - 1;
			    break;
			case IDC_Z:
			    zAxis = GetDlgItemInt(hDlg, IDC_Z, &bTrans, TRUE) - 1;
			    break;
			}
		    Axes2Text(AxesText, xAxis + 1, yAxis + 1, zAxis + 1);
		    SetDlgItemText(hDlg, IDC_DIMTEXT, AxesText);
		    return ((DLGPROC)TRUE);
*/

                case IDOK:
		    GetDlgItemText(hDlg, IDC_VERTBIAS, VertScaling, 100);
		    VertBias = atof(VertScaling);
//		    GetDlgItemText(hDlg, IDC_ZBIAS, zScaling, 100);
//		    zBias = atof(zScaling);
		    GetDlgItemText(hDlg, IDC_DT, DeltaTString, 100);
		    dt = atof(DeltaTString);
		    iterations = (double)GetDlgItemInt(hDlg, IDC_ITERATIONS, &bTrans, TRUE);
		    hCtrl = GetDlgItem (hDlg, IDC_COLOURINGOPTION);
		    if (type == FRACTALMAPS || type == SPROTTMAPS)
			FractalMapColouring = (BYTE)SendMessage(hCtrl, BM_GETCHECK, 0, 0L);
		    else if (type == SURFACES || type == KNOTS || type == CURVES)
			RemoveHiddenPixels = (BYTE)SendMessage(hCtrl, BM_GETCHECK, 0, 0L);
		    for (i = 0; i < NumParams && i < 10; i++) 
			{
			GetDlgItemText(hDlg, ID_FRACPARAM1 + i, s[i], 100);
			param[i] = atof(s[i]);
			}
		    for (i = 0; i < NumVariables && i < 10; i++) 
			{
			GetDlgItemText(hDlg, ID_FRACVAR01 + i, s[i], 100);
			param[10 + i] = atof(s[i]);
			}
		    OscBackGround.rgbtRed = GetDlgItemInt(hDlg, IDC_BG_RED, &bTrans, TRUE);
		    OscBackGround.rgbtGreen = GetDlgItemInt(hDlg, IDC_BG_GREEN, &bTrans, TRUE);
		    OscBackGround.rgbtBlue = GetDlgItemInt(hDlg, IDC_BG_BLUE, &bTrans, TRUE);
/*
		    if (OscBackGround.rgbtRed < 0) OscBackGround.rgbtRed = 0;
		    if (OscBackGround.rgbtGreen < 0) OscBackGround.rgbtGreen = 0;
		    if (OscBackGround.rgbtBlue < 0) OscBackGround.rgbtBlue = 0;
		    if (OscBackGround.rgbtRed > 255) OscBackGround.rgbtRed = 255;
		    if (OscBackGround.rgbtGreen > 255) OscBackGround.rgbtGreen = 255;
		    if (OscBackGround.rgbtBlue > 255) OscBackGround.rgbtBlue = 255;
*/
		    hCtrl = GetDlgItem (hDlg, IDC_DOPERSPECTIVE);
		    PerspectiveFlag = SendMessage(hCtrl, BM_GETCHECK, 0, 0L) ? PERSPECTIVE : 0;
		    x_rot = (PerspectiveFlag) ? (double)(int)GetDlgItemInt(hDlg, IDC_XPERSPECTIVE, &bTrans, TRUE) : 0.0;
		    y_rot = (PerspectiveFlag) ? (double)(int)GetDlgItemInt(hDlg, IDC_YPERSPECTIVE, &bTrans, TRUE) : 0.0;
		    z_rot = (PerspectiveFlag) ? (double)(int)GetDlgItemInt(hDlg, IDC_ZPERSPECTIVE, &bTrans, TRUE) : 0.0;
//		    if (_3dflag)
//			InitTransformation((hor + hor + mandel_width * ScreenRatio) / 2.0, (vert - vert * mandel_width) / 2.0, 0.0);	// translate to the centre of the object
		    hCtrl = GetDlgItem (hDlg, IDC_LINES);
		    DisplayLines = (BYTE)SendMessage(hCtrl, BM_GETCHECK, 0, 0L);
		    hCtrl = GetDlgItem (hDlg, IDC_AVERAGECENTRE);
		    FindCentre = (SendMessage(hCtrl, BM_GETCHECK, 0, 0L)) ? AVERAGE : BOUNDARY;
		    xAxis = GetDlgItemInt(hDlg, IDC_X, &bTrans, TRUE) - 1;
		    yAxis = GetDlgItemInt(hDlg, IDC_Y, &bTrans, TRUE) - 1;

		    hCtrl = GetDlgItem (hDlg, IDC_XREFLECT);
		    xSign = (SendMessage(hCtrl, BM_GETCHECK, 0, 0L)) ? -1 : 1;
		    hCtrl = GetDlgItem (hDlg, IDC_YREFLECT);
		    ySign = (SendMessage(hCtrl, BM_GETCHECK, 0, 0L)) ? -1 : 1;

		    if (MaxDimensions >= 3)
			zAxis = GetDlgItemInt(hDlg, IDC_Z, &bTrans, TRUE) - 1;
		    else
			zAxis = 1;
		    if (type == OSCILLATORS)
			{
			if (xAxis < 0 || yAxis < 0 || zAxis < 0  || xAxis >= MaxDimensions * 2 || yAxis >= MaxDimensions * 2 || zAxis >= MaxDimensions * 2)
			    MessageBox(hDlg, "One or more of the axes out of range", "Select Axes", MB_OK | MB_ICONEXCLAMATION);
			else
			    EndDialog(hDlg, TRUE);
			}
		    else	// fractal maps, surfaces, knots etc
			{
			if (xAxis < 0 || yAxis < 0 || zAxis < 0  || xAxis >= MaxDimensions || yAxis >= MaxDimensions || zAxis >= MaxDimensions)
			    MessageBox(hDlg, "One or more of the axes out of range", "Select Axes", MB_OK | MB_ICONEXCLAMATION);
			else
			    EndDialog(hDlg, TRUE);
			}
                    return ((DLGPROC)TRUE);
                  
                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    return (FALSE);
                    
	    return ((DLGPROC)TRUE);
	    }
	}
    return ((DLGPROC)FALSE);
    }

